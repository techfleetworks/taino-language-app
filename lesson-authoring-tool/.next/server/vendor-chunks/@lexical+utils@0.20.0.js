"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lexical+utils@0.20.0";
exports.ids = ["vendor-chunks/@lexical+utils@0.20.0"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/@lexical+utils@0.20.0/node_modules/@lexical/utils/LexicalUtils.dev.mjs":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@lexical+utils@0.20.0/node_modules/@lexical/utils/LexicalUtils.dev.mjs ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $dfs: () => (/* binding */ $dfs),\n/* harmony export */   $dfsIterator: () => (/* binding */ $dfsIterator),\n/* harmony export */   $filter: () => (/* binding */ $filter),\n/* harmony export */   $findMatchingParent: () => (/* binding */ $findMatchingParent),\n/* harmony export */   $getDepth: () => (/* binding */ $getDepth),\n/* harmony export */   $getNearestBlockElementAncestorOrThrow: () => (/* binding */ $getNearestBlockElementAncestorOrThrow),\n/* harmony export */   $getNearestNodeOfType: () => (/* binding */ $getNearestNodeOfType),\n/* harmony export */   $getNextRightPreorderNode: () => (/* binding */ $getNextRightPreorderNode),\n/* harmony export */   $getNextSiblingOrParentSibling: () => (/* binding */ $getNextSiblingOrParentSibling),\n/* harmony export */   $insertFirst: () => (/* binding */ $insertFirst),\n/* harmony export */   $insertNodeToNearestRoot: () => (/* binding */ $insertNodeToNearestRoot),\n/* harmony export */   $isEditorIsNestedEditor: () => (/* binding */ $isEditorIsNestedEditor),\n/* harmony export */   $restoreEditorState: () => (/* binding */ $restoreEditorState),\n/* harmony export */   $splitNode: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.$splitNode),\n/* harmony export */   $wrapNodeInElement: () => (/* binding */ $wrapNodeInElement),\n/* harmony export */   CAN_USE_BEFORE_INPUT: () => (/* binding */ CAN_USE_BEFORE_INPUT),\n/* harmony export */   CAN_USE_DOM: () => (/* binding */ CAN_USE_DOM),\n/* harmony export */   IS_ANDROID: () => (/* binding */ IS_ANDROID),\n/* harmony export */   IS_ANDROID_CHROME: () => (/* binding */ IS_ANDROID_CHROME),\n/* harmony export */   IS_APPLE: () => (/* binding */ IS_APPLE),\n/* harmony export */   IS_APPLE_WEBKIT: () => (/* binding */ IS_APPLE_WEBKIT),\n/* harmony export */   IS_CHROME: () => (/* binding */ IS_CHROME),\n/* harmony export */   IS_FIREFOX: () => (/* binding */ IS_FIREFOX),\n/* harmony export */   IS_IOS: () => (/* binding */ IS_IOS),\n/* harmony export */   IS_SAFARI: () => (/* binding */ IS_SAFARI),\n/* harmony export */   addClassNamesToElement: () => (/* binding */ addClassNamesToElement),\n/* harmony export */   calculateZoomLevel: () => (/* binding */ calculateZoomLevel),\n/* harmony export */   isBlockDomNode: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isBlockDomNode),\n/* harmony export */   isHTMLAnchorElement: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLAnchorElement),\n/* harmony export */   isHTMLElement: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement),\n/* harmony export */   isInlineDomNode: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isInlineDomNode),\n/* harmony export */   isMimeType: () => (/* binding */ isMimeType),\n/* harmony export */   markSelection: () => (/* binding */ markSelection),\n/* harmony export */   mediaFileReader: () => (/* binding */ mediaFileReader),\n/* harmony export */   mergeRegister: () => (/* binding */ mergeRegister),\n/* harmony export */   objectKlassEquals: () => (/* binding */ objectKlassEquals),\n/* harmony export */   positionNodeOnRange: () => (/* binding */ positionNodeOnRange),\n/* harmony export */   registerNestedElementResolver: () => (/* binding */ registerNestedElementResolver),\n/* harmony export */   removeClassNamesFromElement: () => (/* binding */ removeClassNamesFromElement)\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(rsc)/./node_modules/.pnpm/lexical@0.20.0/node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/selection */ \"(rsc)/./node_modules/.pnpm/@lexical+selection@0.20.0/node_modules/@lexical/selection/LexicalSelection.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM$1 = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM$1 && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE$1 = CAN_USE_DOM$1 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX$1 = CAN_USE_DOM$1 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT$1 = CAN_USE_DOM$1 && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI$1 = CAN_USE_DOM$1 && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS$1 = CAN_USE_DOM$1 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nconst IS_ANDROID$1 = CAN_USE_DOM$1 && /Android/.test(navigator.userAgent);\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME$1 = CAN_USE_DOM$1 && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_ANDROID_CHROME$1 = CAN_USE_DOM$1 && IS_ANDROID$1 && IS_CHROME$1;\nconst IS_APPLE_WEBKIT$1 = CAN_USE_DOM$1 && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME$1;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns a function that will execute all functions passed when called. It is generally used\n * to register multiple lexical listeners and then tear them down with a single function call, such\n * as React's useEffect hook.\n * @example\n * ```ts\n * useEffect(() => {\n *   return mergeRegister(\n *     editor.registerCommand(...registerCommand1 logic),\n *     editor.registerCommand(...registerCommand2 logic),\n *     editor.registerCommand(...registerCommand3 logic)\n *   )\n * }, [editor])\n * ```\n * In this case, useEffect is returning the function returned by mergeRegister as a cleanup\n * function to be executed after either the useEffect runs again (due to one of its dependencies\n * updating) or the component it resides in unmounts.\n * Note the functions don't neccesarily need to be in an array as all arguments\n * are considered to be the func argument and spread from there.\n * The order of cleanup is the reverse of the argument order. Generally it is\n * expected that the first \"acquire\" will be \"released\" last (LIFO order),\n * because a later step may have some dependency on an earlier one.\n * @param func - An array of cleanup functions meant to be executed by the returned function.\n * @returns the function which executes all the passed cleanup functions.\n */\nfunction mergeRegister(...func) {\n  return () => {\n    for (let i = func.length - 1; i >= 0; i--) {\n      func[i]();\n    }\n    // Clean up the references and make future calls a no-op\n    func.length = 0;\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction px(value) {\n  return `${value}px`;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst mutationObserverConfig = {\n  attributes: true,\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction positionNodeOnRange(editor, range, onReposition) {\n  let rootDOMNode = null;\n  let parentDOMNode = null;\n  let observer = null;\n  let lastNodes = [];\n  const wrapperNode = document.createElement('div');\n  function position() {\n    if (!(rootDOMNode !== null)) {\n      throw Error(`Unexpected null rootDOMNode`);\n    }\n    if (!(parentDOMNode !== null)) {\n      throw Error(`Unexpected null parentDOMNode`);\n    }\n    const {\n      left: rootLeft,\n      top: rootTop\n    } = rootDOMNode.getBoundingClientRect();\n    const parentDOMNode_ = parentDOMNode;\n    const rects = (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_1__.createRectsFromDOMRange)(editor, range);\n    if (!wrapperNode.isConnected) {\n      parentDOMNode_.append(wrapperNode);\n    }\n    let hasRepositioned = false;\n    for (let i = 0; i < rects.length; i++) {\n      const rect = rects[i];\n      // Try to reuse the previously created Node when possible, no need to\n      // remove/create on the most common case reposition case\n      const rectNode = lastNodes[i] || document.createElement('div');\n      const rectNodeStyle = rectNode.style;\n      if (rectNodeStyle.position !== 'absolute') {\n        rectNodeStyle.position = 'absolute';\n        hasRepositioned = true;\n      }\n      const left = px(rect.left - rootLeft);\n      if (rectNodeStyle.left !== left) {\n        rectNodeStyle.left = left;\n        hasRepositioned = true;\n      }\n      const top = px(rect.top - rootTop);\n      if (rectNodeStyle.top !== top) {\n        rectNode.style.top = top;\n        hasRepositioned = true;\n      }\n      const width = px(rect.width);\n      if (rectNodeStyle.width !== width) {\n        rectNode.style.width = width;\n        hasRepositioned = true;\n      }\n      const height = px(rect.height);\n      if (rectNodeStyle.height !== height) {\n        rectNode.style.height = height;\n        hasRepositioned = true;\n      }\n      if (rectNode.parentNode !== wrapperNode) {\n        wrapperNode.append(rectNode);\n        hasRepositioned = true;\n      }\n      lastNodes[i] = rectNode;\n    }\n    while (lastNodes.length > rects.length) {\n      lastNodes.pop();\n    }\n    if (hasRepositioned) {\n      onReposition(lastNodes);\n    }\n  }\n  function stop() {\n    parentDOMNode = null;\n    rootDOMNode = null;\n    if (observer !== null) {\n      observer.disconnect();\n    }\n    observer = null;\n    wrapperNode.remove();\n    for (const node of lastNodes) {\n      node.remove();\n    }\n    lastNodes = [];\n  }\n  function restart() {\n    const currentRootDOMNode = editor.getRootElement();\n    if (currentRootDOMNode === null) {\n      return stop();\n    }\n    const currentParentDOMNode = currentRootDOMNode.parentElement;\n    if (!(currentParentDOMNode instanceof HTMLElement)) {\n      return stop();\n    }\n    stop();\n    rootDOMNode = currentRootDOMNode;\n    parentDOMNode = currentParentDOMNode;\n    observer = new MutationObserver(mutations => {\n      const nextRootDOMNode = editor.getRootElement();\n      const nextParentDOMNode = nextRootDOMNode && nextRootDOMNode.parentElement;\n      if (nextRootDOMNode !== rootDOMNode || nextParentDOMNode !== parentDOMNode) {\n        return restart();\n      }\n      for (const mutation of mutations) {\n        if (!wrapperNode.contains(mutation.target)) {\n          // TODO throttle\n          return position();\n        }\n      }\n    });\n    observer.observe(currentParentDOMNode, mutationObserverConfig);\n    position();\n  }\n  const removeRootListener = editor.registerRootListener(restart);\n  return () => {\n    removeRootListener();\n    stop();\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction markSelection(editor, onReposition) {\n  let previousAnchorNode = null;\n  let previousAnchorOffset = null;\n  let previousFocusNode = null;\n  let previousFocusOffset = null;\n  let removeRangeListener = () => {};\n  function compute(editorState) {\n    editorState.read(() => {\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n        // TODO\n        previousAnchorNode = null;\n        previousAnchorOffset = null;\n        previousFocusNode = null;\n        previousFocusOffset = null;\n        removeRangeListener();\n        removeRangeListener = () => {};\n        return;\n      }\n      const {\n        anchor,\n        focus\n      } = selection;\n      const currentAnchorNode = anchor.getNode();\n      const currentAnchorNodeKey = currentAnchorNode.getKey();\n      const currentAnchorOffset = anchor.offset;\n      const currentFocusNode = focus.getNode();\n      const currentFocusNodeKey = currentFocusNode.getKey();\n      const currentFocusOffset = focus.offset;\n      const currentAnchorNodeDOM = editor.getElementByKey(currentAnchorNodeKey);\n      const currentFocusNodeDOM = editor.getElementByKey(currentFocusNodeKey);\n      const differentAnchorDOM = previousAnchorNode === null || currentAnchorNodeDOM === null || currentAnchorOffset !== previousAnchorOffset || currentAnchorNodeKey !== previousAnchorNode.getKey() || currentAnchorNode !== previousAnchorNode && (!(previousAnchorNode instanceof lexical__WEBPACK_IMPORTED_MODULE_0__.TextNode) || currentAnchorNode.updateDOM(previousAnchorNode, currentAnchorNodeDOM, editor._config));\n      const differentFocusDOM = previousFocusNode === null || currentFocusNodeDOM === null || currentFocusOffset !== previousFocusOffset || currentFocusNodeKey !== previousFocusNode.getKey() || currentFocusNode !== previousFocusNode && (!(previousFocusNode instanceof lexical__WEBPACK_IMPORTED_MODULE_0__.TextNode) || currentFocusNode.updateDOM(previousFocusNode, currentFocusNodeDOM, editor._config));\n      if (differentAnchorDOM || differentFocusDOM) {\n        const anchorHTMLElement = editor.getElementByKey(anchor.getNode().getKey());\n        const focusHTMLElement = editor.getElementByKey(focus.getNode().getKey());\n        // TODO handle selection beyond the common TextNode\n        if (anchorHTMLElement !== null && focusHTMLElement !== null && anchorHTMLElement.tagName === 'SPAN' && focusHTMLElement.tagName === 'SPAN') {\n          const range = document.createRange();\n          let firstHTMLElement;\n          let firstOffset;\n          let lastHTMLElement;\n          let lastOffset;\n          if (focus.isBefore(anchor)) {\n            firstHTMLElement = focusHTMLElement;\n            firstOffset = focus.offset;\n            lastHTMLElement = anchorHTMLElement;\n            lastOffset = anchor.offset;\n          } else {\n            firstHTMLElement = anchorHTMLElement;\n            firstOffset = anchor.offset;\n            lastHTMLElement = focusHTMLElement;\n            lastOffset = focus.offset;\n          }\n          const firstTextNode = firstHTMLElement.firstChild;\n          if (!(firstTextNode !== null)) {\n            throw Error(`Expected text node to be first child of span`);\n          }\n          const lastTextNode = lastHTMLElement.firstChild;\n          if (!(lastTextNode !== null)) {\n            throw Error(`Expected text node to be first child of span`);\n          }\n          range.setStart(firstTextNode, firstOffset);\n          range.setEnd(lastTextNode, lastOffset);\n          removeRangeListener();\n          removeRangeListener = positionNodeOnRange(editor, range, domNodes => {\n            for (const domNode of domNodes) {\n              const domNodeStyle = domNode.style;\n              if (domNodeStyle.background !== 'Highlight') {\n                domNodeStyle.background = 'Highlight';\n              }\n              if (domNodeStyle.color !== 'HighlightText') {\n                domNodeStyle.color = 'HighlightText';\n              }\n              if (domNodeStyle.zIndex !== '-1') {\n                domNodeStyle.zIndex = '-1';\n              }\n              if (domNodeStyle.pointerEvents !== 'none') {\n                domNodeStyle.pointerEvents = 'none';\n              }\n              if (domNodeStyle.marginTop !== px(-1.5)) {\n                domNodeStyle.marginTop = px(-1.5);\n              }\n              if (domNodeStyle.paddingTop !== px(4)) {\n                domNodeStyle.paddingTop = px(4);\n              }\n              if (domNodeStyle.paddingBottom !== px(0)) {\n                domNodeStyle.paddingBottom = px(0);\n              }\n            }\n            if (onReposition !== undefined) {\n              onReposition(domNodes);\n            }\n          });\n        }\n      }\n      previousAnchorNode = currentAnchorNode;\n      previousAnchorOffset = currentAnchorOffset;\n      previousFocusNode = currentFocusNode;\n      previousFocusOffset = currentFocusOffset;\n    });\n  }\n  compute(editor.getEditorState());\n  return mergeRegister(editor.registerUpdateListener(({\n    editorState\n  }) => compute(editorState)), removeRangeListener, () => {\n    removeRangeListener();\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Hotfix to export these with inlined types #5918\nconst CAN_USE_BEFORE_INPUT = CAN_USE_BEFORE_INPUT$1;\nconst CAN_USE_DOM = CAN_USE_DOM$1;\nconst IS_ANDROID = IS_ANDROID$1;\nconst IS_ANDROID_CHROME = IS_ANDROID_CHROME$1;\nconst IS_APPLE = IS_APPLE$1;\nconst IS_APPLE_WEBKIT = IS_APPLE_WEBKIT$1;\nconst IS_CHROME = IS_CHROME$1;\nconst IS_FIREFOX = IS_FIREFOX$1;\nconst IS_IOS = IS_IOS$1;\nconst IS_SAFARI = IS_SAFARI$1;\n\n/**\n * Takes an HTML element and adds the classNames passed within an array,\n * ignoring any non-string types. A space can be used to add multiple classes\n * eg. addClassNamesToElement(element, ['element-inner active', true, null])\n * will add both 'element-inner' and 'active' as classes to that element.\n * @param element - The element in which the classes are added\n * @param classNames - An array defining the class names to add to the element\n */\nfunction addClassNamesToElement(element, ...classNames) {\n  const classesToAdd = normalizeClassNames(...classNames);\n  if (classesToAdd.length > 0) {\n    element.classList.add(...classesToAdd);\n  }\n}\n\n/**\n * Takes an HTML element and removes the classNames passed within an array,\n * ignoring any non-string types. A space can be used to remove multiple classes\n * eg. removeClassNamesFromElement(element, ['active small', true, null])\n * will remove both the 'active' and 'small' classes from that element.\n * @param element - The element in which the classes are removed\n * @param classNames - An array defining the class names to remove from the element\n */\nfunction removeClassNamesFromElement(element, ...classNames) {\n  const classesToRemove = normalizeClassNames(...classNames);\n  if (classesToRemove.length > 0) {\n    element.classList.remove(...classesToRemove);\n  }\n}\n\n/**\n * Returns true if the file type matches the types passed within the acceptableMimeTypes array, false otherwise.\n * The types passed must be strings and are CASE-SENSITIVE.\n * eg. if file is of type 'text' and acceptableMimeTypes = ['TEXT', 'IMAGE'] the function will return false.\n * @param file - The file you want to type check.\n * @param acceptableMimeTypes - An array of strings of types which the file is checked against.\n * @returns true if the file is an acceptable mime type, false otherwise.\n */\nfunction isMimeType(file, acceptableMimeTypes) {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Lexical File Reader with:\n *  1. MIME type support\n *  2. batched results (HistoryPlugin compatibility)\n *  3. Order aware (respects the order when multiple Files are passed)\n *\n * const filesResult = await mediaFileReader(files, ['image/']);\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', \\\\{\n *   src: file.result,\n * \\\\}));\n */\nfunction mediaFileReader(files, acceptableMimeTypes) {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed = [];\n    const handleNextFile = () => {\n      const {\n        done,\n        value: file\n      } = filesIterator.next();\n      if (done) {\n        return resolve(processed);\n      }\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n        if (typeof result === 'string') {\n          processed.push({\n            file,\n            result\n          });\n        }\n        handleNextFile();\n      });\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n    handleNextFile();\n  });\n}\n/**\n * \"Depth-First Search\" starts at the root/top node of a tree and goes as far as it can down a branch end\n * before backtracking and finding a new path. Consider solving a maze by hugging either wall, moving down a\n * branch until you hit a dead-end (leaf) and backtracking to find the nearest branching path and repeat.\n * It will then return all the nodes found in the search in an array of objects.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An array of objects of all the nodes found by the search, including their depth into the tree.\n * \\\\{depth: number, node: LexicalNode\\\\} It will always return at least 1 node (the start node).\n */\nfunction $dfs(startNode, endNode) {\n  return Array.from($dfsIterator(startNode, endNode));\n}\nconst iteratorDone = {\n  done: true,\n  value: undefined\n};\nconst iteratorNotDone = value => ({\n  done: false,\n  value\n});\n\n/**\n * $dfs iterator. Tree traversal is done on the fly as new values are requested with O(1) memory.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An iterator, each yielded value is a DFSNode. It will always return at least 1 node (the start node).\n */\nfunction $dfsIterator(startNode, endNode) {\n  const start = (startNode || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)()).getLatest();\n  const startDepth = $getDepth(start);\n  const end = endNode;\n  let node = start;\n  let depth = startDepth;\n  let isFirstNext = true;\n  const iterator = {\n    next() {\n      if (node === null) {\n        return iteratorDone;\n      }\n      if (isFirstNext) {\n        isFirstNext = false;\n        return iteratorNotDone({\n          depth,\n          node\n        });\n      }\n      if (node === end) {\n        return iteratorDone;\n      }\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && node.getChildrenSize() > 0) {\n        node = node.getFirstChild();\n        depth++;\n      } else {\n        let depthDiff;\n        [node, depthDiff] = $getNextSiblingOrParentSibling(node) || [null, 0];\n        depth += depthDiff;\n        if (end == null && depth <= startDepth) {\n          node = null;\n        }\n      }\n      if (node === null) {\n        return iteratorDone;\n      }\n      return iteratorNotDone({\n        depth,\n        node\n      });\n    },\n    [Symbol.iterator]() {\n      return iterator;\n    }\n  };\n  return iterator;\n}\n\n/**\n * Returns the Node sibling when this exists, otherwise the closest parent sibling. For example\n * R -> P -> T1, T2\n *   -> P2\n * returns T2 for node T1, P2 for node T2, and null for node P2.\n * @param node LexicalNode.\n * @returns An array (tuple) containing the found Lexical node and the depth difference, or null, if this node doesn't exist.\n */\nfunction $getNextSiblingOrParentSibling(node) {\n  let node_ = node;\n  // Find immediate sibling or nearest parent sibling\n  let sibling = null;\n  let depthDiff = 0;\n  while (sibling === null && node_ !== null) {\n    sibling = node_.getNextSibling();\n    if (sibling === null) {\n      node_ = node_.getParent();\n      depthDiff--;\n    } else {\n      node_ = sibling;\n    }\n  }\n  if (node_ === null) {\n    return null;\n  }\n  return [node_, depthDiff];\n}\nfunction $getDepth(node) {\n  let innerNode = node;\n  let depth = 0;\n  while ((innerNode = innerNode.getParent()) !== null) {\n    depth++;\n  }\n  return depth;\n}\n\n/**\n * Performs a right-to-left preorder tree traversal.\n * From the starting node it goes to the rightmost child, than backtracks to paret and finds new rightmost path.\n * It will return the next node in traversal sequence after the startingNode.\n * The traversal is similar to $dfs functions above, but the nodes are visited right-to-left, not left-to-right.\n * @param startingNode - The node to start the search.\n * @returns The next node in pre-order right to left traversal sequence or `null`, if the node does not exist\n */\nfunction $getNextRightPreorderNode(startingNode) {\n  let node = startingNode;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && node.getChildrenSize() > 0) {\n    node = node.getLastChild();\n  } else {\n    let sibling = null;\n    while (sibling === null && node !== null) {\n      sibling = node.getPreviousSibling();\n      if (sibling === null) {\n        node = node.getParent();\n      } else {\n        node = sibling;\n      }\n    }\n  }\n  return node;\n}\n\n/**\n * Takes a node and traverses up its ancestors (toward the root node)\n * in order to find a specific type of node.\n * @param node - the node to begin searching.\n * @param klass - an instance of the type of node to look for.\n * @returns the node of type klass that was passed, or null if none exist.\n */\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n    parent = parent.getParent();\n  }\n  return null;\n}\n\n/**\n * Returns the element node of the nearest ancestor, otherwise throws an error.\n * @param startNode - The starting node of the search\n * @returns The ancestor node found\n */\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && !node.isInline());\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(blockNode)) {\n    {\n      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n  return blockNode;\n}\n/**\n * Starts with a node and moves up the tree (toward the root node) to find a matching node based on\n * the search parameters of the findFn. (Consider JavaScripts' .find() function where a testing function must be\n * passed as an argument. eg. if( (node) => node.__type === 'div') ) return true; otherwise return false\n * @param startingNode - The node where the search starts.\n * @param findFn - A testing function that returns true if the current node satisfies the testing parameters.\n * @returns A parent node that matches the findFn parameters, or null if one wasn't found.\n */\nconst $findMatchingParent = (startingNode, findFn) => {\n  let curr = startingNode;\n  while (curr !== (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n    curr = curr.getParent();\n  }\n  return null;\n};\n\n/**\n * Attempts to resolve nested element nodes of the same type into a single node of that type.\n * It is generally used for marks/commenting\n * @param editor - The lexical editor\n * @param targetNode - The target for the nested element to be extracted from.\n * @param cloneNode - See {@link $createMarkNode}\n * @param handleOverlap - Handles any overlap between the node to extract and the targetNode\n * @returns The lexical editor\n */\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n    let parentNode = node;\n    let childNode = node;\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n    return null;\n  };\n  const $elementNodeTransform = node => {\n    const match = $findMatch(node);\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match;\n\n      // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(targetNode, $elementNodeTransform);\n}\n\n/**\n * Clones the editor and marks it as dirty to be reconciled. If there was a selection,\n * it would be set back to its previous state, or null otherwise.\n * @param editor - The lexical editor\n * @param editorState - The editor's state\n */\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map();\n  const activeEditorState = editor._pendingEditorState;\n  for (const [key, node] of editorState._nodeMap) {\n    nodeMap.set(key, (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$cloneWithProperties)(node));\n  }\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n  editor._dirtyType = FULL_RECONCILE;\n  const selection = editorState._selection;\n  (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(selection === null ? null : selection.clone());\n}\n\n/**\n * If the selected insertion area is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be appended there, otherwise, it will be inserted before the insertion area.\n * If there is no selection where the node is to be inserted, it will be appended after any current nodes\n * within the tree, as a child of the root node. A paragraph node will then be added after the inserted node and selected.\n * @param node - The node to be inserted\n * @returns The node after its insertion\n */\nfunction $insertNodeToNearestRoot(node) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)() || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    const {\n      focus\n    } = selection;\n    const focusNode = focus.getNode();\n    const focusOffset = focus.offset;\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(focusNode)) {\n      const focusChild = focusNode.getChildAtIndex(focusOffset);\n      if (focusChild == null) {\n        focusNode.append(node);\n      } else {\n        focusChild.insertBefore(node);\n      }\n      node.selectNext();\n    } else {\n      let splitNode;\n      let splitOffset;\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(focusNode)) {\n        splitNode = focusNode.getParentOrThrow();\n        splitOffset = focusNode.getIndexWithinParent();\n        if (focusOffset > 0) {\n          splitOffset += 1;\n          focusNode.splitText(focusOffset);\n        }\n      } else {\n        splitNode = focusNode;\n        splitOffset = focusOffset;\n      }\n      const [, rightTree] = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$splitNode)(splitNode, splitOffset);\n      rightTree.insertBefore(node);\n      rightTree.selectStart();\n    }\n  } else {\n    if (selection != null) {\n      const nodes = selection.getNodes();\n      nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);\n    } else {\n      const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n      root.append(node);\n    }\n    const paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n    node.insertAfter(paragraphNode);\n    paragraphNode.select();\n  }\n  return node.getLatest();\n}\n\n/**\n * Wraps the node into another node created from a createElementNode function, eg. $createParagraphNode\n * @param node - Node to be wrapped.\n * @param createElementNode - Creates a new lexical element to wrap the to-be-wrapped node and returns it.\n * @returns A new lexical element with the previous node appended within (as a child, including its children).\n */\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * @param object = The instance of the type\n * @param objectClass = The class of the type\n * @returns Whether the object is has the same Klass of the objectClass, ignoring the difference across window (e.g. different iframs)\n */\nfunction objectKlassEquals(object, objectClass) {\n  return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;\n}\n\n/**\n * Filter the nodes\n * @param nodes Array of nodes that needs to be filtered\n * @param filterFn A filter function that returns node if the current node satisfies the condition otherwise null\n * @returns Array of filtered nodes\n */\n\nfunction $filter(nodes, filterFn) {\n  const result = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = filterFn(nodes[i]);\n    if (node !== null) {\n      result.push(node);\n    }\n  }\n  return result;\n}\n/**\n * Appends the node before the first child of the parent node\n * @param parent A parent node\n * @param node Node that needs to be appended\n */\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\n\n/**\n * Calculates the zoom level of an element as a result of using\n * css zoom property.\n * @param element\n */\nfunction calculateZoomLevel(element) {\n  if (IS_FIREFOX) {\n    return 1;\n  }\n  let zoom = 1;\n  while (element) {\n    zoom *= Number(window.getComputedStyle(element).getPropertyValue('zoom'));\n    element = element.parentElement;\n  }\n  return zoom;\n}\n\n/**\n * Checks if the editor is a nested editor created by LexicalNestedComposer\n */\nfunction $isEditorIsNestedEditor(editor) {\n  return editor._parentEditor !== null;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxleGljYWwrdXRpbHNAMC4yMC4wL25vZGVfbW9kdWxlcy9AbGV4aWNhbC91dGlscy9MZXhpY2FsVXRpbHMuZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUrTjtBQUNySDtBQUM3Qzs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esa0JBQWtCLDJFQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0RBQWE7QUFDckMsV0FBVywwREFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzUkFBc1IsNkNBQVE7QUFDOVIsNFFBQTRRLDZDQUFRO0FBQ3BSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sb0NBQW9DO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlEQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsdURBQWM7QUFDeEI7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sdURBQWM7QUFDcEI7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsdURBQWM7QUFDekUsT0FBTyx1REFBYztBQUNyQjtBQUNBLG1DQUFtQyxpQkFBaUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlEQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0JBQXdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw2REFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxzREFBYTtBQUNmOztBQUVBO0FBQ0EscUVBQXFFLGtDQUFrQztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzREFBYSxNQUFNLDhEQUFxQjtBQUM1RCxNQUFNLDBEQUFpQjtBQUN2QjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRLDREQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxVQUFVLG9EQUFXO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbURBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixtQkFBbUIsaURBQVE7QUFDM0I7QUFDQTtBQUNBLDBCQUEwQiw2REFBb0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNm5CIiwic291cmNlcyI6WyIvVXNlcnMva2FyZWxsZS92c2Nwcm9qZWN0cy90ZWNoLWZsZWV0L3RhaW5vLWxhbmd1YWdlLWFwcC9sZXNzb24tYXV0aG9yaW5nL25vZGVfbW9kdWxlcy8ucG5wbS9AbGV4aWNhbCt1dGlsc0AwLjIwLjAvbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3V0aWxzL0xleGljYWxVdGlscy5kZXYubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgJGdldFNlbGVjdGlvbiwgJGlzUmFuZ2VTZWxlY3Rpb24sIFRleHROb2RlLCAkZ2V0Um9vdCwgJGlzRWxlbWVudE5vZGUsICRjbG9uZVdpdGhQcm9wZXJ0aWVzLCAkc2V0U2VsZWN0aW9uLCAkZ2V0UHJldmlvdXNTZWxlY3Rpb24sICRpc1Jvb3RPclNoYWRvd1Jvb3QsICRpc1RleHROb2RlLCAkc3BsaXROb2RlLCAkY3JlYXRlUGFyYWdyYXBoTm9kZSB9IGZyb20gJ2xleGljYWwnO1xuZXhwb3J0IHsgJHNwbGl0Tm9kZSwgaXNCbG9ja0RvbU5vZGUsIGlzSFRNTEFuY2hvckVsZW1lbnQsIGlzSFRNTEVsZW1lbnQsIGlzSW5saW5lRG9tTm9kZSB9IGZyb20gJ2xleGljYWwnO1xuaW1wb3J0IHsgY3JlYXRlUmVjdHNGcm9tRE9NUmFuZ2UgfSBmcm9tICdAbGV4aWNhbC9zZWxlY3Rpb24nO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IENBTl9VU0VfRE9NJDEgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IGRvY3VtZW50TW9kZSA9IENBTl9VU0VfRE9NJDEgJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQgPyBkb2N1bWVudC5kb2N1bWVudE1vZGUgOiBudWxsO1xuY29uc3QgSVNfQVBQTEUkMSA9IENBTl9VU0VfRE9NJDEgJiYgL01hY3xpUG9kfGlQaG9uZXxpUGFkLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG5jb25zdCBJU19GSVJFRk9YJDEgPSBDQU5fVVNFX0RPTSQxICYmIC9eKD8hLipTZWFtb25rZXkpKD89LipGaXJlZm94KS4qL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbmNvbnN0IENBTl9VU0VfQkVGT1JFX0lOUFVUJDEgPSBDQU5fVVNFX0RPTSQxICYmICdJbnB1dEV2ZW50JyBpbiB3aW5kb3cgJiYgIWRvY3VtZW50TW9kZSA/ICdnZXRUYXJnZXRSYW5nZXMnIGluIG5ldyB3aW5kb3cuSW5wdXRFdmVudCgnaW5wdXQnKSA6IGZhbHNlO1xuY29uc3QgSVNfU0FGQVJJJDEgPSBDQU5fVVNFX0RPTSQxICYmIC9WZXJzaW9uXFwvW1xcZC5dKy4qU2FmYXJpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuY29uc3QgSVNfSU9TJDEgPSBDQU5fVVNFX0RPTSQxICYmIC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICF3aW5kb3cuTVNTdHJlYW07XG5jb25zdCBJU19BTkRST0lEJDEgPSBDQU5fVVNFX0RPTSQxICYmIC9BbmRyb2lkLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vLyBLZWVwIHRoZXNlIGluIGNhc2Ugd2UgbmVlZCB0byB1c2UgdGhlbSBpbiB0aGUgZnV0dXJlLlxuLy8gZXhwb3J0IGNvbnN0IElTX1dJTkRPV1M6IGJvb2xlYW4gPSBDQU5fVVNFX0RPTSAmJiAvV2luLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG5jb25zdCBJU19DSFJPTUUkMSA9IENBTl9VU0VfRE9NJDEgJiYgL14oPz0uKkNocm9tZSkuKi9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4vLyBleHBvcnQgY29uc3QgY2FuVXNlVGV4dElucHV0RXZlbnQ6IGJvb2xlYW4gPSBDQU5fVVNFX0RPTSAmJiAnVGV4dEV2ZW50JyBpbiB3aW5kb3cgJiYgIWRvY3VtZW50TW9kZTtcblxuY29uc3QgSVNfQU5EUk9JRF9DSFJPTUUkMSA9IENBTl9VU0VfRE9NJDEgJiYgSVNfQU5EUk9JRCQxICYmIElTX0NIUk9NRSQxO1xuY29uc3QgSVNfQVBQTEVfV0VCS0lUJDEgPSBDQU5fVVNFX0RPTSQxICYmIC9BcHBsZVdlYktpdFxcL1tcXGQuXSsvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIUlTX0NIUk9NRSQxO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzTmFtZXMoLi4uY2xhc3NOYW1lcykge1xuICBjb25zdCBydmFsID0gW107XG4gIGZvciAoY29uc3QgY2xhc3NOYW1lIG9mIGNsYXNzTmFtZXMpIHtcbiAgICBpZiAoY2xhc3NOYW1lICYmIHR5cGVvZiBjbGFzc05hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBmb3IgKGNvbnN0IFtzXSBvZiBjbGFzc05hbWUubWF0Y2hBbGwoL1xcUysvZykpIHtcbiAgICAgICAgcnZhbC5wdXNoKHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcnZhbDtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgZXhlY3V0ZSBhbGwgZnVuY3Rpb25zIHBhc3NlZCB3aGVuIGNhbGxlZC4gSXQgaXMgZ2VuZXJhbGx5IHVzZWRcbiAqIHRvIHJlZ2lzdGVyIG11bHRpcGxlIGxleGljYWwgbGlzdGVuZXJzIGFuZCB0aGVuIHRlYXIgdGhlbSBkb3duIHdpdGggYSBzaW5nbGUgZnVuY3Rpb24gY2FsbCwgc3VjaFxuICogYXMgUmVhY3QncyB1c2VFZmZlY3QgaG9vay5cbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogdXNlRWZmZWN0KCgpID0+IHtcbiAqICAgcmV0dXJuIG1lcmdlUmVnaXN0ZXIoXG4gKiAgICAgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZCguLi5yZWdpc3RlckNvbW1hbmQxIGxvZ2ljKSxcbiAqICAgICBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKC4uLnJlZ2lzdGVyQ29tbWFuZDIgbG9naWMpLFxuICogICAgIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoLi4ucmVnaXN0ZXJDb21tYW5kMyBsb2dpYylcbiAqICAgKVxuICogfSwgW2VkaXRvcl0pXG4gKiBgYGBcbiAqIEluIHRoaXMgY2FzZSwgdXNlRWZmZWN0IGlzIHJldHVybmluZyB0aGUgZnVuY3Rpb24gcmV0dXJuZWQgYnkgbWVyZ2VSZWdpc3RlciBhcyBhIGNsZWFudXBcbiAqIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIGVpdGhlciB0aGUgdXNlRWZmZWN0IHJ1bnMgYWdhaW4gKGR1ZSB0byBvbmUgb2YgaXRzIGRlcGVuZGVuY2llc1xuICogdXBkYXRpbmcpIG9yIHRoZSBjb21wb25lbnQgaXQgcmVzaWRlcyBpbiB1bm1vdW50cy5cbiAqIE5vdGUgdGhlIGZ1bmN0aW9ucyBkb24ndCBuZWNjZXNhcmlseSBuZWVkIHRvIGJlIGluIGFuIGFycmF5IGFzIGFsbCBhcmd1bWVudHNcbiAqIGFyZSBjb25zaWRlcmVkIHRvIGJlIHRoZSBmdW5jIGFyZ3VtZW50IGFuZCBzcHJlYWQgZnJvbSB0aGVyZS5cbiAqIFRoZSBvcmRlciBvZiBjbGVhbnVwIGlzIHRoZSByZXZlcnNlIG9mIHRoZSBhcmd1bWVudCBvcmRlci4gR2VuZXJhbGx5IGl0IGlzXG4gKiBleHBlY3RlZCB0aGF0IHRoZSBmaXJzdCBcImFjcXVpcmVcIiB3aWxsIGJlIFwicmVsZWFzZWRcIiBsYXN0IChMSUZPIG9yZGVyKSxcbiAqIGJlY2F1c2UgYSBsYXRlciBzdGVwIG1heSBoYXZlIHNvbWUgZGVwZW5kZW5jeSBvbiBhbiBlYXJsaWVyIG9uZS5cbiAqIEBwYXJhbSBmdW5jIC0gQW4gYXJyYXkgb2YgY2xlYW51cCBmdW5jdGlvbnMgbWVhbnQgdG8gYmUgZXhlY3V0ZWQgYnkgdGhlIHJldHVybmVkIGZ1bmN0aW9uLlxuICogQHJldHVybnMgdGhlIGZ1bmN0aW9uIHdoaWNoIGV4ZWN1dGVzIGFsbCB0aGUgcGFzc2VkIGNsZWFudXAgZnVuY3Rpb25zLlxuICovXG5mdW5jdGlvbiBtZXJnZVJlZ2lzdGVyKC4uLmZ1bmMpIHtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBmb3IgKGxldCBpID0gZnVuYy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgZnVuY1tpXSgpO1xuICAgIH1cbiAgICAvLyBDbGVhbiB1cCB0aGUgcmVmZXJlbmNlcyBhbmQgbWFrZSBmdXR1cmUgY2FsbHMgYSBuby1vcFxuICAgIGZ1bmMubGVuZ3RoID0gMDtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBweCh2YWx1ZSkge1xuICByZXR1cm4gYCR7dmFsdWV9cHhgO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IG11dGF0aW9uT2JzZXJ2ZXJDb25maWcgPSB7XG4gIGF0dHJpYnV0ZXM6IHRydWUsXG4gIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gIGNoaWxkTGlzdDogdHJ1ZSxcbiAgc3VidHJlZTogdHJ1ZVxufTtcbmZ1bmN0aW9uIHBvc2l0aW9uTm9kZU9uUmFuZ2UoZWRpdG9yLCByYW5nZSwgb25SZXBvc2l0aW9uKSB7XG4gIGxldCByb290RE9NTm9kZSA9IG51bGw7XG4gIGxldCBwYXJlbnRET01Ob2RlID0gbnVsbDtcbiAgbGV0IG9ic2VydmVyID0gbnVsbDtcbiAgbGV0IGxhc3ROb2RlcyA9IFtdO1xuICBjb25zdCB3cmFwcGVyTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBmdW5jdGlvbiBwb3NpdGlvbigpIHtcbiAgICBpZiAoIShyb290RE9NTm9kZSAhPT0gbnVsbCkpIHtcbiAgICAgIHRocm93IEVycm9yKGBVbmV4cGVjdGVkIG51bGwgcm9vdERPTU5vZGVgKTtcbiAgICB9XG4gICAgaWYgKCEocGFyZW50RE9NTm9kZSAhPT0gbnVsbCkpIHtcbiAgICAgIHRocm93IEVycm9yKGBVbmV4cGVjdGVkIG51bGwgcGFyZW50RE9NTm9kZWApO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBsZWZ0OiByb290TGVmdCxcbiAgICAgIHRvcDogcm9vdFRvcFxuICAgIH0gPSByb290RE9NTm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBwYXJlbnRET01Ob2RlXyA9IHBhcmVudERPTU5vZGU7XG4gICAgY29uc3QgcmVjdHMgPSBjcmVhdGVSZWN0c0Zyb21ET01SYW5nZShlZGl0b3IsIHJhbmdlKTtcbiAgICBpZiAoIXdyYXBwZXJOb2RlLmlzQ29ubmVjdGVkKSB7XG4gICAgICBwYXJlbnRET01Ob2RlXy5hcHBlbmQod3JhcHBlck5vZGUpO1xuICAgIH1cbiAgICBsZXQgaGFzUmVwb3NpdGlvbmVkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVjdCA9IHJlY3RzW2ldO1xuICAgICAgLy8gVHJ5IHRvIHJldXNlIHRoZSBwcmV2aW91c2x5IGNyZWF0ZWQgTm9kZSB3aGVuIHBvc3NpYmxlLCBubyBuZWVkIHRvXG4gICAgICAvLyByZW1vdmUvY3JlYXRlIG9uIHRoZSBtb3N0IGNvbW1vbiBjYXNlIHJlcG9zaXRpb24gY2FzZVxuICAgICAgY29uc3QgcmVjdE5vZGUgPSBsYXN0Tm9kZXNbaV0gfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBjb25zdCByZWN0Tm9kZVN0eWxlID0gcmVjdE5vZGUuc3R5bGU7XG4gICAgICBpZiAocmVjdE5vZGVTdHlsZS5wb3NpdGlvbiAhPT0gJ2Fic29sdXRlJykge1xuICAgICAgICByZWN0Tm9kZVN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgaGFzUmVwb3NpdGlvbmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxlZnQgPSBweChyZWN0LmxlZnQgLSByb290TGVmdCk7XG4gICAgICBpZiAocmVjdE5vZGVTdHlsZS5sZWZ0ICE9PSBsZWZ0KSB7XG4gICAgICAgIHJlY3ROb2RlU3R5bGUubGVmdCA9IGxlZnQ7XG4gICAgICAgIGhhc1JlcG9zaXRpb25lZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCB0b3AgPSBweChyZWN0LnRvcCAtIHJvb3RUb3ApO1xuICAgICAgaWYgKHJlY3ROb2RlU3R5bGUudG9wICE9PSB0b3ApIHtcbiAgICAgICAgcmVjdE5vZGUuc3R5bGUudG9wID0gdG9wO1xuICAgICAgICBoYXNSZXBvc2l0aW9uZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgd2lkdGggPSBweChyZWN0LndpZHRoKTtcbiAgICAgIGlmIChyZWN0Tm9kZVN0eWxlLndpZHRoICE9PSB3aWR0aCkge1xuICAgICAgICByZWN0Tm9kZS5zdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICBoYXNSZXBvc2l0aW9uZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgaGVpZ2h0ID0gcHgocmVjdC5oZWlnaHQpO1xuICAgICAgaWYgKHJlY3ROb2RlU3R5bGUuaGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgICAgcmVjdE5vZGUuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBoYXNSZXBvc2l0aW9uZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHJlY3ROb2RlLnBhcmVudE5vZGUgIT09IHdyYXBwZXJOb2RlKSB7XG4gICAgICAgIHdyYXBwZXJOb2RlLmFwcGVuZChyZWN0Tm9kZSk7XG4gICAgICAgIGhhc1JlcG9zaXRpb25lZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBsYXN0Tm9kZXNbaV0gPSByZWN0Tm9kZTtcbiAgICB9XG4gICAgd2hpbGUgKGxhc3ROb2Rlcy5sZW5ndGggPiByZWN0cy5sZW5ndGgpIHtcbiAgICAgIGxhc3ROb2Rlcy5wb3AoKTtcbiAgICB9XG4gICAgaWYgKGhhc1JlcG9zaXRpb25lZCkge1xuICAgICAgb25SZXBvc2l0aW9uKGxhc3ROb2Rlcyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgcGFyZW50RE9NTm9kZSA9IG51bGw7XG4gICAgcm9vdERPTU5vZGUgPSBudWxsO1xuICAgIGlmIChvYnNlcnZlciAhPT0gbnVsbCkge1xuICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgICBvYnNlcnZlciA9IG51bGw7XG4gICAgd3JhcHBlck5vZGUucmVtb3ZlKCk7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIGxhc3ROb2Rlcykge1xuICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICB9XG4gICAgbGFzdE5vZGVzID0gW107XG4gIH1cbiAgZnVuY3Rpb24gcmVzdGFydCgpIHtcbiAgICBjb25zdCBjdXJyZW50Um9vdERPTU5vZGUgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcbiAgICBpZiAoY3VycmVudFJvb3RET01Ob2RlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gc3RvcCgpO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50UGFyZW50RE9NTm9kZSA9IGN1cnJlbnRSb290RE9NTm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIGlmICghKGN1cnJlbnRQYXJlbnRET01Ob2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gc3RvcCgpO1xuICAgIH1cbiAgICBzdG9wKCk7XG4gICAgcm9vdERPTU5vZGUgPSBjdXJyZW50Um9vdERPTU5vZGU7XG4gICAgcGFyZW50RE9NTm9kZSA9IGN1cnJlbnRQYXJlbnRET01Ob2RlO1xuICAgIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zID0+IHtcbiAgICAgIGNvbnN0IG5leHRSb290RE9NTm9kZSA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuICAgICAgY29uc3QgbmV4dFBhcmVudERPTU5vZGUgPSBuZXh0Um9vdERPTU5vZGUgJiYgbmV4dFJvb3RET01Ob2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgICBpZiAobmV4dFJvb3RET01Ob2RlICE9PSByb290RE9NTm9kZSB8fCBuZXh0UGFyZW50RE9NTm9kZSAhPT0gcGFyZW50RE9NTm9kZSkge1xuICAgICAgICByZXR1cm4gcmVzdGFydCgpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgaWYgKCF3cmFwcGVyTm9kZS5jb250YWlucyhtdXRhdGlvbi50YXJnZXQpKSB7XG4gICAgICAgICAgLy8gVE9ETyB0aHJvdHRsZVxuICAgICAgICAgIHJldHVybiBwb3NpdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShjdXJyZW50UGFyZW50RE9NTm9kZSwgbXV0YXRpb25PYnNlcnZlckNvbmZpZyk7XG4gICAgcG9zaXRpb24oKTtcbiAgfVxuICBjb25zdCByZW1vdmVSb290TGlzdGVuZXIgPSBlZGl0b3IucmVnaXN0ZXJSb290TGlzdGVuZXIocmVzdGFydCk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgcmVtb3ZlUm9vdExpc3RlbmVyKCk7XG4gICAgc3RvcCgpO1xuICB9O1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIG1hcmtTZWxlY3Rpb24oZWRpdG9yLCBvblJlcG9zaXRpb24pIHtcbiAgbGV0IHByZXZpb3VzQW5jaG9yTm9kZSA9IG51bGw7XG4gIGxldCBwcmV2aW91c0FuY2hvck9mZnNldCA9IG51bGw7XG4gIGxldCBwcmV2aW91c0ZvY3VzTm9kZSA9IG51bGw7XG4gIGxldCBwcmV2aW91c0ZvY3VzT2Zmc2V0ID0gbnVsbDtcbiAgbGV0IHJlbW92ZVJhbmdlTGlzdGVuZXIgPSAoKSA9PiB7fTtcbiAgZnVuY3Rpb24gY29tcHV0ZShlZGl0b3JTdGF0ZSkge1xuICAgIGVkaXRvclN0YXRlLnJlYWQoKCkgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgcHJldmlvdXNBbmNob3JOb2RlID0gbnVsbDtcbiAgICAgICAgcHJldmlvdXNBbmNob3JPZmZzZXQgPSBudWxsO1xuICAgICAgICBwcmV2aW91c0ZvY3VzTm9kZSA9IG51bGw7XG4gICAgICAgIHByZXZpb3VzRm9jdXNPZmZzZXQgPSBudWxsO1xuICAgICAgICByZW1vdmVSYW5nZUxpc3RlbmVyKCk7XG4gICAgICAgIHJlbW92ZVJhbmdlTGlzdGVuZXIgPSAoKSA9PiB7fTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBhbmNob3IsXG4gICAgICAgIGZvY3VzXG4gICAgICB9ID0gc2VsZWN0aW9uO1xuICAgICAgY29uc3QgY3VycmVudEFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgY29uc3QgY3VycmVudEFuY2hvck5vZGVLZXkgPSBjdXJyZW50QW5jaG9yTm9kZS5nZXRLZXkoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRBbmNob3JPZmZzZXQgPSBhbmNob3Iub2Zmc2V0O1xuICAgICAgY29uc3QgY3VycmVudEZvY3VzTm9kZSA9IGZvY3VzLmdldE5vZGUoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRGb2N1c05vZGVLZXkgPSBjdXJyZW50Rm9jdXNOb2RlLmdldEtleSgpO1xuICAgICAgY29uc3QgY3VycmVudEZvY3VzT2Zmc2V0ID0gZm9jdXMub2Zmc2V0O1xuICAgICAgY29uc3QgY3VycmVudEFuY2hvck5vZGVET00gPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGN1cnJlbnRBbmNob3JOb2RlS2V5KTtcbiAgICAgIGNvbnN0IGN1cnJlbnRGb2N1c05vZGVET00gPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGN1cnJlbnRGb2N1c05vZGVLZXkpO1xuICAgICAgY29uc3QgZGlmZmVyZW50QW5jaG9yRE9NID0gcHJldmlvdXNBbmNob3JOb2RlID09PSBudWxsIHx8IGN1cnJlbnRBbmNob3JOb2RlRE9NID09PSBudWxsIHx8IGN1cnJlbnRBbmNob3JPZmZzZXQgIT09IHByZXZpb3VzQW5jaG9yT2Zmc2V0IHx8IGN1cnJlbnRBbmNob3JOb2RlS2V5ICE9PSBwcmV2aW91c0FuY2hvck5vZGUuZ2V0S2V5KCkgfHwgY3VycmVudEFuY2hvck5vZGUgIT09IHByZXZpb3VzQW5jaG9yTm9kZSAmJiAoIShwcmV2aW91c0FuY2hvck5vZGUgaW5zdGFuY2VvZiBUZXh0Tm9kZSkgfHwgY3VycmVudEFuY2hvck5vZGUudXBkYXRlRE9NKHByZXZpb3VzQW5jaG9yTm9kZSwgY3VycmVudEFuY2hvck5vZGVET00sIGVkaXRvci5fY29uZmlnKSk7XG4gICAgICBjb25zdCBkaWZmZXJlbnRGb2N1c0RPTSA9IHByZXZpb3VzRm9jdXNOb2RlID09PSBudWxsIHx8IGN1cnJlbnRGb2N1c05vZGVET00gPT09IG51bGwgfHwgY3VycmVudEZvY3VzT2Zmc2V0ICE9PSBwcmV2aW91c0ZvY3VzT2Zmc2V0IHx8IGN1cnJlbnRGb2N1c05vZGVLZXkgIT09IHByZXZpb3VzRm9jdXNOb2RlLmdldEtleSgpIHx8IGN1cnJlbnRGb2N1c05vZGUgIT09IHByZXZpb3VzRm9jdXNOb2RlICYmICghKHByZXZpb3VzRm9jdXNOb2RlIGluc3RhbmNlb2YgVGV4dE5vZGUpIHx8IGN1cnJlbnRGb2N1c05vZGUudXBkYXRlRE9NKHByZXZpb3VzRm9jdXNOb2RlLCBjdXJyZW50Rm9jdXNOb2RlRE9NLCBlZGl0b3IuX2NvbmZpZykpO1xuICAgICAgaWYgKGRpZmZlcmVudEFuY2hvckRPTSB8fCBkaWZmZXJlbnRGb2N1c0RPTSkge1xuICAgICAgICBjb25zdCBhbmNob3JIVE1MRWxlbWVudCA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoYW5jaG9yLmdldE5vZGUoKS5nZXRLZXkoKSk7XG4gICAgICAgIGNvbnN0IGZvY3VzSFRNTEVsZW1lbnQgPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGZvY3VzLmdldE5vZGUoKS5nZXRLZXkoKSk7XG4gICAgICAgIC8vIFRPRE8gaGFuZGxlIHNlbGVjdGlvbiBiZXlvbmQgdGhlIGNvbW1vbiBUZXh0Tm9kZVxuICAgICAgICBpZiAoYW5jaG9ySFRNTEVsZW1lbnQgIT09IG51bGwgJiYgZm9jdXNIVE1MRWxlbWVudCAhPT0gbnVsbCAmJiBhbmNob3JIVE1MRWxlbWVudC50YWdOYW1lID09PSAnU1BBTicgJiYgZm9jdXNIVE1MRWxlbWVudC50YWdOYW1lID09PSAnU1BBTicpIHtcbiAgICAgICAgICBjb25zdCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgbGV0IGZpcnN0SFRNTEVsZW1lbnQ7XG4gICAgICAgICAgbGV0IGZpcnN0T2Zmc2V0O1xuICAgICAgICAgIGxldCBsYXN0SFRNTEVsZW1lbnQ7XG4gICAgICAgICAgbGV0IGxhc3RPZmZzZXQ7XG4gICAgICAgICAgaWYgKGZvY3VzLmlzQmVmb3JlKGFuY2hvcikpIHtcbiAgICAgICAgICAgIGZpcnN0SFRNTEVsZW1lbnQgPSBmb2N1c0hUTUxFbGVtZW50O1xuICAgICAgICAgICAgZmlyc3RPZmZzZXQgPSBmb2N1cy5vZmZzZXQ7XG4gICAgICAgICAgICBsYXN0SFRNTEVsZW1lbnQgPSBhbmNob3JIVE1MRWxlbWVudDtcbiAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBhbmNob3Iub2Zmc2V0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaXJzdEhUTUxFbGVtZW50ID0gYW5jaG9ySFRNTEVsZW1lbnQ7XG4gICAgICAgICAgICBmaXJzdE9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gICAgICAgICAgICBsYXN0SFRNTEVsZW1lbnQgPSBmb2N1c0hUTUxFbGVtZW50O1xuICAgICAgICAgICAgbGFzdE9mZnNldCA9IGZvY3VzLm9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZmlyc3RUZXh0Tm9kZSA9IGZpcnN0SFRNTEVsZW1lbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgICBpZiAoIShmaXJzdFRleHROb2RlICE9PSBudWxsKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIHRleHQgbm9kZSB0byBiZSBmaXJzdCBjaGlsZCBvZiBzcGFuYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGxhc3RUZXh0Tm9kZSA9IGxhc3RIVE1MRWxlbWVudC5maXJzdENoaWxkO1xuICAgICAgICAgIGlmICghKGxhc3RUZXh0Tm9kZSAhPT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCB0ZXh0IG5vZGUgdG8gYmUgZmlyc3QgY2hpbGQgb2Ygc3BhbmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByYW5nZS5zZXRTdGFydChmaXJzdFRleHROb2RlLCBmaXJzdE9mZnNldCk7XG4gICAgICAgICAgcmFuZ2Uuc2V0RW5kKGxhc3RUZXh0Tm9kZSwgbGFzdE9mZnNldCk7XG4gICAgICAgICAgcmVtb3ZlUmFuZ2VMaXN0ZW5lcigpO1xuICAgICAgICAgIHJlbW92ZVJhbmdlTGlzdGVuZXIgPSBwb3NpdGlvbk5vZGVPblJhbmdlKGVkaXRvciwgcmFuZ2UsIGRvbU5vZGVzID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZG9tTm9kZSBvZiBkb21Ob2Rlcykge1xuICAgICAgICAgICAgICBjb25zdCBkb21Ob2RlU3R5bGUgPSBkb21Ob2RlLnN0eWxlO1xuICAgICAgICAgICAgICBpZiAoZG9tTm9kZVN0eWxlLmJhY2tncm91bmQgIT09ICdIaWdobGlnaHQnKSB7XG4gICAgICAgICAgICAgICAgZG9tTm9kZVN0eWxlLmJhY2tncm91bmQgPSAnSGlnaGxpZ2h0JztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZG9tTm9kZVN0eWxlLmNvbG9yICE9PSAnSGlnaGxpZ2h0VGV4dCcpIHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlU3R5bGUuY29sb3IgPSAnSGlnaGxpZ2h0VGV4dCc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGRvbU5vZGVTdHlsZS56SW5kZXggIT09ICctMScpIHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlU3R5bGUuekluZGV4ID0gJy0xJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZG9tTm9kZVN0eWxlLnBvaW50ZXJFdmVudHMgIT09ICdub25lJykge1xuICAgICAgICAgICAgICAgIGRvbU5vZGVTdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkb21Ob2RlU3R5bGUubWFyZ2luVG9wICE9PSBweCgtMS41KSkge1xuICAgICAgICAgICAgICAgIGRvbU5vZGVTdHlsZS5tYXJnaW5Ub3AgPSBweCgtMS41KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZG9tTm9kZVN0eWxlLnBhZGRpbmdUb3AgIT09IHB4KDQpKSB7XG4gICAgICAgICAgICAgICAgZG9tTm9kZVN0eWxlLnBhZGRpbmdUb3AgPSBweCg0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZG9tTm9kZVN0eWxlLnBhZGRpbmdCb3R0b20gIT09IHB4KDApKSB7XG4gICAgICAgICAgICAgICAgZG9tTm9kZVN0eWxlLnBhZGRpbmdCb3R0b20gPSBweCgwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uUmVwb3NpdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIG9uUmVwb3NpdGlvbihkb21Ob2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHByZXZpb3VzQW5jaG9yTm9kZSA9IGN1cnJlbnRBbmNob3JOb2RlO1xuICAgICAgcHJldmlvdXNBbmNob3JPZmZzZXQgPSBjdXJyZW50QW5jaG9yT2Zmc2V0O1xuICAgICAgcHJldmlvdXNGb2N1c05vZGUgPSBjdXJyZW50Rm9jdXNOb2RlO1xuICAgICAgcHJldmlvdXNGb2N1c09mZnNldCA9IGN1cnJlbnRGb2N1c09mZnNldDtcbiAgICB9KTtcbiAgfVxuICBjb21wdXRlKGVkaXRvci5nZXRFZGl0b3JTdGF0ZSgpKTtcbiAgcmV0dXJuIG1lcmdlUmVnaXN0ZXIoZWRpdG9yLnJlZ2lzdGVyVXBkYXRlTGlzdGVuZXIoKHtcbiAgICBlZGl0b3JTdGF0ZVxuICB9KSA9PiBjb21wdXRlKGVkaXRvclN0YXRlKSksIHJlbW92ZVJhbmdlTGlzdGVuZXIsICgpID0+IHtcbiAgICByZW1vdmVSYW5nZUxpc3RlbmVyKCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8vIEhvdGZpeCB0byBleHBvcnQgdGhlc2Ugd2l0aCBpbmxpbmVkIHR5cGVzICM1OTE4XG5jb25zdCBDQU5fVVNFX0JFRk9SRV9JTlBVVCA9IENBTl9VU0VfQkVGT1JFX0lOUFVUJDE7XG5jb25zdCBDQU5fVVNFX0RPTSA9IENBTl9VU0VfRE9NJDE7XG5jb25zdCBJU19BTkRST0lEID0gSVNfQU5EUk9JRCQxO1xuY29uc3QgSVNfQU5EUk9JRF9DSFJPTUUgPSBJU19BTkRST0lEX0NIUk9NRSQxO1xuY29uc3QgSVNfQVBQTEUgPSBJU19BUFBMRSQxO1xuY29uc3QgSVNfQVBQTEVfV0VCS0lUID0gSVNfQVBQTEVfV0VCS0lUJDE7XG5jb25zdCBJU19DSFJPTUUgPSBJU19DSFJPTUUkMTtcbmNvbnN0IElTX0ZJUkVGT1ggPSBJU19GSVJFRk9YJDE7XG5jb25zdCBJU19JT1MgPSBJU19JT1MkMTtcbmNvbnN0IElTX1NBRkFSSSA9IElTX1NBRkFSSSQxO1xuXG4vKipcbiAqIFRha2VzIGFuIEhUTUwgZWxlbWVudCBhbmQgYWRkcyB0aGUgY2xhc3NOYW1lcyBwYXNzZWQgd2l0aGluIGFuIGFycmF5LFxuICogaWdub3JpbmcgYW55IG5vbi1zdHJpbmcgdHlwZXMuIEEgc3BhY2UgY2FuIGJlIHVzZWQgdG8gYWRkIG11bHRpcGxlIGNsYXNzZXNcbiAqIGVnLiBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIFsnZWxlbWVudC1pbm5lciBhY3RpdmUnLCB0cnVlLCBudWxsXSlcbiAqIHdpbGwgYWRkIGJvdGggJ2VsZW1lbnQtaW5uZXInIGFuZCAnYWN0aXZlJyBhcyBjbGFzc2VzIHRvIHRoYXQgZWxlbWVudC5cbiAqIEBwYXJhbSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgaW4gd2hpY2ggdGhlIGNsYXNzZXMgYXJlIGFkZGVkXG4gKiBAcGFyYW0gY2xhc3NOYW1lcyAtIEFuIGFycmF5IGRlZmluaW5nIHRoZSBjbGFzcyBuYW1lcyB0byBhZGQgdG8gdGhlIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChlbGVtZW50LCAuLi5jbGFzc05hbWVzKSB7XG4gIGNvbnN0IGNsYXNzZXNUb0FkZCA9IG5vcm1hbGl6ZUNsYXNzTmFtZXMoLi4uY2xhc3NOYW1lcyk7XG4gIGlmIChjbGFzc2VzVG9BZGQubGVuZ3RoID4gMCkge1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCguLi5jbGFzc2VzVG9BZGQpO1xuICB9XG59XG5cbi8qKlxuICogVGFrZXMgYW4gSFRNTCBlbGVtZW50IGFuZCByZW1vdmVzIHRoZSBjbGFzc05hbWVzIHBhc3NlZCB3aXRoaW4gYW4gYXJyYXksXG4gKiBpZ25vcmluZyBhbnkgbm9uLXN0cmluZyB0eXBlcy4gQSBzcGFjZSBjYW4gYmUgdXNlZCB0byByZW1vdmUgbXVsdGlwbGUgY2xhc3Nlc1xuICogZWcuIHJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudChlbGVtZW50LCBbJ2FjdGl2ZSBzbWFsbCcsIHRydWUsIG51bGxdKVxuICogd2lsbCByZW1vdmUgYm90aCB0aGUgJ2FjdGl2ZScgYW5kICdzbWFsbCcgY2xhc3NlcyBmcm9tIHRoYXQgZWxlbWVudC5cbiAqIEBwYXJhbSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgaW4gd2hpY2ggdGhlIGNsYXNzZXMgYXJlIHJlbW92ZWRcbiAqIEBwYXJhbSBjbGFzc05hbWVzIC0gQW4gYXJyYXkgZGVmaW5pbmcgdGhlIGNsYXNzIG5hbWVzIHRvIHJlbW92ZSBmcm9tIHRoZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudChlbGVtZW50LCAuLi5jbGFzc05hbWVzKSB7XG4gIGNvbnN0IGNsYXNzZXNUb1JlbW92ZSA9IG5vcm1hbGl6ZUNsYXNzTmFtZXMoLi4uY2xhc3NOYW1lcyk7XG4gIGlmIChjbGFzc2VzVG9SZW1vdmUubGVuZ3RoID4gMCkge1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSguLi5jbGFzc2VzVG9SZW1vdmUpO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBmaWxlIHR5cGUgbWF0Y2hlcyB0aGUgdHlwZXMgcGFzc2VkIHdpdGhpbiB0aGUgYWNjZXB0YWJsZU1pbWVUeXBlcyBhcnJheSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogVGhlIHR5cGVzIHBhc3NlZCBtdXN0IGJlIHN0cmluZ3MgYW5kIGFyZSBDQVNFLVNFTlNJVElWRS5cbiAqIGVnLiBpZiBmaWxlIGlzIG9mIHR5cGUgJ3RleHQnIGFuZCBhY2NlcHRhYmxlTWltZVR5cGVzID0gWydURVhUJywgJ0lNQUdFJ10gdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGZhbHNlLlxuICogQHBhcmFtIGZpbGUgLSBUaGUgZmlsZSB5b3Ugd2FudCB0byB0eXBlIGNoZWNrLlxuICogQHBhcmFtIGFjY2VwdGFibGVNaW1lVHlwZXMgLSBBbiBhcnJheSBvZiBzdHJpbmdzIG9mIHR5cGVzIHdoaWNoIHRoZSBmaWxlIGlzIGNoZWNrZWQgYWdhaW5zdC5cbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGZpbGUgaXMgYW4gYWNjZXB0YWJsZSBtaW1lIHR5cGUsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNNaW1lVHlwZShmaWxlLCBhY2NlcHRhYmxlTWltZVR5cGVzKSB7XG4gIGZvciAoY29uc3QgYWNjZXB0YWJsZVR5cGUgb2YgYWNjZXB0YWJsZU1pbWVUeXBlcykge1xuICAgIGlmIChmaWxlLnR5cGUuc3RhcnRzV2l0aChhY2NlcHRhYmxlVHlwZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogTGV4aWNhbCBGaWxlIFJlYWRlciB3aXRoOlxuICogIDEuIE1JTUUgdHlwZSBzdXBwb3J0XG4gKiAgMi4gYmF0Y2hlZCByZXN1bHRzIChIaXN0b3J5UGx1Z2luIGNvbXBhdGliaWxpdHkpXG4gKiAgMy4gT3JkZXIgYXdhcmUgKHJlc3BlY3RzIHRoZSBvcmRlciB3aGVuIG11bHRpcGxlIEZpbGVzIGFyZSBwYXNzZWQpXG4gKlxuICogY29uc3QgZmlsZXNSZXN1bHQgPSBhd2FpdCBtZWRpYUZpbGVSZWFkZXIoZmlsZXMsIFsnaW1hZ2UvJ10pO1xuICogZmlsZXNSZXN1bHQuZm9yRWFjaChmaWxlID0+IGVkaXRvci5kaXNwYXRjaENvbW1hbmQoJ0lOU0VSVF9JTUFHRScsIFxcXFx7XG4gKiAgIHNyYzogZmlsZS5yZXN1bHQsXG4gKiBcXFxcfSkpO1xuICovXG5mdW5jdGlvbiBtZWRpYUZpbGVSZWFkZXIoZmlsZXMsIGFjY2VwdGFibGVNaW1lVHlwZXMpIHtcbiAgY29uc3QgZmlsZXNJdGVyYXRvciA9IGZpbGVzW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBwcm9jZXNzZWQgPSBbXTtcbiAgICBjb25zdCBoYW5kbGVOZXh0RmlsZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZG9uZSxcbiAgICAgICAgdmFsdWU6IGZpbGVcbiAgICAgIH0gPSBmaWxlc0l0ZXJhdG9yLm5leHQoKTtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKHByb2Nlc3NlZCk7XG4gICAgICB9XG4gICAgICBjb25zdCBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIGZpbGVSZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCByZWplY3QpO1xuICAgICAgZmlsZVJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBmaWxlUmVhZGVyLnJlc3VsdDtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcHJvY2Vzc2VkLnB1c2goe1xuICAgICAgICAgICAgZmlsZSxcbiAgICAgICAgICAgIHJlc3VsdFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZU5leHRGaWxlKCk7XG4gICAgICB9KTtcbiAgICAgIGlmIChpc01pbWVUeXBlKGZpbGUsIGFjY2VwdGFibGVNaW1lVHlwZXMpKSB7XG4gICAgICAgIGZpbGVSZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZU5leHRGaWxlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBoYW5kbGVOZXh0RmlsZSgpO1xuICB9KTtcbn1cbi8qKlxuICogXCJEZXB0aC1GaXJzdCBTZWFyY2hcIiBzdGFydHMgYXQgdGhlIHJvb3QvdG9wIG5vZGUgb2YgYSB0cmVlIGFuZCBnb2VzIGFzIGZhciBhcyBpdCBjYW4gZG93biBhIGJyYW5jaCBlbmRcbiAqIGJlZm9yZSBiYWNrdHJhY2tpbmcgYW5kIGZpbmRpbmcgYSBuZXcgcGF0aC4gQ29uc2lkZXIgc29sdmluZyBhIG1hemUgYnkgaHVnZ2luZyBlaXRoZXIgd2FsbCwgbW92aW5nIGRvd24gYVxuICogYnJhbmNoIHVudGlsIHlvdSBoaXQgYSBkZWFkLWVuZCAobGVhZikgYW5kIGJhY2t0cmFja2luZyB0byBmaW5kIHRoZSBuZWFyZXN0IGJyYW5jaGluZyBwYXRoIGFuZCByZXBlYXQuXG4gKiBJdCB3aWxsIHRoZW4gcmV0dXJuIGFsbCB0aGUgbm9kZXMgZm91bmQgaW4gdGhlIHNlYXJjaCBpbiBhbiBhcnJheSBvZiBvYmplY3RzLlxuICogQHBhcmFtIHN0YXJ0Tm9kZSAtIFRoZSBub2RlIHRvIHN0YXJ0IHRoZSBzZWFyY2gsIGlmIG9taXR0ZWQsIGl0IHdpbGwgc3RhcnQgYXQgdGhlIHJvb3Qgbm9kZS5cbiAqIEBwYXJhbSBlbmROb2RlIC0gVGhlIG5vZGUgdG8gZW5kIHRoZSBzZWFyY2gsIGlmIG9taXR0ZWQsIGl0IHdpbGwgZmluZCBhbGwgZGVzY2VuZGFudHMgb2YgdGhlIHN0YXJ0aW5nTm9kZS5cbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIG9iamVjdHMgb2YgYWxsIHRoZSBub2RlcyBmb3VuZCBieSB0aGUgc2VhcmNoLCBpbmNsdWRpbmcgdGhlaXIgZGVwdGggaW50byB0aGUgdHJlZS5cbiAqIFxcXFx7ZGVwdGg6IG51bWJlciwgbm9kZTogTGV4aWNhbE5vZGVcXFxcfSBJdCB3aWxsIGFsd2F5cyByZXR1cm4gYXQgbGVhc3QgMSBub2RlICh0aGUgc3RhcnQgbm9kZSkuXG4gKi9cbmZ1bmN0aW9uICRkZnMoc3RhcnROb2RlLCBlbmROb2RlKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKCRkZnNJdGVyYXRvcihzdGFydE5vZGUsIGVuZE5vZGUpKTtcbn1cbmNvbnN0IGl0ZXJhdG9yRG9uZSA9IHtcbiAgZG9uZTogdHJ1ZSxcbiAgdmFsdWU6IHVuZGVmaW5lZFxufTtcbmNvbnN0IGl0ZXJhdG9yTm90RG9uZSA9IHZhbHVlID0+ICh7XG4gIGRvbmU6IGZhbHNlLFxuICB2YWx1ZVxufSk7XG5cbi8qKlxuICogJGRmcyBpdGVyYXRvci4gVHJlZSB0cmF2ZXJzYWwgaXMgZG9uZSBvbiB0aGUgZmx5IGFzIG5ldyB2YWx1ZXMgYXJlIHJlcXVlc3RlZCB3aXRoIE8oMSkgbWVtb3J5LlxuICogQHBhcmFtIHN0YXJ0Tm9kZSAtIFRoZSBub2RlIHRvIHN0YXJ0IHRoZSBzZWFyY2gsIGlmIG9taXR0ZWQsIGl0IHdpbGwgc3RhcnQgYXQgdGhlIHJvb3Qgbm9kZS5cbiAqIEBwYXJhbSBlbmROb2RlIC0gVGhlIG5vZGUgdG8gZW5kIHRoZSBzZWFyY2gsIGlmIG9taXR0ZWQsIGl0IHdpbGwgZmluZCBhbGwgZGVzY2VuZGFudHMgb2YgdGhlIHN0YXJ0aW5nTm9kZS5cbiAqIEByZXR1cm5zIEFuIGl0ZXJhdG9yLCBlYWNoIHlpZWxkZWQgdmFsdWUgaXMgYSBERlNOb2RlLiBJdCB3aWxsIGFsd2F5cyByZXR1cm4gYXQgbGVhc3QgMSBub2RlICh0aGUgc3RhcnQgbm9kZSkuXG4gKi9cbmZ1bmN0aW9uICRkZnNJdGVyYXRvcihzdGFydE5vZGUsIGVuZE5vZGUpIHtcbiAgY29uc3Qgc3RhcnQgPSAoc3RhcnROb2RlIHx8ICRnZXRSb290KCkpLmdldExhdGVzdCgpO1xuICBjb25zdCBzdGFydERlcHRoID0gJGdldERlcHRoKHN0YXJ0KTtcbiAgY29uc3QgZW5kID0gZW5kTm9kZTtcbiAgbGV0IG5vZGUgPSBzdGFydDtcbiAgbGV0IGRlcHRoID0gc3RhcnREZXB0aDtcbiAgbGV0IGlzRmlyc3ROZXh0ID0gdHJ1ZTtcbiAgY29uc3QgaXRlcmF0b3IgPSB7XG4gICAgbmV4dCgpIHtcbiAgICAgIGlmIChub2RlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvckRvbmU7XG4gICAgICB9XG4gICAgICBpZiAoaXNGaXJzdE5leHQpIHtcbiAgICAgICAgaXNGaXJzdE5leHQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTm90RG9uZSh7XG4gICAgICAgICAgZGVwdGgsXG4gICAgICAgICAgbm9kZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSBlbmQpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZTtcbiAgICAgIH1cbiAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShub2RlKSAmJiBub2RlLmdldENoaWxkcmVuU2l6ZSgpID4gMCkge1xuICAgICAgICBub2RlID0gbm9kZS5nZXRGaXJzdENoaWxkKCk7XG4gICAgICAgIGRlcHRoKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgZGVwdGhEaWZmO1xuICAgICAgICBbbm9kZSwgZGVwdGhEaWZmXSA9ICRnZXROZXh0U2libGluZ09yUGFyZW50U2libGluZyhub2RlKSB8fCBbbnVsbCwgMF07XG4gICAgICAgIGRlcHRoICs9IGRlcHRoRGlmZjtcbiAgICAgICAgaWYgKGVuZCA9PSBudWxsICYmIGRlcHRoIDw9IHN0YXJ0RGVwdGgpIHtcbiAgICAgICAgICBub2RlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVyYXRvck5vdERvbmUoe1xuICAgICAgICBkZXB0aCxcbiAgICAgICAgbm9kZVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICB9XG4gIH07XG4gIHJldHVybiBpdGVyYXRvcjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBOb2RlIHNpYmxpbmcgd2hlbiB0aGlzIGV4aXN0cywgb3RoZXJ3aXNlIHRoZSBjbG9zZXN0IHBhcmVudCBzaWJsaW5nLiBGb3IgZXhhbXBsZVxuICogUiAtPiBQIC0+IFQxLCBUMlxuICogICAtPiBQMlxuICogcmV0dXJucyBUMiBmb3Igbm9kZSBUMSwgUDIgZm9yIG5vZGUgVDIsIGFuZCBudWxsIGZvciBub2RlIFAyLlxuICogQHBhcmFtIG5vZGUgTGV4aWNhbE5vZGUuXG4gKiBAcmV0dXJucyBBbiBhcnJheSAodHVwbGUpIGNvbnRhaW5pbmcgdGhlIGZvdW5kIExleGljYWwgbm9kZSBhbmQgdGhlIGRlcHRoIGRpZmZlcmVuY2UsIG9yIG51bGwsIGlmIHRoaXMgbm9kZSBkb2Vzbid0IGV4aXN0LlxuICovXG5mdW5jdGlvbiAkZ2V0TmV4dFNpYmxpbmdPclBhcmVudFNpYmxpbmcobm9kZSkge1xuICBsZXQgbm9kZV8gPSBub2RlO1xuICAvLyBGaW5kIGltbWVkaWF0ZSBzaWJsaW5nIG9yIG5lYXJlc3QgcGFyZW50IHNpYmxpbmdcbiAgbGV0IHNpYmxpbmcgPSBudWxsO1xuICBsZXQgZGVwdGhEaWZmID0gMDtcbiAgd2hpbGUgKHNpYmxpbmcgPT09IG51bGwgJiYgbm9kZV8gIT09IG51bGwpIHtcbiAgICBzaWJsaW5nID0gbm9kZV8uZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICBpZiAoc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgbm9kZV8gPSBub2RlXy5nZXRQYXJlbnQoKTtcbiAgICAgIGRlcHRoRGlmZi0tO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlXyA9IHNpYmxpbmc7XG4gICAgfVxuICB9XG4gIGlmIChub2RlXyA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBbbm9kZV8sIGRlcHRoRGlmZl07XG59XG5mdW5jdGlvbiAkZ2V0RGVwdGgobm9kZSkge1xuICBsZXQgaW5uZXJOb2RlID0gbm9kZTtcbiAgbGV0IGRlcHRoID0gMDtcbiAgd2hpbGUgKChpbm5lck5vZGUgPSBpbm5lck5vZGUuZ2V0UGFyZW50KCkpICE9PSBudWxsKSB7XG4gICAgZGVwdGgrKztcbiAgfVxuICByZXR1cm4gZGVwdGg7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYSByaWdodC10by1sZWZ0IHByZW9yZGVyIHRyZWUgdHJhdmVyc2FsLlxuICogRnJvbSB0aGUgc3RhcnRpbmcgbm9kZSBpdCBnb2VzIHRvIHRoZSByaWdodG1vc3QgY2hpbGQsIHRoYW4gYmFja3RyYWNrcyB0byBwYXJldCBhbmQgZmluZHMgbmV3IHJpZ2h0bW9zdCBwYXRoLlxuICogSXQgd2lsbCByZXR1cm4gdGhlIG5leHQgbm9kZSBpbiB0cmF2ZXJzYWwgc2VxdWVuY2UgYWZ0ZXIgdGhlIHN0YXJ0aW5nTm9kZS5cbiAqIFRoZSB0cmF2ZXJzYWwgaXMgc2ltaWxhciB0byAkZGZzIGZ1bmN0aW9ucyBhYm92ZSwgYnV0IHRoZSBub2RlcyBhcmUgdmlzaXRlZCByaWdodC10by1sZWZ0LCBub3QgbGVmdC10by1yaWdodC5cbiAqIEBwYXJhbSBzdGFydGluZ05vZGUgLSBUaGUgbm9kZSB0byBzdGFydCB0aGUgc2VhcmNoLlxuICogQHJldHVybnMgVGhlIG5leHQgbm9kZSBpbiBwcmUtb3JkZXIgcmlnaHQgdG8gbGVmdCB0cmF2ZXJzYWwgc2VxdWVuY2Ugb3IgYG51bGxgLCBpZiB0aGUgbm9kZSBkb2VzIG5vdCBleGlzdFxuICovXG5mdW5jdGlvbiAkZ2V0TmV4dFJpZ2h0UHJlb3JkZXJOb2RlKHN0YXJ0aW5nTm9kZSkge1xuICBsZXQgbm9kZSA9IHN0YXJ0aW5nTm9kZTtcbiAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpICYmIG5vZGUuZ2V0Q2hpbGRyZW5TaXplKCkgPiAwKSB7XG4gICAgbm9kZSA9IG5vZGUuZ2V0TGFzdENoaWxkKCk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHNpYmxpbmcgPSBudWxsO1xuICAgIHdoaWxlIChzaWJsaW5nID09PSBudWxsICYmIG5vZGUgIT09IG51bGwpIHtcbiAgICAgIHNpYmxpbmcgPSBub2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgaWYgKHNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gc2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogVGFrZXMgYSBub2RlIGFuZCB0cmF2ZXJzZXMgdXAgaXRzIGFuY2VzdG9ycyAodG93YXJkIHRoZSByb290IG5vZGUpXG4gKiBpbiBvcmRlciB0byBmaW5kIGEgc3BlY2lmaWMgdHlwZSBvZiBub2RlLlxuICogQHBhcmFtIG5vZGUgLSB0aGUgbm9kZSB0byBiZWdpbiBzZWFyY2hpbmcuXG4gKiBAcGFyYW0ga2xhc3MgLSBhbiBpbnN0YW5jZSBvZiB0aGUgdHlwZSBvZiBub2RlIHRvIGxvb2sgZm9yLlxuICogQHJldHVybnMgdGhlIG5vZGUgb2YgdHlwZSBrbGFzcyB0aGF0IHdhcyBwYXNzZWQsIG9yIG51bGwgaWYgbm9uZSBleGlzdC5cbiAqL1xuZnVuY3Rpb24gJGdldE5lYXJlc3ROb2RlT2ZUeXBlKG5vZGUsIGtsYXNzKSB7XG4gIGxldCBwYXJlbnQgPSBub2RlO1xuICB3aGlsZSAocGFyZW50ICE9IG51bGwpIHtcbiAgICBpZiAocGFyZW50IGluc3RhbmNlb2Yga2xhc3MpIHtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlbGVtZW50IG5vZGUgb2YgdGhlIG5lYXJlc3QgYW5jZXN0b3IsIG90aGVyd2lzZSB0aHJvd3MgYW4gZXJyb3IuXG4gKiBAcGFyYW0gc3RhcnROb2RlIC0gVGhlIHN0YXJ0aW5nIG5vZGUgb2YgdGhlIHNlYXJjaFxuICogQHJldHVybnMgVGhlIGFuY2VzdG9yIG5vZGUgZm91bmRcbiAqL1xuZnVuY3Rpb24gJGdldE5lYXJlc3RCbG9ja0VsZW1lbnRBbmNlc3Rvck9yVGhyb3coc3RhcnROb2RlKSB7XG4gIGNvbnN0IGJsb2NrTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc3RhcnROb2RlLCBub2RlID0+ICRpc0VsZW1lbnROb2RlKG5vZGUpICYmICFub2RlLmlzSW5saW5lKCkpO1xuICBpZiAoISRpc0VsZW1lbnROb2RlKGJsb2NrTm9kZSkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgbm9kZSAke3N0YXJ0Tm9kZS5fX2tleX0gdG8gaGF2ZSBjbG9zZXN0IGJsb2NrIGVsZW1lbnQgbm9kZS5gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJsb2NrTm9kZTtcbn1cbi8qKlxuICogU3RhcnRzIHdpdGggYSBub2RlIGFuZCBtb3ZlcyB1cCB0aGUgdHJlZSAodG93YXJkIHRoZSByb290IG5vZGUpIHRvIGZpbmQgYSBtYXRjaGluZyBub2RlIGJhc2VkIG9uXG4gKiB0aGUgc2VhcmNoIHBhcmFtZXRlcnMgb2YgdGhlIGZpbmRGbi4gKENvbnNpZGVyIEphdmFTY3JpcHRzJyAuZmluZCgpIGZ1bmN0aW9uIHdoZXJlIGEgdGVzdGluZyBmdW5jdGlvbiBtdXN0IGJlXG4gKiBwYXNzZWQgYXMgYW4gYXJndW1lbnQuIGVnLiBpZiggKG5vZGUpID0+IG5vZGUuX190eXBlID09PSAnZGl2JykgKSByZXR1cm4gdHJ1ZTsgb3RoZXJ3aXNlIHJldHVybiBmYWxzZVxuICogQHBhcmFtIHN0YXJ0aW5nTm9kZSAtIFRoZSBub2RlIHdoZXJlIHRoZSBzZWFyY2ggc3RhcnRzLlxuICogQHBhcmFtIGZpbmRGbiAtIEEgdGVzdGluZyBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBpZiB0aGUgY3VycmVudCBub2RlIHNhdGlzZmllcyB0aGUgdGVzdGluZyBwYXJhbWV0ZXJzLlxuICogQHJldHVybnMgQSBwYXJlbnQgbm9kZSB0aGF0IG1hdGNoZXMgdGhlIGZpbmRGbiBwYXJhbWV0ZXJzLCBvciBudWxsIGlmIG9uZSB3YXNuJ3QgZm91bmQuXG4gKi9cbmNvbnN0ICRmaW5kTWF0Y2hpbmdQYXJlbnQgPSAoc3RhcnRpbmdOb2RlLCBmaW5kRm4pID0+IHtcbiAgbGV0IGN1cnIgPSBzdGFydGluZ05vZGU7XG4gIHdoaWxlIChjdXJyICE9PSAkZ2V0Um9vdCgpICYmIGN1cnIgIT0gbnVsbCkge1xuICAgIGlmIChmaW5kRm4oY3VycikpIHtcbiAgICAgIHJldHVybiBjdXJyO1xuICAgIH1cbiAgICBjdXJyID0gY3Vyci5nZXRQYXJlbnQoKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gcmVzb2x2ZSBuZXN0ZWQgZWxlbWVudCBub2RlcyBvZiB0aGUgc2FtZSB0eXBlIGludG8gYSBzaW5nbGUgbm9kZSBvZiB0aGF0IHR5cGUuXG4gKiBJdCBpcyBnZW5lcmFsbHkgdXNlZCBmb3IgbWFya3MvY29tbWVudGluZ1xuICogQHBhcmFtIGVkaXRvciAtIFRoZSBsZXhpY2FsIGVkaXRvclxuICogQHBhcmFtIHRhcmdldE5vZGUgLSBUaGUgdGFyZ2V0IGZvciB0aGUgbmVzdGVkIGVsZW1lbnQgdG8gYmUgZXh0cmFjdGVkIGZyb20uXG4gKiBAcGFyYW0gY2xvbmVOb2RlIC0gU2VlIHtAbGluayAkY3JlYXRlTWFya05vZGV9XG4gKiBAcGFyYW0gaGFuZGxlT3ZlcmxhcCAtIEhhbmRsZXMgYW55IG92ZXJsYXAgYmV0d2VlbiB0aGUgbm9kZSB0byBleHRyYWN0IGFuZCB0aGUgdGFyZ2V0Tm9kZVxuICogQHJldHVybnMgVGhlIGxleGljYWwgZWRpdG9yXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyTmVzdGVkRWxlbWVudFJlc29sdmVyKGVkaXRvciwgdGFyZ2V0Tm9kZSwgY2xvbmVOb2RlLCBoYW5kbGVPdmVybGFwKSB7XG4gIGNvbnN0ICRpc1RhcmdldE5vZGUgPSBub2RlID0+IHtcbiAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIHRhcmdldE5vZGU7XG4gIH07XG4gIGNvbnN0ICRmaW5kTWF0Y2ggPSBub2RlID0+IHtcbiAgICAvLyBGaXJzdCB2YWxpZGF0ZSB3ZSBkb24ndCBoYXZlIGFueSBjaGlsZHJlbiB0aGF0IGFyZSBvZiB0aGUgdGFyZ2V0LFxuICAgIC8vIGFzIHdlIG5lZWQgdG8gaGFuZGxlIHRoZW0gZmlyc3QuXG4gICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmICgkaXNUYXJnZXROb2RlKGNoaWxkKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHBhcmVudE5vZGUgPSBub2RlO1xuICAgIGxldCBjaGlsZE5vZGUgPSBub2RlO1xuICAgIHdoaWxlIChwYXJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgICBjaGlsZE5vZGUgPSBwYXJlbnROb2RlO1xuICAgICAgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUuZ2V0UGFyZW50KCk7XG4gICAgICBpZiAoJGlzVGFyZ2V0Tm9kZShwYXJlbnROb2RlKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNoaWxkOiBjaGlsZE5vZGUsXG4gICAgICAgICAgcGFyZW50OiBwYXJlbnROb2RlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuICBjb25zdCAkZWxlbWVudE5vZGVUcmFuc2Zvcm0gPSBub2RlID0+IHtcbiAgICBjb25zdCBtYXRjaCA9ICRmaW5kTWF0Y2gobm9kZSk7XG4gICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNoaWxkLFxuICAgICAgICBwYXJlbnRcbiAgICAgIH0gPSBtYXRjaDtcblxuICAgICAgLy8gU2ltcGxlIHBhdGgsIHdlIGNhbiBtb3ZlIGNoaWxkIG91dCBhbmQgc2libGluZ3MgaW50byBhIG5ldyBwYXJlbnQuXG5cbiAgICAgIGlmIChjaGlsZC5pcyhub2RlKSkge1xuICAgICAgICBoYW5kbGVPdmVybGFwKHBhcmVudCwgbm9kZSk7XG4gICAgICAgIGNvbnN0IG5leHRTaWJsaW5ncyA9IGNoaWxkLmdldE5leHRTaWJsaW5ncygpO1xuICAgICAgICBjb25zdCBuZXh0U2libGluZ3NMZW5ndGggPSBuZXh0U2libGluZ3MubGVuZ3RoO1xuICAgICAgICBwYXJlbnQuaW5zZXJ0QWZ0ZXIoY2hpbGQpO1xuICAgICAgICBpZiAobmV4dFNpYmxpbmdzTGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgY29uc3QgbmV3UGFyZW50ID0gY2xvbmVOb2RlKHBhcmVudCk7XG4gICAgICAgICAgY2hpbGQuaW5zZXJ0QWZ0ZXIobmV3UGFyZW50KTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5leHRTaWJsaW5nc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBuZXdQYXJlbnQuYXBwZW5kKG5leHRTaWJsaW5nc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyZW50LmNhbkJlRW1wdHkoKSAmJiBwYXJlbnQuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDApIHtcbiAgICAgICAgICBwYXJlbnQucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBlZGl0b3IucmVnaXN0ZXJOb2RlVHJhbnNmb3JtKHRhcmdldE5vZGUsICRlbGVtZW50Tm9kZVRyYW5zZm9ybSk7XG59XG5cbi8qKlxuICogQ2xvbmVzIHRoZSBlZGl0b3IgYW5kIG1hcmtzIGl0IGFzIGRpcnR5IHRvIGJlIHJlY29uY2lsZWQuIElmIHRoZXJlIHdhcyBhIHNlbGVjdGlvbixcbiAqIGl0IHdvdWxkIGJlIHNldCBiYWNrIHRvIGl0cyBwcmV2aW91cyBzdGF0ZSwgb3IgbnVsbCBvdGhlcndpc2UuXG4gKiBAcGFyYW0gZWRpdG9yIC0gVGhlIGxleGljYWwgZWRpdG9yXG4gKiBAcGFyYW0gZWRpdG9yU3RhdGUgLSBUaGUgZWRpdG9yJ3Mgc3RhdGVcbiAqL1xuZnVuY3Rpb24gJHJlc3RvcmVFZGl0b3JTdGF0ZShlZGl0b3IsIGVkaXRvclN0YXRlKSB7XG4gIGNvbnN0IEZVTExfUkVDT05DSUxFID0gMjtcbiAgY29uc3Qgbm9kZU1hcCA9IG5ldyBNYXAoKTtcbiAgY29uc3QgYWN0aXZlRWRpdG9yU3RhdGUgPSBlZGl0b3IuX3BlbmRpbmdFZGl0b3JTdGF0ZTtcbiAgZm9yIChjb25zdCBba2V5LCBub2RlXSBvZiBlZGl0b3JTdGF0ZS5fbm9kZU1hcCkge1xuICAgIG5vZGVNYXAuc2V0KGtleSwgJGNsb25lV2l0aFByb3BlcnRpZXMobm9kZSkpO1xuICB9XG4gIGlmIChhY3RpdmVFZGl0b3JTdGF0ZSkge1xuICAgIGFjdGl2ZUVkaXRvclN0YXRlLl9ub2RlTWFwID0gbm9kZU1hcDtcbiAgfVxuICBlZGl0b3IuX2RpcnR5VHlwZSA9IEZVTExfUkVDT05DSUxFO1xuICBjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xuICAkc2V0U2VsZWN0aW9uKHNlbGVjdGlvbiA9PT0gbnVsbCA/IG51bGwgOiBzZWxlY3Rpb24uY2xvbmUoKSk7XG59XG5cbi8qKlxuICogSWYgdGhlIHNlbGVjdGVkIGluc2VydGlvbiBhcmVhIGlzIHRoZSByb290L3NoYWRvdyByb290IG5vZGUgKHNlZSB7QGxpbmsgbGV4aWNhbCEkaXNSb290T3JTaGFkb3dSb290fSksXG4gKiB0aGUgbm9kZSB3aWxsIGJlIGFwcGVuZGVkIHRoZXJlLCBvdGhlcndpc2UsIGl0IHdpbGwgYmUgaW5zZXJ0ZWQgYmVmb3JlIHRoZSBpbnNlcnRpb24gYXJlYS5cbiAqIElmIHRoZXJlIGlzIG5vIHNlbGVjdGlvbiB3aGVyZSB0aGUgbm9kZSBpcyB0byBiZSBpbnNlcnRlZCwgaXQgd2lsbCBiZSBhcHBlbmRlZCBhZnRlciBhbnkgY3VycmVudCBub2Rlc1xuICogd2l0aGluIHRoZSB0cmVlLCBhcyBhIGNoaWxkIG9mIHRoZSByb290IG5vZGUuIEEgcGFyYWdyYXBoIG5vZGUgd2lsbCB0aGVuIGJlIGFkZGVkIGFmdGVyIHRoZSBpbnNlcnRlZCBub2RlIGFuZCBzZWxlY3RlZC5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gYmUgaW5zZXJ0ZWRcbiAqIEByZXR1cm5zIFRoZSBub2RlIGFmdGVyIGl0cyBpbnNlcnRpb25cbiAqL1xuZnVuY3Rpb24gJGluc2VydE5vZGVUb05lYXJlc3RSb290KG5vZGUpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpIHx8ICRnZXRQcmV2aW91c1NlbGVjdGlvbigpO1xuICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZvY3VzXG4gICAgfSA9IHNlbGVjdGlvbjtcbiAgICBjb25zdCBmb2N1c05vZGUgPSBmb2N1cy5nZXROb2RlKCk7XG4gICAgY29uc3QgZm9jdXNPZmZzZXQgPSBmb2N1cy5vZmZzZXQ7XG4gICAgaWYgKCRpc1Jvb3RPclNoYWRvd1Jvb3QoZm9jdXNOb2RlKSkge1xuICAgICAgY29uc3QgZm9jdXNDaGlsZCA9IGZvY3VzTm9kZS5nZXRDaGlsZEF0SW5kZXgoZm9jdXNPZmZzZXQpO1xuICAgICAgaWYgKGZvY3VzQ2hpbGQgPT0gbnVsbCkge1xuICAgICAgICBmb2N1c05vZGUuYXBwZW5kKG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9jdXNDaGlsZC5pbnNlcnRCZWZvcmUobm9kZSk7XG4gICAgICB9XG4gICAgICBub2RlLnNlbGVjdE5leHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHNwbGl0Tm9kZTtcbiAgICAgIGxldCBzcGxpdE9mZnNldDtcbiAgICAgIGlmICgkaXNUZXh0Tm9kZShmb2N1c05vZGUpKSB7XG4gICAgICAgIHNwbGl0Tm9kZSA9IGZvY3VzTm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICAgIHNwbGl0T2Zmc2V0ID0gZm9jdXNOb2RlLmdldEluZGV4V2l0aGluUGFyZW50KCk7XG4gICAgICAgIGlmIChmb2N1c09mZnNldCA+IDApIHtcbiAgICAgICAgICBzcGxpdE9mZnNldCArPSAxO1xuICAgICAgICAgIGZvY3VzTm9kZS5zcGxpdFRleHQoZm9jdXNPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcGxpdE5vZGUgPSBmb2N1c05vZGU7XG4gICAgICAgIHNwbGl0T2Zmc2V0ID0gZm9jdXNPZmZzZXQ7XG4gICAgICB9XG4gICAgICBjb25zdCBbLCByaWdodFRyZWVdID0gJHNwbGl0Tm9kZShzcGxpdE5vZGUsIHNwbGl0T2Zmc2V0KTtcbiAgICAgIHJpZ2h0VHJlZS5pbnNlcnRCZWZvcmUobm9kZSk7XG4gICAgICByaWdodFRyZWUuc2VsZWN0U3RhcnQoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHNlbGVjdGlvbiAhPSBudWxsKSB7XG4gICAgICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICAgICAgbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV0uZ2V0VG9wTGV2ZWxFbGVtZW50T3JUaHJvdygpLmluc2VydEFmdGVyKG5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByb290ID0gJGdldFJvb3QoKTtcbiAgICAgIHJvb3QuYXBwZW5kKG5vZGUpO1xuICAgIH1cbiAgICBjb25zdCBwYXJhZ3JhcGhOb2RlID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICBub2RlLmluc2VydEFmdGVyKHBhcmFncmFwaE5vZGUpO1xuICAgIHBhcmFncmFwaE5vZGUuc2VsZWN0KCk7XG4gIH1cbiAgcmV0dXJuIG5vZGUuZ2V0TGF0ZXN0KCk7XG59XG5cbi8qKlxuICogV3JhcHMgdGhlIG5vZGUgaW50byBhbm90aGVyIG5vZGUgY3JlYXRlZCBmcm9tIGEgY3JlYXRlRWxlbWVudE5vZGUgZnVuY3Rpb24sIGVnLiAkY3JlYXRlUGFyYWdyYXBoTm9kZVxuICogQHBhcmFtIG5vZGUgLSBOb2RlIHRvIGJlIHdyYXBwZWQuXG4gKiBAcGFyYW0gY3JlYXRlRWxlbWVudE5vZGUgLSBDcmVhdGVzIGEgbmV3IGxleGljYWwgZWxlbWVudCB0byB3cmFwIHRoZSB0by1iZS13cmFwcGVkIG5vZGUgYW5kIHJldHVybnMgaXQuXG4gKiBAcmV0dXJucyBBIG5ldyBsZXhpY2FsIGVsZW1lbnQgd2l0aCB0aGUgcHJldmlvdXMgbm9kZSBhcHBlbmRlZCB3aXRoaW4gKGFzIGEgY2hpbGQsIGluY2x1ZGluZyBpdHMgY2hpbGRyZW4pLlxuICovXG5mdW5jdGlvbiAkd3JhcE5vZGVJbkVsZW1lbnQobm9kZSwgY3JlYXRlRWxlbWVudE5vZGUpIHtcbiAgY29uc3QgZWxlbWVudE5vZGUgPSBjcmVhdGVFbGVtZW50Tm9kZSgpO1xuICBub2RlLnJlcGxhY2UoZWxlbWVudE5vZGUpO1xuICBlbGVtZW50Tm9kZS5hcHBlbmQobm9kZSk7XG4gIHJldHVybiBlbGVtZW50Tm9kZTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuLyoqXG4gKiBAcGFyYW0gb2JqZWN0ID0gVGhlIGluc3RhbmNlIG9mIHRoZSB0eXBlXG4gKiBAcGFyYW0gb2JqZWN0Q2xhc3MgPSBUaGUgY2xhc3Mgb2YgdGhlIHR5cGVcbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIG9iamVjdCBpcyBoYXMgdGhlIHNhbWUgS2xhc3Mgb2YgdGhlIG9iamVjdENsYXNzLCBpZ25vcmluZyB0aGUgZGlmZmVyZW5jZSBhY3Jvc3Mgd2luZG93IChlLmcuIGRpZmZlcmVudCBpZnJhbXMpXG4gKi9cbmZ1bmN0aW9uIG9iamVjdEtsYXNzRXF1YWxzKG9iamVjdCwgb2JqZWN0Q2xhc3MpIHtcbiAgcmV0dXJuIG9iamVjdCAhPT0gbnVsbCA/IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpLmNvbnN0cnVjdG9yLm5hbWUgPT09IG9iamVjdENsYXNzLm5hbWUgOiBmYWxzZTtcbn1cblxuLyoqXG4gKiBGaWx0ZXIgdGhlIG5vZGVzXG4gKiBAcGFyYW0gbm9kZXMgQXJyYXkgb2Ygbm9kZXMgdGhhdCBuZWVkcyB0byBiZSBmaWx0ZXJlZFxuICogQHBhcmFtIGZpbHRlckZuIEEgZmlsdGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBub2RlIGlmIHRoZSBjdXJyZW50IG5vZGUgc2F0aXNmaWVzIHRoZSBjb25kaXRpb24gb3RoZXJ3aXNlIG51bGxcbiAqIEByZXR1cm5zIEFycmF5IG9mIGZpbHRlcmVkIG5vZGVzXG4gKi9cblxuZnVuY3Rpb24gJGZpbHRlcihub2RlcywgZmlsdGVyRm4pIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gZmlsdGVyRm4obm9kZXNbaV0pO1xuICAgIGlmIChub2RlICE9PSBudWxsKSB7XG4gICAgICByZXN1bHQucHVzaChub2RlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQXBwZW5kcyB0aGUgbm9kZSBiZWZvcmUgdGhlIGZpcnN0IGNoaWxkIG9mIHRoZSBwYXJlbnQgbm9kZVxuICogQHBhcmFtIHBhcmVudCBBIHBhcmVudCBub2RlXG4gKiBAcGFyYW0gbm9kZSBOb2RlIHRoYXQgbmVlZHMgdG8gYmUgYXBwZW5kZWRcbiAqL1xuZnVuY3Rpb24gJGluc2VydEZpcnN0KHBhcmVudCwgbm9kZSkge1xuICBjb25zdCBmaXJzdENoaWxkID0gcGFyZW50LmdldEZpcnN0Q2hpbGQoKTtcbiAgaWYgKGZpcnN0Q2hpbGQgIT09IG51bGwpIHtcbiAgICBmaXJzdENoaWxkLmluc2VydEJlZm9yZShub2RlKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJlbnQuYXBwZW5kKG5vZGUpO1xuICB9XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgem9vbSBsZXZlbCBvZiBhbiBlbGVtZW50IGFzIGEgcmVzdWx0IG9mIHVzaW5nXG4gKiBjc3Mgem9vbSBwcm9wZXJ0eS5cbiAqIEBwYXJhbSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZVpvb21MZXZlbChlbGVtZW50KSB7XG4gIGlmIChJU19GSVJFRk9YKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgbGV0IHpvb20gPSAxO1xuICB3aGlsZSAoZWxlbWVudCkge1xuICAgIHpvb20gKj0gTnVtYmVyKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoJ3pvb20nKSk7XG4gICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgfVxuICByZXR1cm4gem9vbTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGVkaXRvciBpcyBhIG5lc3RlZCBlZGl0b3IgY3JlYXRlZCBieSBMZXhpY2FsTmVzdGVkQ29tcG9zZXJcbiAqL1xuZnVuY3Rpb24gJGlzRWRpdG9ySXNOZXN0ZWRFZGl0b3IoZWRpdG9yKSB7XG4gIHJldHVybiBlZGl0b3IuX3BhcmVudEVkaXRvciAhPT0gbnVsbDtcbn1cblxuZXhwb3J0IHsgJGRmcywgJGRmc0l0ZXJhdG9yLCAkZmlsdGVyLCAkZmluZE1hdGNoaW5nUGFyZW50LCAkZ2V0RGVwdGgsICRnZXROZWFyZXN0QmxvY2tFbGVtZW50QW5jZXN0b3JPclRocm93LCAkZ2V0TmVhcmVzdE5vZGVPZlR5cGUsICRnZXROZXh0UmlnaHRQcmVvcmRlck5vZGUsICRnZXROZXh0U2libGluZ09yUGFyZW50U2libGluZywgJGluc2VydEZpcnN0LCAkaW5zZXJ0Tm9kZVRvTmVhcmVzdFJvb3QsICRpc0VkaXRvcklzTmVzdGVkRWRpdG9yLCAkcmVzdG9yZUVkaXRvclN0YXRlLCAkd3JhcE5vZGVJbkVsZW1lbnQsIENBTl9VU0VfQkVGT1JFX0lOUFVULCBDQU5fVVNFX0RPTSwgSVNfQU5EUk9JRCwgSVNfQU5EUk9JRF9DSFJPTUUsIElTX0FQUExFLCBJU19BUFBMRV9XRUJLSVQsIElTX0NIUk9NRSwgSVNfRklSRUZPWCwgSVNfSU9TLCBJU19TQUZBUkksIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQsIGNhbGN1bGF0ZVpvb21MZXZlbCwgaXNNaW1lVHlwZSwgbWFya1NlbGVjdGlvbiwgbWVkaWFGaWxlUmVhZGVyLCBtZXJnZVJlZ2lzdGVyLCBvYmplY3RLbGFzc0VxdWFscywgcG9zaXRpb25Ob2RlT25SYW5nZSwgcmVnaXN0ZXJOZXN0ZWRFbGVtZW50UmVzb2x2ZXIsIHJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@lexical+utils@0.20.0/node_modules/@lexical/utils/LexicalUtils.dev.mjs\n");

/***/ })

};
;
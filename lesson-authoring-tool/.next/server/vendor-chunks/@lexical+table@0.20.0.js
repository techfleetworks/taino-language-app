"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lexical+table@0.20.0";
exports.ids = ["vendor-chunks/@lexical+table@0.20.0"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/@lexical+table@0.20.0/node_modules/@lexical/table/LexicalTable.dev.mjs":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@lexical+table@0.20.0/node_modules/@lexical/table/LexicalTable.dev.mjs ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $computeTableMap: () => (/* binding */ $computeTableMap),\n/* harmony export */   $computeTableMapSkipCellCheck: () => (/* binding */ $computeTableMapSkipCellCheck),\n/* harmony export */   $createTableCellNode: () => (/* binding */ $createTableCellNode),\n/* harmony export */   $createTableNode: () => (/* binding */ $createTableNode),\n/* harmony export */   $createTableNodeWithDimensions: () => (/* binding */ $createTableNodeWithDimensions),\n/* harmony export */   $createTableRowNode: () => (/* binding */ $createTableRowNode),\n/* harmony export */   $createTableSelection: () => (/* binding */ $createTableSelection),\n/* harmony export */   $deleteTableColumn: () => (/* binding */ $deleteTableColumn),\n/* harmony export */   $deleteTableColumn__EXPERIMENTAL: () => (/* binding */ $deleteTableColumn__EXPERIMENTAL),\n/* harmony export */   $deleteTableRow__EXPERIMENTAL: () => (/* binding */ $deleteTableRow__EXPERIMENTAL),\n/* harmony export */   $findCellNode: () => (/* binding */ $findCellNode),\n/* harmony export */   $findTableNode: () => (/* binding */ $findTableNode),\n/* harmony export */   $getElementForTableNode: () => (/* binding */ $getElementForTableNode),\n/* harmony export */   $getNodeTriplet: () => (/* binding */ $getNodeTriplet),\n/* harmony export */   $getTableCellNodeFromLexicalNode: () => (/* binding */ $getTableCellNodeFromLexicalNode),\n/* harmony export */   $getTableCellNodeRect: () => (/* binding */ $getTableCellNodeRect),\n/* harmony export */   $getTableColumnIndexFromTableCellNode: () => (/* binding */ $getTableColumnIndexFromTableCellNode),\n/* harmony export */   $getTableNodeFromLexicalNodeOrThrow: () => (/* binding */ $getTableNodeFromLexicalNodeOrThrow),\n/* harmony export */   $getTableRowIndexFromTableCellNode: () => (/* binding */ $getTableRowIndexFromTableCellNode),\n/* harmony export */   $getTableRowNodeFromTableCellNodeOrThrow: () => (/* binding */ $getTableRowNodeFromTableCellNodeOrThrow),\n/* harmony export */   $insertTableColumn: () => (/* binding */ $insertTableColumn),\n/* harmony export */   $insertTableColumn__EXPERIMENTAL: () => (/* binding */ $insertTableColumn__EXPERIMENTAL),\n/* harmony export */   $insertTableRow: () => (/* binding */ $insertTableRow),\n/* harmony export */   $insertTableRow__EXPERIMENTAL: () => (/* binding */ $insertTableRow__EXPERIMENTAL),\n/* harmony export */   $isTableCellNode: () => (/* binding */ $isTableCellNode),\n/* harmony export */   $isTableNode: () => (/* binding */ $isTableNode),\n/* harmony export */   $isTableRowNode: () => (/* binding */ $isTableRowNode),\n/* harmony export */   $isTableSelection: () => (/* binding */ $isTableSelection),\n/* harmony export */   $removeTableRowAtIndex: () => (/* binding */ $removeTableRowAtIndex),\n/* harmony export */   $unmergeCell: () => (/* binding */ $unmergeCell),\n/* harmony export */   INSERT_TABLE_COMMAND: () => (/* binding */ INSERT_TABLE_COMMAND),\n/* harmony export */   TableCellHeaderStates: () => (/* binding */ TableCellHeaderStates),\n/* harmony export */   TableCellNode: () => (/* binding */ TableCellNode),\n/* harmony export */   TableNode: () => (/* binding */ TableNode),\n/* harmony export */   TableObserver: () => (/* binding */ TableObserver),\n/* harmony export */   TableRowNode: () => (/* binding */ TableRowNode),\n/* harmony export */   applyTableHandlers: () => (/* binding */ applyTableHandlers),\n/* harmony export */   getDOMCellFromTarget: () => (/* binding */ getDOMCellFromTarget),\n/* harmony export */   getTableObserverFromTableElement: () => (/* binding */ getTableObserverFromTableElement)\n/* harmony export */ });\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/utils */ \"(rsc)/./node_modules/.pnpm/@lexical+utils@0.20.0/node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(rsc)/./node_modules/.pnpm/lexical@0.20.0/node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var _lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/clipboard */ \"(rsc)/./node_modules/.pnpm/@lexical+clipboard@0.20.0/node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst PIXEL_VALUE_REG_EXP = /^(\\d+(?:\\.\\d+)?)px$/;\n\n// .PlaygroundEditorTheme__tableCell width value from\n// packages/lexical-playground/src/themes/PlaygroundEditorTheme.css\nconst COLUMN_WIDTH = 75;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst TableCellHeaderStates = {\n  BOTH: 3,\n  COLUMN: 2,\n  NO_STATUS: 0,\n  ROW: 1\n};\n/** @noInheritDoc */\nclass TableCellNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'tablecell';\n  }\n  static clone(node) {\n    return new TableCellNode(node.__headerState, node.__colSpan, node.__width, node.__key);\n  }\n  afterCloneFrom(node) {\n    super.afterCloneFrom(node);\n    this.__rowSpan = node.__rowSpan;\n    this.__backgroundColor = node.__backgroundColor;\n  }\n  static importDOM() {\n    return {\n      td: node => ({\n        conversion: $convertTableCellNodeElement,\n        priority: 0\n      }),\n      th: node => ({\n        conversion: $convertTableCellNodeElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const colSpan = serializedNode.colSpan || 1;\n    const rowSpan = serializedNode.rowSpan || 1;\n    return $createTableCellNode(serializedNode.headerState, colSpan, serializedNode.width || undefined).setRowSpan(rowSpan).setBackgroundColor(serializedNode.backgroundColor || null);\n  }\n  constructor(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width, key) {\n    super(key);\n    this.__colSpan = colSpan;\n    this.__rowSpan = 1;\n    this.__headerState = headerState;\n    this.__width = width;\n    this.__backgroundColor = null;\n  }\n  createDOM(config) {\n    const element = document.createElement(this.getTag());\n    if (this.__width) {\n      element.style.width = `${this.__width}px`;\n    }\n    if (this.__colSpan > 1) {\n      element.colSpan = this.__colSpan;\n    }\n    if (this.__rowSpan > 1) {\n      element.rowSpan = this.__rowSpan;\n    }\n    if (this.__backgroundColor !== null) {\n      element.style.backgroundColor = this.__backgroundColor;\n    }\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, config.theme.tableCell, this.hasHeader() && config.theme.tableCellHeader);\n    return element;\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element) {\n      const element_ = element;\n      element_.style.border = '1px solid black';\n      if (this.__colSpan > 1) {\n        element_.colSpan = this.__colSpan;\n      }\n      if (this.__rowSpan > 1) {\n        element_.rowSpan = this.__rowSpan;\n      }\n      element_.style.width = `${this.getWidth() || COLUMN_WIDTH}px`;\n      element_.style.verticalAlign = 'top';\n      element_.style.textAlign = 'start';\n      const backgroundColor = this.getBackgroundColor();\n      if (backgroundColor !== null) {\n        element_.style.backgroundColor = backgroundColor;\n      } else if (this.hasHeader()) {\n        element_.style.backgroundColor = '#f2f3f5';\n      }\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      backgroundColor: this.getBackgroundColor(),\n      colSpan: this.__colSpan,\n      headerState: this.__headerState,\n      rowSpan: this.__rowSpan,\n      type: 'tablecell',\n      width: this.getWidth()\n    };\n  }\n  getColSpan() {\n    return this.getLatest().__colSpan;\n  }\n  setColSpan(colSpan) {\n    const self = this.getWritable();\n    self.__colSpan = colSpan;\n    return self;\n  }\n  getRowSpan() {\n    return this.getLatest().__rowSpan;\n  }\n  setRowSpan(rowSpan) {\n    const self = this.getWritable();\n    self.__rowSpan = rowSpan;\n    return self;\n  }\n  getTag() {\n    return this.hasHeader() ? 'th' : 'td';\n  }\n  setHeaderStyles(headerState, mask = TableCellHeaderStates.BOTH) {\n    const self = this.getWritable();\n    self.__headerState = headerState & mask | self.__headerState & ~mask;\n    return self;\n  }\n  getHeaderStyles() {\n    return this.getLatest().__headerState;\n  }\n  setWidth(width) {\n    const self = this.getWritable();\n    self.__width = width;\n    return self;\n  }\n  getWidth() {\n    return this.getLatest().__width;\n  }\n  getBackgroundColor() {\n    return this.getLatest().__backgroundColor;\n  }\n  setBackgroundColor(newBackgroundColor) {\n    const self = this.getWritable();\n    self.__backgroundColor = newBackgroundColor;\n    return self;\n  }\n  toggleHeaderStyle(headerStateToToggle) {\n    const self = this.getWritable();\n    if ((self.__headerState & headerStateToToggle) === headerStateToToggle) {\n      self.__headerState -= headerStateToToggle;\n    } else {\n      self.__headerState += headerStateToToggle;\n    }\n    return self;\n  }\n  hasHeaderState(headerState) {\n    return (this.getHeaderStyles() & headerState) === headerState;\n  }\n  hasHeader() {\n    return this.getLatest().__headerState !== TableCellHeaderStates.NO_STATUS;\n  }\n  updateDOM(prevNode) {\n    return prevNode.__headerState !== this.__headerState || prevNode.__width !== this.__width || prevNode.__colSpan !== this.__colSpan || prevNode.__rowSpan !== this.__rowSpan || prevNode.__backgroundColor !== this.__backgroundColor;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  collapseAtStart() {\n    return true;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction $convertTableCellNodeElement(domNode) {\n  const domNode_ = domNode;\n  const nodeName = domNode.nodeName.toLowerCase();\n  let width = undefined;\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.width)) {\n    width = parseFloat(domNode_.style.width);\n  }\n  const tableCellNode = $createTableCellNode(nodeName === 'th' ? TableCellHeaderStates.ROW : TableCellHeaderStates.NO_STATUS, domNode_.colSpan, width);\n  tableCellNode.__rowSpan = domNode_.rowSpan;\n  const backgroundColor = domNode_.style.backgroundColor;\n  if (backgroundColor !== '') {\n    tableCellNode.__backgroundColor = backgroundColor;\n  }\n  const style = domNode_.style;\n  const textDecoration = (style && style.textDecoration || '').split(' ');\n  const hasBoldFontWeight = style.fontWeight === '700' || style.fontWeight === 'bold';\n  const hasLinethroughTextDecoration = textDecoration.includes('line-through');\n  const hasItalicFontStyle = style.fontStyle === 'italic';\n  const hasUnderlineTextDecoration = textDecoration.includes('underline');\n  return {\n    after: childLexicalNodes => {\n      if (childLexicalNodes.length === 0) {\n        childLexicalNodes.push((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n      }\n      return childLexicalNodes;\n    },\n    forChild: (lexicalNode, parentLexicalNode) => {\n      if ($isTableCellNode(parentLexicalNode) && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(lexicalNode)) {\n        const paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLineBreakNode)(lexicalNode) && lexicalNode.getTextContent() === '\\n') {\n          return null;\n        }\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(lexicalNode)) {\n          if (hasBoldFontWeight) {\n            lexicalNode.toggleFormat('bold');\n          }\n          if (hasLinethroughTextDecoration) {\n            lexicalNode.toggleFormat('strikethrough');\n          }\n          if (hasItalicFontStyle) {\n            lexicalNode.toggleFormat('italic');\n          }\n          if (hasUnderlineTextDecoration) {\n            lexicalNode.toggleFormat('underline');\n          }\n        }\n        paragraphNode.append(lexicalNode);\n        return paragraphNode;\n      }\n      return lexicalNode;\n    },\n    node: tableCellNode\n  };\n}\nfunction $createTableCellNode(headerState, colSpan = 1, width) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new TableCellNode(headerState, colSpan, width));\n}\nfunction $isTableCellNode(node) {\n  return node instanceof TableCellNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst INSERT_TABLE_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('INSERT_TABLE_COMMAND');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TableRowNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'tablerow';\n  }\n  static clone(node) {\n    return new TableRowNode(node.__height, node.__key);\n  }\n  static importDOM() {\n    return {\n      tr: node => ({\n        conversion: $convertTableRowElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTableRowNode(serializedNode.height);\n  }\n  constructor(height, key) {\n    super(key);\n    this.__height = height;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      ...(this.getHeight() && {\n        height: this.getHeight()\n      }),\n      type: 'tablerow',\n      version: 1\n    };\n  }\n  createDOM(config) {\n    const element = document.createElement('tr');\n    if (this.__height) {\n      element.style.height = `${this.__height}px`;\n    }\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, config.theme.tableRow);\n    return element;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  setHeight(height) {\n    const self = this.getWritable();\n    self.__height = height;\n    return this.__height;\n  }\n  getHeight() {\n    return this.getLatest().__height;\n  }\n  updateDOM(prevNode) {\n    return prevNode.__height !== this.__height;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction $convertTableRowElement(domNode) {\n  const domNode_ = domNode;\n  let height = undefined;\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.height)) {\n    height = parseFloat(domNode_.style.height);\n  }\n  return {\n    node: $createTableRowNode(height)\n  };\n}\nfunction $createTableRowNode(height) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new TableRowNode(height));\n}\nfunction $isTableRowNode(node) {\n  return node instanceof TableRowNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $createTableNodeWithDimensions(rowCount, columnCount, includeHeaders = true) {\n  const tableNode = $createTableNode();\n  for (let iRow = 0; iRow < rowCount; iRow++) {\n    const tableRowNode = $createTableRowNode();\n    for (let iColumn = 0; iColumn < columnCount; iColumn++) {\n      let headerState = TableCellHeaderStates.NO_STATUS;\n      if (typeof includeHeaders === 'object') {\n        if (iRow === 0 && includeHeaders.rows) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        if (iColumn === 0 && includeHeaders.columns) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n      } else if (includeHeaders) {\n        if (iRow === 0) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        if (iColumn === 0) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n      }\n      const tableCellNode = $createTableCellNode(headerState);\n      const paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n      paragraphNode.append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)());\n      tableCellNode.append(paragraphNode);\n      tableRowNode.append(tableCellNode);\n    }\n    tableNode.append(tableRowNode);\n  }\n  return tableNode;\n}\nfunction $getTableCellNodeFromLexicalNode(startingNode) {\n  const node = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(startingNode, n => $isTableCellNode(n));\n  if ($isTableCellNode(node)) {\n    return node;\n  }\n  return null;\n}\nfunction $getTableRowNodeFromTableCellNodeOrThrow(startingNode) {\n  const node = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(startingNode, n => $isTableRowNode(n));\n  if ($isTableRowNode(node)) {\n    return node;\n  }\n  throw new Error('Expected table cell to be inside of table row.');\n}\nfunction $getTableNodeFromLexicalNodeOrThrow(startingNode) {\n  const node = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(startingNode, n => $isTableNode(n));\n  if ($isTableNode(node)) {\n    return node;\n  }\n  throw new Error('Expected table cell to be inside of table.');\n}\nfunction $getTableRowIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableRowNode);\n  return tableNode.getChildren().findIndex(n => n.is(tableRowNode));\n}\nfunction $getTableColumnIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  return tableRowNode.getChildren().findIndex(n => n.is(tableCellNode));\n}\nfunction $getTableCellSiblingsFromTableCellNode(tableCellNode, table) {\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode);\n  const {\n    x,\n    y\n  } = tableNode.getCordsFromCellNode(tableCellNode, table);\n  return {\n    above: tableNode.getCellNodeFromCords(x, y - 1, table),\n    below: tableNode.getCellNodeFromCords(x, y + 1, table),\n    left: tableNode.getCellNodeFromCords(x - 1, y, table),\n    right: tableNode.getCellNodeFromCords(x + 1, y, table)\n  };\n}\nfunction $removeTableRowAtIndex(tableNode, indexToDelete) {\n  const tableRows = tableNode.getChildren();\n  if (indexToDelete >= tableRows.length || indexToDelete < 0) {\n    throw new Error('Expected table cell to be inside of table row.');\n  }\n  const targetRowNode = tableRows[indexToDelete];\n  targetRowNode.remove();\n  return tableNode;\n}\nfunction $insertTableRow(tableNode, targetIndex, shouldInsertAfter = true, rowCount, table) {\n  const tableRows = tableNode.getChildren();\n  if (targetIndex >= tableRows.length || targetIndex < 0) {\n    throw new Error('Table row target index out of range');\n  }\n  const targetRowNode = tableRows[targetIndex];\n  if ($isTableRowNode(targetRowNode)) {\n    for (let r = 0; r < rowCount; r++) {\n      const tableRowCells = targetRowNode.getChildren();\n      const tableColumnCount = tableRowCells.length;\n      const newTableRowNode = $createTableRowNode();\n      for (let c = 0; c < tableColumnCount; c++) {\n        const tableCellFromTargetRow = tableRowCells[c];\n        if (!$isTableCellNode(tableCellFromTargetRow)) {\n          throw Error(`Expected table cell`);\n        }\n        const {\n          above,\n          below\n        } = $getTableCellSiblingsFromTableCellNode(tableCellFromTargetRow, table);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        const width = above && above.getWidth() || below && below.getWidth() || undefined;\n        if (above && above.hasHeaderState(TableCellHeaderStates.COLUMN) || below && below.hasHeaderState(TableCellHeaderStates.COLUMN)) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n        const tableCellNode = $createTableCellNode(headerState, 1, width);\n        tableCellNode.append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n        newTableRowNode.append(tableCellNode);\n      }\n      if (shouldInsertAfter) {\n        targetRowNode.insertAfter(newTableRowNode);\n      } else {\n        targetRowNode.insertBefore(newTableRowNode);\n      }\n    }\n  } else {\n    throw new Error('Row before insertion index does not exist.');\n  }\n  return tableNode;\n}\nconst getHeaderState = (currentState, possibleState) => {\n  if (currentState === TableCellHeaderStates.BOTH || currentState === possibleState) {\n    return possibleState;\n  }\n  return TableCellHeaderStates.NO_STATUS;\n};\n\n/**\n * Inserts a table row before or after the current focus cell node,\n * taking into account any spans. If successful, returns the\n * inserted table row node.\n */\nfunction $insertTableRow__EXPERIMENTAL(insertAfter = true) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const focus = selection.focus.getNode();\n  const [focusCell,, grid] = $getNodeTriplet(focus);\n  const [gridMap, focusCellMap] = $computeTableMap(grid, focusCell, focusCell);\n  const columnCount = gridMap[0].length;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  let insertedRow = null;\n  if (insertAfter) {\n    const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;\n    const focusEndRowMap = gridMap[focusEndRow];\n    const newRow = $createTableRowNode();\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = focusEndRowMap[i];\n      if (startRow + cell.__rowSpan - 1 <= focusEndRow) {\n        const currentCell = focusEndRowMap[i].cell;\n        const currentCellHeaderState = currentCell.__headerState;\n        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);\n        newRow.append($createTableCellNode(headerState).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)()));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n    const focusEndRowNode = grid.getChildAtIndex(focusEndRow);\n    if (!$isTableRowNode(focusEndRowNode)) {\n      throw Error(`focusEndRow is not a TableRowNode`);\n    }\n    focusEndRowNode.insertAfter(newRow);\n    insertedRow = newRow;\n  } else {\n    const focusStartRowMap = gridMap[focusStartRow];\n    const newRow = $createTableRowNode();\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = focusStartRowMap[i];\n      if (startRow === focusStartRow) {\n        const currentCell = focusStartRowMap[i].cell;\n        const currentCellHeaderState = currentCell.__headerState;\n        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);\n        newRow.append($createTableCellNode(headerState).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)()));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n    const focusStartRowNode = grid.getChildAtIndex(focusStartRow);\n    if (!$isTableRowNode(focusStartRowNode)) {\n      throw Error(`focusEndRow is not a TableRowNode`);\n    }\n    focusStartRowNode.insertBefore(newRow);\n    insertedRow = newRow;\n  }\n  return insertedRow;\n}\nfunction $insertTableColumn(tableNode, targetIndex, shouldInsertAfter = true, columnCount, table) {\n  const tableRows = tableNode.getChildren();\n  const tableCellsToBeInserted = [];\n  for (let r = 0; r < tableRows.length; r++) {\n    const currentTableRowNode = tableRows[r];\n    if ($isTableRowNode(currentTableRowNode)) {\n      for (let c = 0; c < columnCount; c++) {\n        const tableRowChildren = currentTableRowNode.getChildren();\n        if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n          throw new Error('Table column target index out of range');\n        }\n        const targetCell = tableRowChildren[targetIndex];\n        if (!$isTableCellNode(targetCell)) {\n          throw Error(`Expected table cell`);\n        }\n        const {\n          left,\n          right\n        } = $getTableCellSiblingsFromTableCellNode(targetCell, table);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        if (left && left.hasHeaderState(TableCellHeaderStates.ROW) || right && right.hasHeaderState(TableCellHeaderStates.ROW)) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        const newTableCell = $createTableCellNode(headerState);\n        newTableCell.append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n        tableCellsToBeInserted.push({\n          newTableCell,\n          targetCell\n        });\n      }\n    }\n  }\n  tableCellsToBeInserted.forEach(({\n    newTableCell,\n    targetCell\n  }) => {\n    if (shouldInsertAfter) {\n      targetCell.insertAfter(newTableCell);\n    } else {\n      targetCell.insertBefore(newTableCell);\n    }\n  });\n  return tableNode;\n}\n\n/**\n * Inserts a column before or after the current focus cell node,\n * taking into account any spans. If successful, returns the\n * first inserted cell node.\n */\nfunction $insertTableColumn__EXPERIMENTAL(insertAfter = true) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell] = $getNodeTriplet(anchor);\n  const [focusCell,, grid] = $getNodeTriplet(focus);\n  const [gridMap, focusCellMap, anchorCellMap] = $computeTableMap(grid, focusCell, anchorCell);\n  const rowCount = gridMap.length;\n  const startColumn = insertAfter ? Math.max(focusCellMap.startColumn, anchorCellMap.startColumn) : Math.min(focusCellMap.startColumn, anchorCellMap.startColumn);\n  const insertAfterColumn = insertAfter ? startColumn + focusCell.__colSpan - 1 : startColumn - 1;\n  const gridFirstChild = grid.getFirstChild();\n  if (!$isTableRowNode(gridFirstChild)) {\n    throw Error(`Expected firstTable child to be a row`);\n  }\n  let firstInsertedCell = null;\n  function $createTableCellNodeForInsertTableColumn(headerState = TableCellHeaderStates.NO_STATUS) {\n    const cell = $createTableCellNode(headerState).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n    if (firstInsertedCell === null) {\n      firstInsertedCell = cell;\n    }\n    return cell;\n  }\n  let loopRow = gridFirstChild;\n  rowLoop: for (let i = 0; i < rowCount; i++) {\n    if (i !== 0) {\n      const currentRow = loopRow.getNextSibling();\n      if (!$isTableRowNode(currentRow)) {\n        throw Error(`Expected row nextSibling to be a row`);\n      }\n      loopRow = currentRow;\n    }\n    const rowMap = gridMap[i];\n    const currentCellHeaderState = rowMap[insertAfterColumn < 0 ? 0 : insertAfterColumn].cell.__headerState;\n    const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.ROW);\n    if (insertAfterColumn < 0) {\n      $insertFirst(loopRow, $createTableCellNodeForInsertTableColumn(headerState));\n      continue;\n    }\n    const {\n      cell: currentCell,\n      startColumn: currentStartColumn,\n      startRow: currentStartRow\n    } = rowMap[insertAfterColumn];\n    if (currentStartColumn + currentCell.__colSpan - 1 <= insertAfterColumn) {\n      let insertAfterCell = currentCell;\n      let insertAfterCellRowStart = currentStartRow;\n      let prevCellIndex = insertAfterColumn;\n      while (insertAfterCellRowStart !== i && insertAfterCell.__rowSpan > 1) {\n        prevCellIndex -= currentCell.__colSpan;\n        if (prevCellIndex >= 0) {\n          const {\n            cell: cell_,\n            startRow: startRow_\n          } = rowMap[prevCellIndex];\n          insertAfterCell = cell_;\n          insertAfterCellRowStart = startRow_;\n        } else {\n          loopRow.append($createTableCellNodeForInsertTableColumn(headerState));\n          continue rowLoop;\n        }\n      }\n      insertAfterCell.insertAfter($createTableCellNodeForInsertTableColumn(headerState));\n    } else {\n      currentCell.setColSpan(currentCell.__colSpan + 1);\n    }\n  }\n  if (firstInsertedCell !== null) {\n    $moveSelectionToCell(firstInsertedCell);\n  }\n  const colWidths = grid.getColWidths();\n  if (colWidths) {\n    const newColWidths = [...colWidths];\n    const columnIndex = insertAfterColumn < 0 ? 0 : insertAfterColumn;\n    const newWidth = newColWidths[columnIndex];\n    newColWidths.splice(columnIndex, 0, newWidth);\n    grid.setColWidths(newColWidths);\n  }\n  return firstInsertedCell;\n}\nfunction $deleteTableColumn(tableNode, targetIndex) {\n  const tableRows = tableNode.getChildren();\n  for (let i = 0; i < tableRows.length; i++) {\n    const currentTableRowNode = tableRows[i];\n    if ($isTableRowNode(currentTableRowNode)) {\n      const tableRowChildren = currentTableRowNode.getChildren();\n      if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n        throw new Error('Table column target index out of range');\n      }\n      tableRowChildren[targetIndex].remove();\n    }\n  }\n  return tableNode;\n}\nfunction $deleteTableRow__EXPERIMENTAL() {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const [anchor, focus] = selection.isBackward() ? [selection.focus.getNode(), selection.anchor.getNode()] : [selection.anchor.getNode(), selection.focus.getNode()];\n  const [anchorCell,, grid] = $getNodeTriplet(anchor);\n  const [focusCell] = $getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);\n  const {\n    startRow: anchorStartRow\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;\n  if (gridMap.length === focusEndRow - anchorStartRow + 1) {\n    // Empty grid\n    grid.remove();\n    return;\n  }\n  const columnCount = gridMap[0].length;\n  const nextRow = gridMap[focusEndRow + 1];\n  const nextRowNode = grid.getChildAtIndex(focusEndRow + 1);\n  for (let row = focusEndRow; row >= anchorStartRow; row--) {\n    for (let column = columnCount - 1; column >= 0; column--) {\n      const {\n        cell,\n        startRow: cellStartRow,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n      if (cellStartColumn !== column) {\n        // Don't repeat work for the same Cell\n        continue;\n      }\n      // Rows overflowing top have to be trimmed\n      if (row === anchorStartRow && cellStartRow < anchorStartRow) {\n        cell.setRowSpan(cell.__rowSpan - (cellStartRow - anchorStartRow));\n      }\n      // Rows overflowing bottom have to be trimmed and moved to the next row\n      if (cellStartRow >= anchorStartRow && cellStartRow + cell.__rowSpan - 1 > focusEndRow) {\n        cell.setRowSpan(cell.__rowSpan - (focusEndRow - cellStartRow + 1));\n        if (!(nextRowNode !== null)) {\n          throw Error(`Expected nextRowNode not to be null`);\n        }\n        if (column === 0) {\n          $insertFirst(nextRowNode, cell);\n        } else {\n          const {\n            cell: previousCell\n          } = nextRow[column - 1];\n          previousCell.insertAfter(cell);\n        }\n      }\n    }\n    const rowNode = grid.getChildAtIndex(row);\n    if (!$isTableRowNode(rowNode)) {\n      throw Error(`Expected TableNode childAtIndex(${String(row)}) to be RowNode`);\n    }\n    rowNode.remove();\n  }\n  if (nextRow !== undefined) {\n    const {\n      cell\n    } = nextRow[0];\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = gridMap[anchorStartRow - 1];\n    const {\n      cell\n    } = previousRow[0];\n    $moveSelectionToCell(cell);\n  }\n}\nfunction $deleteTableColumn__EXPERIMENTAL() {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell,, grid] = $getNodeTriplet(anchor);\n  const [focusCell] = $getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);\n  const {\n    startColumn: anchorStartColumn\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow,\n    startColumn: focusStartColumn\n  } = focusCellMap;\n  const startColumn = Math.min(anchorStartColumn, focusStartColumn);\n  const endColumn = Math.max(anchorStartColumn + anchorCell.__colSpan - 1, focusStartColumn + focusCell.__colSpan - 1);\n  const selectedColumnCount = endColumn - startColumn + 1;\n  const columnCount = gridMap[0].length;\n  if (columnCount === endColumn - startColumn + 1) {\n    // Empty grid\n    grid.selectPrevious();\n    grid.remove();\n    return;\n  }\n  const rowCount = gridMap.length;\n  for (let row = 0; row < rowCount; row++) {\n    for (let column = startColumn; column <= endColumn; column++) {\n      const {\n        cell,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n      if (cellStartColumn < startColumn) {\n        if (column === startColumn) {\n          const overflowLeft = startColumn - cellStartColumn;\n          // Overflowing left\n          cell.setColSpan(cell.__colSpan -\n          // Possible overflow right too\n          Math.min(selectedColumnCount, cell.__colSpan - overflowLeft));\n        }\n      } else if (cellStartColumn + cell.__colSpan - 1 > endColumn) {\n        if (column === endColumn) {\n          // Overflowing right\n          const inSelectedArea = endColumn - cellStartColumn + 1;\n          cell.setColSpan(cell.__colSpan - inSelectedArea);\n        }\n      } else {\n        cell.remove();\n      }\n    }\n  }\n  const focusRowMap = gridMap[focusStartRow];\n  const nextColumn = anchorStartColumn > focusStartColumn ? focusRowMap[anchorStartColumn + anchorCell.__colSpan] : focusRowMap[focusStartColumn + focusCell.__colSpan];\n  if (nextColumn !== undefined) {\n    const {\n      cell\n    } = nextColumn;\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = focusStartColumn < anchorStartColumn ? focusRowMap[focusStartColumn - 1] : focusRowMap[anchorStartColumn - 1];\n    const {\n      cell\n    } = previousRow;\n    $moveSelectionToCell(cell);\n  }\n  const colWidths = grid.getColWidths();\n  if (colWidths) {\n    const newColWidths = [...colWidths];\n    newColWidths.splice(startColumn, selectedColumnCount);\n    grid.setColWidths(newColWidths);\n  }\n}\nfunction $moveSelectionToCell(cell) {\n  const firstDescendant = cell.getFirstDescendant();\n  if (firstDescendant == null) {\n    cell.selectStart();\n  } else {\n    firstDescendant.getParentOrThrow().selectStart();\n  }\n}\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\nfunction $unmergeCell() {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const [cell, row, grid] = $getNodeTriplet(anchor);\n  const colSpan = cell.__colSpan;\n  const rowSpan = cell.__rowSpan;\n  if (colSpan === 1 && rowSpan === 1) {\n    return;\n  }\n  const [map, cellMap] = $computeTableMap(grid, cell, cell);\n  const {\n    startColumn,\n    startRow\n  } = cellMap;\n  // Create a heuristic for what the style of the unmerged cells should be\n  // based on whether every row or column already had that state before the\n  // unmerge.\n  const baseColStyle = cell.__headerState & TableCellHeaderStates.COLUMN;\n  const colStyles = Array.from({\n    length: colSpan\n  }, (_v, i) => {\n    let colStyle = baseColStyle;\n    for (let rowIdx = 0; colStyle !== 0 && rowIdx < map.length; rowIdx++) {\n      colStyle &= map[rowIdx][i + startColumn].cell.__headerState;\n    }\n    return colStyle;\n  });\n  const baseRowStyle = cell.__headerState & TableCellHeaderStates.ROW;\n  const rowStyles = Array.from({\n    length: rowSpan\n  }, (_v, i) => {\n    let rowStyle = baseRowStyle;\n    for (let colIdx = 0; rowStyle !== 0 && colIdx < map[0].length; colIdx++) {\n      rowStyle &= map[i + startRow][colIdx].cell.__headerState;\n    }\n    return rowStyle;\n  });\n  if (colSpan > 1) {\n    for (let i = 1; i < colSpan; i++) {\n      cell.insertAfter($createTableCellNode(colStyles[i] | rowStyles[0]).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)()));\n    }\n    cell.setColSpan(1);\n  }\n  if (rowSpan > 1) {\n    let currentRowNode;\n    for (let i = 1; i < rowSpan; i++) {\n      const currentRow = startRow + i;\n      const currentRowMap = map[currentRow];\n      currentRowNode = (currentRowNode || row).getNextSibling();\n      if (!$isTableRowNode(currentRowNode)) {\n        throw Error(`Expected row next sibling to be a row`);\n      }\n      let insertAfterCell = null;\n      for (let column = 0; column < startColumn; column++) {\n        const currentCellMap = currentRowMap[column];\n        const currentCell = currentCellMap.cell;\n        if (currentCellMap.startRow === currentRow) {\n          insertAfterCell = currentCell;\n        }\n        if (currentCell.__colSpan > 1) {\n          column += currentCell.__colSpan - 1;\n        }\n      }\n      if (insertAfterCell === null) {\n        for (let j = colSpan - 1; j >= 0; j--) {\n          $insertFirst(currentRowNode, $createTableCellNode(colStyles[j] | rowStyles[i]).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)()));\n        }\n      } else {\n        for (let j = colSpan - 1; j >= 0; j--) {\n          insertAfterCell.insertAfter($createTableCellNode(colStyles[j] | rowStyles[i]).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)()));\n        }\n      }\n    }\n    cell.setRowSpan(1);\n  }\n}\nfunction $computeTableMap(grid, cellA, cellB) {\n  const [tableMap, cellAValue, cellBValue] = $computeTableMapSkipCellCheck(grid, cellA, cellB);\n  if (!(cellAValue !== null)) {\n    throw Error(`Anchor not found in Table`);\n  }\n  if (!(cellBValue !== null)) {\n    throw Error(`Focus not found in Table`);\n  }\n  return [tableMap, cellAValue, cellBValue];\n}\nfunction $computeTableMapSkipCellCheck(grid, cellA, cellB) {\n  const tableMap = [];\n  let cellAValue = null;\n  let cellBValue = null;\n  function getMapRow(i) {\n    let row = tableMap[i];\n    if (row === undefined) {\n      tableMap[i] = row = [];\n    }\n    return row;\n  }\n  const gridChildren = grid.getChildren();\n  for (let rowIdx = 0; rowIdx < gridChildren.length; rowIdx++) {\n    const row = gridChildren[rowIdx];\n    if (!$isTableRowNode(row)) {\n      throw Error(`Expected TableNode children to be TableRowNode`);\n    }\n    for (let cell = row.getFirstChild(), colIdx = 0; cell != null; cell = cell.getNextSibling()) {\n      if (!$isTableCellNode(cell)) {\n        throw Error(`Expected TableRowNode children to be TableCellNode`);\n      } // Skip past any columns that were merged from a higher row\n      const startMapRow = getMapRow(rowIdx);\n      while (startMapRow[colIdx] !== undefined) {\n        colIdx++;\n      }\n      const value = {\n        cell,\n        startColumn: colIdx,\n        startRow: rowIdx\n      };\n      const {\n        __rowSpan: rowSpan,\n        __colSpan: colSpan\n      } = cell;\n      for (let j = 0; j < rowSpan; j++) {\n        if (rowIdx + j >= gridChildren.length) {\n          // The table is non-rectangular with a rowSpan\n          // below the last <tr> in the table.\n          // We should probably handle this with a node transform\n          // to ensure that tables are always rectangular but this\n          // will avoid crashes such as #6584\n          // Note that there are probably still latent bugs\n          // regarding colSpan or general cell count mismatches.\n          break;\n        }\n        const mapRow = getMapRow(rowIdx + j);\n        for (let i = 0; i < colSpan; i++) {\n          mapRow[colIdx + i] = value;\n        }\n      }\n      if (cellA !== null && cellAValue === null && cellA.is(cell)) {\n        cellAValue = value;\n      }\n      if (cellB !== null && cellBValue === null && cellB.is(cell)) {\n        cellBValue = value;\n      }\n    }\n  }\n  return [tableMap, cellAValue, cellBValue];\n}\nfunction $getNodeTriplet(source) {\n  let cell;\n  if (source instanceof TableCellNode) {\n    cell = source;\n  } else if ('__type' in source) {\n    const cell_ = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(source, $isTableCellNode);\n    if (!$isTableCellNode(cell_)) {\n      throw Error(`Expected to find a parent TableCellNode`);\n    }\n    cell = cell_;\n  } else {\n    const cell_ = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(source.getNode(), $isTableCellNode);\n    if (!$isTableCellNode(cell_)) {\n      throw Error(`Expected to find a parent TableCellNode`);\n    }\n    cell = cell_;\n  }\n  const row = cell.getParent();\n  if (!$isTableRowNode(row)) {\n    throw Error(`Expected TableCellNode to have a parent TableRowNode`);\n  }\n  const grid = row.getParent();\n  if (!$isTableNode(grid)) {\n    throw Error(`Expected TableRowNode to have a parent TableNode`);\n  }\n  return [cell, row, grid];\n}\nfunction $getTableCellNodeRect(tableCellNode) {\n  const [cellNode,, gridNode] = $getNodeTriplet(tableCellNode);\n  const rows = gridNode.getChildren();\n  const rowCount = rows.length;\n  const columnCount = rows[0].getChildren().length;\n\n  // Create a matrix of the same size as the table to track the position of each cell\n  const cellMatrix = new Array(rowCount);\n  for (let i = 0; i < rowCount; i++) {\n    cellMatrix[i] = new Array(columnCount);\n  }\n  for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n    const row = rows[rowIndex];\n    const cells = row.getChildren();\n    let columnIndex = 0;\n    for (let cellIndex = 0; cellIndex < cells.length; cellIndex++) {\n      // Find the next available position in the matrix, skip the position of merged cells\n      while (cellMatrix[rowIndex][columnIndex]) {\n        columnIndex++;\n      }\n      const cell = cells[cellIndex];\n      const rowSpan = cell.__rowSpan || 1;\n      const colSpan = cell.__colSpan || 1;\n\n      // Put the cell into the corresponding position in the matrix\n      for (let i = 0; i < rowSpan; i++) {\n        for (let j = 0; j < colSpan; j++) {\n          cellMatrix[rowIndex + i][columnIndex + j] = cell;\n        }\n      }\n\n      // Return to the original index, row span and column span of the cell.\n      if (cellNode === cell) {\n        return {\n          colSpan,\n          columnIndex,\n          rowIndex,\n          rowSpan\n        };\n      }\n      columnIndex += colSpan;\n    }\n  }\n  return null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nclass TableSelection {\n  constructor(tableKey, anchor, focus) {\n    this.anchor = anchor;\n    this.focus = focus;\n    anchor._selection = this;\n    focus._selection = this;\n    this._cachedNodes = null;\n    this.dirty = false;\n    this.tableKey = tableKey;\n  }\n  getStartEndPoints() {\n    return [this.anchor, this.focus];\n  }\n\n  /**\n   * Returns whether the Selection is \"backwards\", meaning the focus\n   * logically precedes the anchor in the EditorState.\n   * @returns true if the Selection is backwards, false otherwise.\n   */\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n  is(selection) {\n    if (!$isTableSelection(selection)) {\n      return false;\n    }\n    return this.tableKey === selection.tableKey && this.anchor.is(selection.anchor) && this.focus.is(selection.focus);\n  }\n  set(tableKey, anchorCellKey, focusCellKey) {\n    this.dirty = true;\n    this.tableKey = tableKey;\n    this.anchor.key = anchorCellKey;\n    this.focus.key = focusCellKey;\n    this._cachedNodes = null;\n  }\n  clone() {\n    return new TableSelection(this.tableKey, this.anchor, this.focus);\n  }\n  isCollapsed() {\n    return false;\n  }\n  extract() {\n    return this.getNodes();\n  }\n  insertRawText(text) {\n    // Do nothing?\n  }\n  insertText() {\n    // Do nothing?\n  }\n\n  /**\n   * Returns whether the provided TextFormatType is present on the Selection.\n   * This will be true if any paragraph in table cells has the specified format.\n   *\n   * @param type the TextFormatType to check for.\n   * @returns true if the provided format is currently toggled on on the Selection, false otherwise.\n   */\n  hasFormat(type) {\n    let format = 0;\n    const cellNodes = this.getNodes().filter($isTableCellNode);\n    cellNodes.forEach(cellNode => {\n      const paragraph = cellNode.getFirstChild();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(paragraph)) {\n        format |= paragraph.getTextFormat();\n      }\n    });\n    const formatFlag = lexical__WEBPACK_IMPORTED_MODULE_0__.TEXT_TYPE_TO_FORMAT[type];\n    return (format & formatFlag) !== 0;\n  }\n  insertNodes(nodes) {\n    const focusNode = this.focus.getNode();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(focusNode)) {\n      throw Error(`Expected TableSelection focus to be an ElementNode`);\n    }\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeSelection__EXPERIMENTAL)(focusNode.select(0, focusNode.getChildrenSize()));\n    selection.insertNodes(nodes);\n  }\n\n  // TODO Deprecate this method. It's confusing when used with colspan|rowspan\n  getShape() {\n    const anchorCellNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(this.anchor.key);\n    if (!$isTableCellNode(anchorCellNode)) {\n      throw Error(`Expected TableSelection anchor to be (or a child of) TableCellNode`);\n    }\n    const anchorCellNodeRect = $getTableCellNodeRect(anchorCellNode);\n    if (!(anchorCellNodeRect !== null)) {\n      throw Error(`getCellRect: expected to find AnchorNode`);\n    }\n    const focusCellNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(this.focus.key);\n    if (!$isTableCellNode(focusCellNode)) {\n      throw Error(`Expected TableSelection focus to be (or a child of) TableCellNode`);\n    }\n    const focusCellNodeRect = $getTableCellNodeRect(focusCellNode);\n    if (!(focusCellNodeRect !== null)) {\n      throw Error(`getCellRect: expected to find focusCellNode`);\n    }\n    const startX = Math.min(anchorCellNodeRect.columnIndex, focusCellNodeRect.columnIndex);\n    const stopX = Math.max(anchorCellNodeRect.columnIndex + anchorCellNodeRect.colSpan - 1, focusCellNodeRect.columnIndex + focusCellNodeRect.colSpan - 1);\n    const startY = Math.min(anchorCellNodeRect.rowIndex, focusCellNodeRect.rowIndex);\n    const stopY = Math.max(anchorCellNodeRect.rowIndex + anchorCellNodeRect.rowSpan - 1, focusCellNodeRect.rowIndex + focusCellNodeRect.rowSpan - 1);\n    return {\n      fromX: Math.min(startX, stopX),\n      fromY: Math.min(startY, stopY),\n      toX: Math.max(startX, stopX),\n      toY: Math.max(startY, stopY)\n    };\n  }\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const anchorNode = this.anchor.getNode();\n    const focusNode = this.focus.getNode();\n    const anchorCell = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchorNode, $isTableCellNode);\n    // todo replace with triplet\n    const focusCell = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focusNode, $isTableCellNode);\n    if (!$isTableCellNode(anchorCell)) {\n      throw Error(`Expected TableSelection anchor to be (or a child of) TableCellNode`);\n    }\n    if (!$isTableCellNode(focusCell)) {\n      throw Error(`Expected TableSelection focus to be (or a child of) TableCellNode`);\n    }\n    const anchorRow = anchorCell.getParent();\n    if (!$isTableRowNode(anchorRow)) {\n      throw Error(`Expected anchorCell to have a parent TableRowNode`);\n    }\n    const tableNode = anchorRow.getParent();\n    if (!$isTableNode(tableNode)) {\n      throw Error(`Expected tableNode to have a parent TableNode`);\n    }\n    const focusCellGrid = focusCell.getParents()[1];\n    if (focusCellGrid !== tableNode) {\n      if (!tableNode.isParentOf(focusCell)) {\n        // focus is on higher Grid level than anchor\n        const gridParent = tableNode.getParent();\n        if (!(gridParent != null)) {\n          throw Error(`Expected gridParent to have a parent`);\n        }\n        this.set(this.tableKey, gridParent.getKey(), focusCell.getKey());\n      } else {\n        // anchor is on higher Grid level than focus\n        const focusCellParent = focusCellGrid.getParent();\n        if (!(focusCellParent != null)) {\n          throw Error(`Expected focusCellParent to have a parent`);\n        }\n        this.set(this.tableKey, focusCell.getKey(), focusCellParent.getKey());\n      }\n      return this.getNodes();\n    }\n\n    // TODO Mapping the whole Grid every time not efficient. We need to compute the entire state only\n    // once (on load) and iterate on it as updates occur. However, to do this we need to have the\n    // ability to store a state. Killing TableSelection and moving the logic to the plugin would make\n    // this possible.\n    const [map, cellAMap, cellBMap] = $computeTableMap(tableNode, anchorCell, focusCell);\n    let minColumn = Math.min(cellAMap.startColumn, cellBMap.startColumn);\n    let minRow = Math.min(cellAMap.startRow, cellBMap.startRow);\n    let maxColumn = Math.max(cellAMap.startColumn + cellAMap.cell.__colSpan - 1, cellBMap.startColumn + cellBMap.cell.__colSpan - 1);\n    let maxRow = Math.max(cellAMap.startRow + cellAMap.cell.__rowSpan - 1, cellBMap.startRow + cellBMap.cell.__rowSpan - 1);\n    let exploredMinColumn = minColumn;\n    let exploredMinRow = minRow;\n    let exploredMaxColumn = minColumn;\n    let exploredMaxRow = minRow;\n    function expandBoundary(mapValue) {\n      const {\n        cell,\n        startColumn: cellStartColumn,\n        startRow: cellStartRow\n      } = mapValue;\n      minColumn = Math.min(minColumn, cellStartColumn);\n      minRow = Math.min(minRow, cellStartRow);\n      maxColumn = Math.max(maxColumn, cellStartColumn + cell.__colSpan - 1);\n      maxRow = Math.max(maxRow, cellStartRow + cell.__rowSpan - 1);\n    }\n    while (minColumn < exploredMinColumn || minRow < exploredMinRow || maxColumn > exploredMaxColumn || maxRow > exploredMaxRow) {\n      if (minColumn < exploredMinColumn) {\n        // Expand on the left\n        const rowDiff = exploredMaxRow - exploredMinRow;\n        const previousColumn = exploredMinColumn - 1;\n        for (let i = 0; i <= rowDiff; i++) {\n          expandBoundary(map[exploredMinRow + i][previousColumn]);\n        }\n        exploredMinColumn = previousColumn;\n      }\n      if (minRow < exploredMinRow) {\n        // Expand on top\n        const columnDiff = exploredMaxColumn - exploredMinColumn;\n        const previousRow = exploredMinRow - 1;\n        for (let i = 0; i <= columnDiff; i++) {\n          expandBoundary(map[previousRow][exploredMinColumn + i]);\n        }\n        exploredMinRow = previousRow;\n      }\n      if (maxColumn > exploredMaxColumn) {\n        // Expand on the right\n        const rowDiff = exploredMaxRow - exploredMinRow;\n        const nextColumn = exploredMaxColumn + 1;\n        for (let i = 0; i <= rowDiff; i++) {\n          expandBoundary(map[exploredMinRow + i][nextColumn]);\n        }\n        exploredMaxColumn = nextColumn;\n      }\n      if (maxRow > exploredMaxRow) {\n        // Expand on the bottom\n        const columnDiff = exploredMaxColumn - exploredMinColumn;\n        const nextRow = exploredMaxRow + 1;\n        for (let i = 0; i <= columnDiff; i++) {\n          expandBoundary(map[nextRow][exploredMinColumn + i]);\n        }\n        exploredMaxRow = nextRow;\n      }\n    }\n\n    // We use a Map here because merged cells in the grid would otherwise\n    // show up multiple times in the nodes array\n    const nodeMap = new Map([[tableNode.getKey(), tableNode]]);\n    let lastRow = null;\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const {\n          cell\n        } = map[i][j];\n        const currentRow = cell.getParent();\n        if (!$isTableRowNode(currentRow)) {\n          throw Error(`Expected TableCellNode parent to be a TableRowNode`);\n        }\n        if (currentRow !== lastRow) {\n          nodeMap.set(currentRow.getKey(), currentRow);\n        }\n        nodeMap.set(cell.getKey(), cell);\n        for (const child of $getChildrenRecursively(cell)) {\n          nodeMap.set(child.getKey(), child);\n        }\n        lastRow = currentRow;\n      }\n    }\n    const nodes = Array.from(nodeMap.values());\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isCurrentlyReadOnlyMode)()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  getTextContent() {\n    const nodes = this.getNodes().filter(node => $isTableCellNode(node));\n    let textContent = '';\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      const row = node.__parent;\n      const nextRow = (nodes[i + 1] || {}).__parent;\n      textContent += node.getTextContent() + (nextRow !== row ? '\\n' : '\\t');\n    }\n    return textContent;\n  }\n}\nfunction $isTableSelection(x) {\n  return x instanceof TableSelection;\n}\nfunction $createTableSelection() {\n  const anchor = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createPoint)('root', 0, 'element');\n  const focus = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createPoint)('root', 0, 'element');\n  return new TableSelection('root', anchor, focus);\n}\nfunction $getChildrenRecursively(node) {\n  const nodes = [];\n  const stack = [node];\n  while (stack.length > 0) {\n    const currentNode = stack.pop();\n    if (!(currentNode !== undefined)) {\n      throw Error(`Stack.length > 0; can't be undefined`);\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode)) {\n      stack.unshift(...currentNode.getChildren());\n    }\n    if (currentNode !== node) {\n      nodes.push(currentNode);\n    }\n  }\n  return nodes;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nclass TableObserver {\n  constructor(editor, tableNodeKey) {\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.listenersToRemove = new Set();\n    this.tableNodeKey = tableNodeKey;\n    this.editor = editor;\n    this.table = {\n      columns: 0,\n      domRows: [],\n      rows: 0\n    };\n    this.tableSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.trackTable();\n    this.isSelecting = false;\n    this.abortController = new AbortController();\n    this.listenerOptions = {\n      signal: this.abortController.signal\n    };\n  }\n  getTable() {\n    return this.table;\n  }\n  removeListeners() {\n    this.abortController.abort('removeListeners');\n    Array.from(this.listenersToRemove).forEach(removeListener => removeListener());\n    this.listenersToRemove.clear();\n  }\n  trackTable() {\n    const observer = new MutationObserver(records => {\n      this.editor.update(() => {\n        let gridNeedsRedraw = false;\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const target = record.target;\n          const nodeName = target.nodeName;\n          if (nodeName === 'TABLE' || nodeName === 'TBODY' || nodeName === 'THEAD' || nodeName === 'TR') {\n            gridNeedsRedraw = true;\n            break;\n          }\n        }\n        if (!gridNeedsRedraw) {\n          return;\n        }\n        const tableElement = this.editor.getElementByKey(this.tableNodeKey);\n        if (!tableElement) {\n          throw new Error('Expected to find TableElement in DOM');\n        }\n        this.table = getTable(tableElement);\n      });\n    });\n    this.editor.update(() => {\n      const tableElement = this.editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      this.table = getTable(tableElement);\n      observer.observe(tableElement, {\n        attributes: true,\n        childList: true,\n        subtree: true\n      });\n    });\n  }\n  clearHighlight() {\n    const editor = this.editor;\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.tableSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.enableHighlightStyle();\n    editor.update(() => {\n      const tableNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(this.tableNodeKey);\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      const grid = getTable(tableElement);\n      $updateDOMForSelection(editor, grid, null);\n      (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(null);\n      editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n  enableHighlightStyle() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(tableElement, editor._config.theme.tableSelection);\n      tableElement.classList.remove('disable-selection');\n      this.hasHijackedSelectionStyles = false;\n    });\n  }\n  disableHighlightStyle() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(tableElement, editor._config.theme.tableSelection);\n      this.hasHijackedSelectionStyles = true;\n    });\n  }\n  updateTableTableSelection(selection) {\n    if (selection !== null && selection.tableKey === this.tableNodeKey) {\n      const editor = this.editor;\n      this.tableSelection = selection;\n      this.isHighlightingCells = true;\n      this.disableHighlightStyle();\n      $updateDOMForSelection(editor, this.table, this.tableSelection);\n    } else if (selection == null) {\n      this.clearHighlight();\n    } else {\n      this.tableNodeKey = selection.tableKey;\n      this.updateTableTableSelection(selection);\n    }\n  }\n  setFocusCellForSelection(cell, ignoreStart = false) {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(this.tableNodeKey);\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      const cellX = cell.x;\n      const cellY = cell.y;\n      this.focusCell = cell;\n      if (this.anchorCell !== null) {\n        const domSelection = getDOMSelection(editor._window);\n        // Collapse the selection\n        if (domSelection) {\n          domSelection.setBaseAndExtent(this.anchorCell.elem, 0, this.focusCell.elem, 0);\n        }\n      }\n      if (!this.isHighlightingCells && (this.anchorX !== cellX || this.anchorY !== cellY || ignoreStart)) {\n        this.isHighlightingCells = true;\n        this.disableHighlightStyle();\n      } else if (cellX === this.focusX && cellY === this.focusY) {\n        return;\n      }\n      this.focusX = cellX;\n      this.focusY = cellY;\n      if (this.isHighlightingCells) {\n        const focusTableCellNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(cell.elem);\n        if (this.tableSelection != null && this.anchorCellNodeKey != null && $isTableCellNode(focusTableCellNode) && tableNode.is($findTableNode(focusTableCellNode))) {\n          const focusNodeKey = focusTableCellNode.getKey();\n          this.tableSelection = this.tableSelection.clone() || $createTableSelection();\n          this.focusCellNodeKey = focusNodeKey;\n          this.tableSelection.set(this.tableNodeKey, this.anchorCellNodeKey, this.focusCellNodeKey);\n          (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(this.tableSelection);\n          editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, undefined);\n          $updateDOMForSelection(editor, this.table, this.tableSelection);\n        }\n      }\n    });\n  }\n  setAnchorCellForSelection(cell) {\n    this.isHighlightingCells = false;\n    this.anchorCell = cell;\n    this.anchorX = cell.x;\n    this.anchorY = cell.y;\n    this.editor.update(() => {\n      const anchorTableCellNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(cell.elem);\n      if ($isTableCellNode(anchorTableCellNode)) {\n        const anchorNodeKey = anchorTableCellNode.getKey();\n        this.tableSelection = this.tableSelection != null ? this.tableSelection.clone() : $createTableSelection();\n        this.anchorCellNodeKey = anchorNodeKey;\n      }\n    });\n  }\n  formatCells(type) {\n    this.editor.update(() => {\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      if (!$isTableSelection(selection)) {\n        {\n          throw Error(`Expected grid selection`);\n        }\n      }\n      const formatSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createRangeSelection)();\n      const anchor = formatSelection.anchor;\n      const focus = formatSelection.focus;\n      const cellNodes = selection.getNodes().filter($isTableCellNode);\n      const paragraph = cellNodes[0].getFirstChild();\n      const alignFormatWith = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(paragraph) ? paragraph.getFormatFlags(type, null) : null;\n      cellNodes.forEach(cellNode => {\n        anchor.set(cellNode.getKey(), 0, 'element');\n        focus.set(cellNode.getKey(), cellNode.getChildrenSize(), 'element');\n        formatSelection.formatText(type, alignFormatWith);\n      });\n      (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(selection);\n      this.editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n  clearText() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(this.tableNodeKey);\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      if (!$isTableSelection(selection)) {\n        {\n          throw Error(`Expected grid selection`);\n        }\n      }\n      const selectedNodes = selection.getNodes().filter($isTableCellNode);\n      if (selectedNodes.length === this.table.columns * this.table.rows) {\n        tableNode.selectPrevious();\n        // Delete entire table\n        tableNode.remove();\n        const rootNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n        rootNode.selectStart();\n        return;\n      }\n      selectedNodes.forEach(cellNode => {\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(cellNode)) {\n          const paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n          const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)();\n          paragraphNode.append(textNode);\n          cellNode.append(paragraphNode);\n          cellNode.getChildren().forEach(child => {\n            if (child !== paragraphNode) {\n              child.remove();\n            }\n          });\n        }\n      });\n      $updateDOMForSelection(editor, this.table, null);\n      (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(null);\n      editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst LEXICAL_ELEMENT_KEY = '__lexicalTableSelection';\nconst getDOMSelection = targetWindow => CAN_USE_DOM ? (targetWindow || window).getSelection() : null;\nconst isMouseDownOnEvent = event => {\n  return (event.buttons & 1) === 1;\n};\nfunction applyTableHandlers(tableNode, tableElement, editor, hasTabHandler) {\n  const rootElement = editor.getRootElement();\n  if (rootElement === null) {\n    throw new Error('No root element.');\n  }\n  const tableObserver = new TableObserver(editor, tableNode.getKey());\n  const editorWindow = editor._window || window;\n  attachTableObserverToTableElement(tableElement, tableObserver);\n  tableObserver.listenersToRemove.add(() => deatatchTableObserverFromTableElement(tableElement, tableObserver));\n  const createMouseHandlers = () => {\n    const onMouseUp = () => {\n      tableObserver.isSelecting = false;\n      editorWindow.removeEventListener('mouseup', onMouseUp);\n      editorWindow.removeEventListener('mousemove', onMouseMove);\n    };\n    const onMouseMove = moveEvent => {\n      // delaying mousemove handler to allow selectionchange handler from LexicalEvents.ts to be executed first\n      setTimeout(() => {\n        if (!isMouseDownOnEvent(moveEvent) && tableObserver.isSelecting) {\n          tableObserver.isSelecting = false;\n          editorWindow.removeEventListener('mouseup', onMouseUp);\n          editorWindow.removeEventListener('mousemove', onMouseMove);\n          return;\n        }\n        const focusCell = getDOMCellFromTarget(moveEvent.target);\n        if (focusCell !== null && (tableObserver.anchorX !== focusCell.x || tableObserver.anchorY !== focusCell.y)) {\n          moveEvent.preventDefault();\n          tableObserver.setFocusCellForSelection(focusCell);\n        }\n      }, 0);\n    };\n    return {\n      onMouseMove,\n      onMouseUp\n    };\n  };\n  const onMouseDown = event => {\n    setTimeout(() => {\n      if (event.button !== 0) {\n        return;\n      }\n      if (!editorWindow) {\n        return;\n      }\n      const anchorCell = getDOMCellFromTarget(event.target);\n      if (anchorCell !== null) {\n        stopEvent(event);\n        tableObserver.setAnchorCellForSelection(anchorCell);\n      }\n      const {\n        onMouseUp,\n        onMouseMove\n      } = createMouseHandlers();\n      tableObserver.isSelecting = true;\n      editorWindow.addEventListener('mouseup', onMouseUp, tableObserver.listenerOptions);\n      editorWindow.addEventListener('mousemove', onMouseMove, tableObserver.listenerOptions);\n    }, 0);\n  };\n  tableElement.addEventListener('mousedown', onMouseDown, tableObserver.listenerOptions);\n\n  // Clear selection when clicking outside of dom.\n  const mouseDownCallback = event => {\n    if (event.button !== 0) {\n      return;\n    }\n    editor.update(() => {\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      const target = event.target;\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey && rootElement.contains(target)) {\n        tableObserver.clearHighlight();\n      }\n    });\n  };\n  editorWindow.addEventListener('mousedown', mouseDownCallback, tableObserver.listenerOptions);\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_DOWN_COMMAND, event => $handleArrowKey(editor, event, 'down', tableNode, tableObserver), lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_UP_COMMAND, event => $handleArrowKey(editor, event, 'up', tableNode, tableObserver), lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_LEFT_COMMAND, event => $handleArrowKey(editor, event, 'backward', tableNode, tableObserver), lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_RIGHT_COMMAND, event => $handleArrowKey(editor, event, 'forward', tableNode, tableObserver), lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ESCAPE_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ($isTableSelection(selection)) {\n      const focusCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.focus.getNode(), $isTableCellNode);\n      if ($isTableCellNode(focusCellNode)) {\n        stopEvent(event);\n        focusCellNode.selectEnd();\n        return true;\n      }\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_HIGH));\n  const deleteTextHandler = command => () => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.clearText();\n      return true;\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const tableCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n      const anchorNode = selection.anchor.getNode();\n      const focusNode = selection.focus.getNode();\n      const isAnchorInside = tableNode.isParentOf(anchorNode);\n      const isFocusInside = tableNode.isParentOf(focusNode);\n      const selectionContainsPartialTable = isAnchorInside && !isFocusInside || isFocusInside && !isAnchorInside;\n      if (selectionContainsPartialTable) {\n        tableObserver.clearText();\n        return true;\n      }\n      const nearestElementNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(n));\n      const topLevelCellElementNode = nearestElementNode && (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(nearestElementNode, n => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(n) && $isTableCellNode(n.getParent()));\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(topLevelCellElementNode) || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(nearestElementNode)) {\n        return false;\n      }\n      if (command === lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_LINE_COMMAND && topLevelCellElementNode.getPreviousSibling() === null) {\n        // TODO: Fix Delete Line in Table Cells.\n        return true;\n      }\n    }\n    return false;\n  };\n  [lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_WORD_COMMAND, lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_LINE_COMMAND, lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_CHARACTER_COMMAND].forEach(command => {\n    tableObserver.listenersToRemove.add(editor.registerCommand(command, deleteTextHandler(command), lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  });\n  const $deleteCellHandler = event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!($isTableSelection(selection) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection))) {\n      return false;\n    }\n\n    // If the selection is inside the table but should remove the whole table\n    // we expand the selection so that both the anchor and focus are outside\n    // the table and the editor's command listener will handle the delete\n    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());\n    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());\n    if (isAnchorInside !== isFocusInside) {\n      const tablePoint = isAnchorInside ? 'anchor' : 'focus';\n      const outerPoint = isAnchorInside ? 'focus' : 'anchor';\n      // Preserve the outer point\n      const {\n        key,\n        offset,\n        type\n      } = selection[outerPoint];\n      // Expand the selection around the table\n      const newSelection = tableNode[selection[tablePoint].isBefore(selection[outerPoint]) ? 'selectPrevious' : 'selectNext']();\n      // Restore the outer point of the selection\n      newSelection[outerPoint].set(key, offset, type);\n      // Let the base implementation handle the rest\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      if (event) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n      tableObserver.clearText();\n      return true;\n    }\n    return false;\n  };\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_BACKSPACE_COMMAND, $deleteCellHandler, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_DELETE_COMMAND, $deleteCellHandler, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CUT_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (selection) {\n      if (!($isTableSelection(selection) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection))) {\n        return false;\n      }\n      // Copying to the clipboard is async so we must capture the data\n      // before we delete it\n      void (0,_lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__.copyToClipboard)(editor, (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.objectKlassEquals)(event, ClipboardEvent) ? event : null, (0,_lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__.$getClipboardDataFromSelection)(selection));\n      const intercepted = $deleteCellHandler(event);\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n        selection.removeText();\n        return true;\n      }\n      return intercepted;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.FORMAT_TEXT_COMMAND, payload => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.formatCells(payload);\n      return true;\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const tableCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.FORMAT_ELEMENT_COMMAND, formatType => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!$isTableSelection(selection) || !$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    if (!$isTableCellNode(anchorNode) || !$isTableCellNode(focusNode)) {\n      return false;\n    }\n    const [tableMap, anchorCell, focusCell] = $computeTableMap(tableNode, anchorNode, focusNode);\n    const maxRow = Math.max(anchorCell.startRow, focusCell.startRow);\n    const maxColumn = Math.max(anchorCell.startColumn, focusCell.startColumn);\n    const minRow = Math.min(anchorCell.startRow, focusCell.startRow);\n    const minColumn = Math.min(anchorCell.startColumn, focusCell.startColumn);\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const cell = tableMap[i][j].cell;\n        cell.setFormat(formatType);\n        const cellChildren = cell.getChildren();\n        for (let k = 0; k < cellChildren.length; k++) {\n          const child = cellChildren[k];\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(child) && !child.isInline()) {\n            child.setFormat(formatType);\n          }\n        }\n      }\n    }\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CONTROLLED_TEXT_INSERTION_COMMAND, payload => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.clearHighlight();\n      return false;\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const tableCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n      if (typeof payload === 'string') {\n        const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);\n        if (edgePosition) {\n          $insertParagraphAtTableEdge(edgePosition, tableNode, [(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(payload)]);\n          return true;\n        }\n      }\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  if (hasTabHandler) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_TAB_COMMAND, event => {\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\n        return false;\n      }\n      const tableCellNode = $findCellNode(selection.anchor.getNode());\n      if (tableCellNode === null) {\n        return false;\n      }\n      stopEvent(event);\n      const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableObserver.table);\n      selectTableNodeInDirection(tableObserver, tableNode, currentCords.x, currentCords.y, !event.shiftKey ? 'forward' : 'backward');\n      return true;\n    }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.FOCUS_COMMAND, payload => {\n    return tableNode.isSelected();\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_HIGH));\n  function getObserverCellFromCellNode(tableCellNode) {\n    const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableObserver.table);\n    return tableNode.getDOMCellFromCordsOrThrow(currentCords.x, currentCords.y, tableObserver.table);\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, selectionPayload => {\n    const {\n      nodes,\n      selection\n    } = selectionPayload;\n    const anchorAndFocus = selection.getStartEndPoints();\n    const isTableSelection = $isTableSelection(selection);\n    const isRangeSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection);\n    const isSelectionInsideOfGrid = isRangeSelection && (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => $isTableCellNode(n)) !== null && (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.focus.getNode(), n => $isTableCellNode(n)) !== null || isTableSelection;\n    if (nodes.length !== 1 || !$isTableNode(nodes[0]) || !isSelectionInsideOfGrid || anchorAndFocus === null) {\n      return false;\n    }\n    const [anchor] = anchorAndFocus;\n    const newGrid = nodes[0];\n    const newGridRows = newGrid.getChildren();\n    const newColumnCount = newGrid.getFirstChildOrThrow().getChildrenSize();\n    const newRowCount = newGrid.getChildrenSize();\n    const gridCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchor.getNode(), n => $isTableCellNode(n));\n    const gridRowNode = gridCellNode && (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(gridCellNode, n => $isTableRowNode(n));\n    const gridNode = gridRowNode && (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(gridRowNode, n => $isTableNode(n));\n    if (!$isTableCellNode(gridCellNode) || !$isTableRowNode(gridRowNode) || !$isTableNode(gridNode)) {\n      return false;\n    }\n    const startY = gridRowNode.getIndexWithinParent();\n    const stopY = Math.min(gridNode.getChildrenSize() - 1, startY + newRowCount - 1);\n    const startX = gridCellNode.getIndexWithinParent();\n    const stopX = Math.min(gridRowNode.getChildrenSize() - 1, startX + newColumnCount - 1);\n    const fromX = Math.min(startX, stopX);\n    const fromY = Math.min(startY, stopY);\n    const toX = Math.max(startX, stopX);\n    const toY = Math.max(startY, stopY);\n    const gridRowNodes = gridNode.getChildren();\n    let newRowIdx = 0;\n    for (let r = fromY; r <= toY; r++) {\n      const currentGridRowNode = gridRowNodes[r];\n      if (!$isTableRowNode(currentGridRowNode)) {\n        return false;\n      }\n      const newGridRowNode = newGridRows[newRowIdx];\n      if (!$isTableRowNode(newGridRowNode)) {\n        return false;\n      }\n      const gridCellNodes = currentGridRowNode.getChildren();\n      const newGridCellNodes = newGridRowNode.getChildren();\n      let newColumnIdx = 0;\n      for (let c = fromX; c <= toX; c++) {\n        const currentGridCellNode = gridCellNodes[c];\n        if (!$isTableCellNode(currentGridCellNode)) {\n          return false;\n        }\n        const newGridCellNode = newGridCellNodes[newColumnIdx];\n        if (!$isTableCellNode(newGridCellNode)) {\n          return false;\n        }\n        const originalChildren = currentGridCellNode.getChildren();\n        newGridCellNode.getChildren().forEach(child => {\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(child)) {\n            const paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n            paragraphNode.append(child);\n            currentGridCellNode.append(child);\n          } else {\n            currentGridCellNode.append(child);\n          }\n        });\n        originalChildren.forEach(n => n.remove());\n        newColumnIdx++;\n      }\n      newRowIdx++;\n    }\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, () => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    const prevSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const {\n        anchor,\n        focus\n      } = selection;\n      const anchorNode = anchor.getNode();\n      const focusNode = focus.getNode();\n      // Using explicit comparison with table node to ensure it's not a nested table\n      // as in that case we'll leave selection resolving to that table\n      const anchorCellNode = $findCellNode(anchorNode);\n      const focusCellNode = $findCellNode(focusNode);\n      const isAnchorInside = !!(anchorCellNode && tableNode.is($findTableNode(anchorCellNode)));\n      const isFocusInside = !!(focusCellNode && tableNode.is($findTableNode(focusCellNode)));\n      const isPartialyWithinTable = isAnchorInside !== isFocusInside;\n      const isWithinTable = isAnchorInside && isFocusInside;\n      const isBackward = selection.isBackward();\n      if (isPartialyWithinTable) {\n        const newSelection = selection.clone();\n        if (isFocusInside) {\n          const [tableMap] = $computeTableMap(tableNode, focusCellNode, focusCellNode);\n          const firstCell = tableMap[0][0].cell;\n          const lastCell = tableMap[tableMap.length - 1].at(-1).cell;\n          newSelection.focus.set(isBackward ? firstCell.getKey() : lastCell.getKey(), isBackward ? firstCell.getChildrenSize() : lastCell.getChildrenSize(), 'element');\n        } else if (isAnchorInside) {\n          const [tableMap] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n          const firstCell = tableMap[0][0].cell;\n          const lastCell = tableMap[tableMap.length - 1].at(-1).cell;\n          /**\n           * If isBackward, set the anchor to be at the end of the table so that when the cursor moves outside of\n           * the table in the backward direction, the entire table will be selected from its end.\n           * Otherwise, if forward, set the anchor to be at the start of the table so that when the focus is dragged\n           * outside th end of the table, it will start from the beginning of the table.\n           */\n          newSelection.anchor.set(isBackward ? lastCell.getKey() : firstCell.getKey(), isBackward ? lastCell.getChildrenSize() : 0, 'element');\n        }\n        (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(newSelection);\n        $addHighlightStyleToTable(editor, tableObserver);\n      } else if (isWithinTable) {\n        // Handle case when selection spans across multiple cells but still\n        // has range selection, then we convert it into grid selection\n        if (!anchorCellNode.is(focusCellNode)) {\n          tableObserver.setAnchorCellForSelection(getObserverCellFromCellNode(anchorCellNode));\n          tableObserver.setFocusCellForSelection(getObserverCellFromCellNode(focusCellNode), true);\n          if (!tableObserver.isSelecting) {\n            setTimeout(() => {\n              const {\n                onMouseUp,\n                onMouseMove\n              } = createMouseHandlers();\n              tableObserver.isSelecting = true;\n              editorWindow.addEventListener('mouseup', onMouseUp);\n              editorWindow.addEventListener('mousemove', onMouseMove);\n            }, 0);\n          }\n        }\n      }\n    } else if (selection && $isTableSelection(selection) && selection.is(prevSelection) && selection.tableKey === tableNode.getKey()) {\n      // if selection goes outside of the table we need to change it to Range selection\n      const domSelection = getDOMSelection(editor._window);\n      if (domSelection && domSelection.anchorNode && domSelection.focusNode) {\n        const focusNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(domSelection.focusNode);\n        const isFocusOutside = focusNode && !tableNode.is($findTableNode(focusNode));\n        const anchorNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(domSelection.anchorNode);\n        const isAnchorInside = anchorNode && tableNode.is($findTableNode(anchorNode));\n        if (isFocusOutside && isAnchorInside && domSelection.rangeCount > 0) {\n          const newSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createRangeSelectionFromDom)(domSelection, editor);\n          if (newSelection) {\n            newSelection.anchor.set(tableNode.getKey(), selection.isBackward() ? tableNode.getChildrenSize() : 0, 'element');\n            domSelection.removeAllRanges();\n            (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(newSelection);\n          }\n        }\n      }\n    }\n    if (selection && !selection.is(prevSelection) && ($isTableSelection(selection) || $isTableSelection(prevSelection)) && tableObserver.tableSelection && !tableObserver.tableSelection.is(prevSelection)) {\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey) {\n        tableObserver.updateTableTableSelection(selection);\n      } else if (!$isTableSelection(selection) && $isTableSelection(prevSelection) && prevSelection.tableKey === tableObserver.tableNodeKey) {\n        tableObserver.updateTableTableSelection(null);\n      }\n      return false;\n    }\n    if (tableObserver.hasHijackedSelectionStyles && !tableNode.isSelected()) {\n      $removeHighlightStyleToTable(editor, tableObserver);\n    } else if (!tableObserver.hasHijackedSelectionStyles && tableNode.isSelected()) {\n      $addHighlightStyleToTable(editor, tableObserver);\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);\n    if (edgePosition) {\n      $insertParagraphAtTableEdge(edgePosition, tableNode);\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  return tableObserver;\n}\nfunction deatatchTableObserverFromTableElement(tableElement, tableObserver) {\n  if (getTableObserverFromTableElement(tableElement) === tableObserver) {\n    delete tableElement[LEXICAL_ELEMENT_KEY];\n  }\n}\nfunction attachTableObserverToTableElement(tableElement, tableObserver) {\n  if (!(getTableObserverFromTableElement(tableElement) === null)) {\n    throw Error(`tableElement already has an attached TableObserver`);\n  }\n  tableElement[LEXICAL_ELEMENT_KEY] = tableObserver;\n}\nfunction getTableObserverFromTableElement(tableElement) {\n  return tableElement[LEXICAL_ELEMENT_KEY] || null;\n}\nfunction getDOMCellFromTarget(node) {\n  let currentNode = node;\n  while (currentNode != null) {\n    const nodeName = currentNode.nodeName;\n    if (nodeName === 'TD' || nodeName === 'TH') {\n      // @ts-expect-error: internal field\n      const cell = currentNode._cell;\n      if (cell === undefined) {\n        return null;\n      }\n      return cell;\n    }\n    currentNode = currentNode.parentNode;\n  }\n  return null;\n}\nfunction getTable(tableElement) {\n  const domRows = [];\n  const grid = {\n    columns: 0,\n    domRows,\n    rows: 0\n  };\n  let currentNode = tableElement.querySelector('tr');\n  let x = 0;\n  let y = 0;\n  domRows.length = 0;\n  while (currentNode != null) {\n    const nodeMame = currentNode.nodeName;\n    if (nodeMame === 'TD' || nodeMame === 'TH') {\n      const elem = currentNode;\n      const cell = {\n        elem,\n        hasBackgroundColor: elem.style.backgroundColor !== '',\n        highlighted: false,\n        x,\n        y\n      };\n\n      // @ts-expect-error: internal field\n      currentNode._cell = cell;\n      let row = domRows[y];\n      if (row === undefined) {\n        row = domRows[y] = [];\n      }\n      row[x] = cell;\n    } else {\n      const child = currentNode.firstChild;\n      if (child != null) {\n        currentNode = child;\n        continue;\n      }\n    }\n    const sibling = currentNode.nextSibling;\n    if (sibling != null) {\n      x++;\n      currentNode = sibling;\n      continue;\n    }\n    const parent = currentNode.parentNode;\n    if (parent != null) {\n      const parentSibling = parent.nextSibling;\n      if (parentSibling == null) {\n        break;\n      }\n      y++;\n      x = 0;\n      currentNode = parentSibling;\n    }\n  }\n  grid.columns = x + 1;\n  grid.rows = y + 1;\n  return grid;\n}\nfunction $updateDOMForSelection(editor, table, selection) {\n  const selectedCellNodes = new Set(selection ? selection.getNodes() : []);\n  $forEachTableCell(table, (cell, lexicalNode) => {\n    const elem = cell.elem;\n    if (selectedCellNodes.has(lexicalNode)) {\n      cell.highlighted = true;\n      $addHighlightToDOM(editor, cell);\n    } else {\n      cell.highlighted = false;\n      $removeHighlightFromDOM(editor, cell);\n      if (!elem.getAttribute('style')) {\n        elem.removeAttribute('style');\n      }\n    }\n  });\n}\nfunction $forEachTableCell(grid, cb) {\n  const {\n    domRows\n  } = grid;\n  for (let y = 0; y < domRows.length; y++) {\n    const row = domRows[y];\n    if (!row) {\n      continue;\n    }\n    for (let x = 0; x < row.length; x++) {\n      const cell = row[x];\n      if (!cell) {\n        continue;\n      }\n      const lexicalNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(cell.elem);\n      if (lexicalNode !== null) {\n        cb(cell, lexicalNode, {\n          x,\n          y\n        });\n      }\n    }\n  }\n}\nfunction $addHighlightStyleToTable(editor, tableSelection) {\n  tableSelection.disableHighlightStyle();\n  $forEachTableCell(tableSelection.table, cell => {\n    cell.highlighted = true;\n    $addHighlightToDOM(editor, cell);\n  });\n}\nfunction $removeHighlightStyleToTable(editor, tableObserver) {\n  tableObserver.enableHighlightStyle();\n  $forEachTableCell(tableObserver.table, cell => {\n    const elem = cell.elem;\n    cell.highlighted = false;\n    $removeHighlightFromDOM(editor, cell);\n    if (!elem.getAttribute('style')) {\n      elem.removeAttribute('style');\n    }\n  });\n}\nconst selectTableNodeInDirection = (tableObserver, tableNode, x, y, direction) => {\n  const isForward = direction === 'forward';\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      if (x !== (isForward ? tableObserver.table.columns - 1 : 0)) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableObserver.table), isForward);\n      } else {\n        if (y !== (isForward ? tableObserver.table.rows - 1 : 0)) {\n          selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(isForward ? 0 : tableObserver.table.columns - 1, y + (isForward ? 1 : -1), tableObserver.table), isForward);\n        } else if (!isForward) {\n          tableNode.selectPrevious();\n        } else {\n          tableNode.selectNext();\n        }\n      }\n      return true;\n    case 'up':\n      if (y !== 0) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y - 1, tableObserver.table), false);\n      } else {\n        tableNode.selectPrevious();\n      }\n      return true;\n    case 'down':\n      if (y !== tableObserver.table.rows - 1) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y + 1, tableObserver.table), true);\n      } else {\n        tableNode.selectNext();\n      }\n      return true;\n    default:\n      return false;\n  }\n};\nconst adjustFocusNodeInDirection = (tableObserver, tableNode, x, y, direction) => {\n  const isForward = direction === 'forward';\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      if (x !== (isForward ? tableObserver.table.columns - 1 : 0)) {\n        tableObserver.setFocusCellForSelection(tableNode.getDOMCellFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableObserver.table));\n      }\n      return true;\n    case 'up':\n      if (y !== 0) {\n        tableObserver.setFocusCellForSelection(tableNode.getDOMCellFromCordsOrThrow(x, y - 1, tableObserver.table));\n        return true;\n      } else {\n        return false;\n      }\n    case 'down':\n      if (y !== tableObserver.table.rows - 1) {\n        tableObserver.setFocusCellForSelection(tableNode.getDOMCellFromCordsOrThrow(x, y + 1, tableObserver.table));\n        return true;\n      } else {\n        return false;\n      }\n    default:\n      return false;\n  }\n};\nfunction $isSelectionInTable(selection, tableNode) {\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection)) {\n    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());\n    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());\n    return isAnchorInside && isFocusInside;\n  }\n  return false;\n}\nfunction selectTableCellNode(tableCell, fromStart) {\n  if (fromStart) {\n    tableCell.selectStart();\n  } else {\n    tableCell.selectEnd();\n  }\n}\nconst BROWSER_BLUE_RGB = '172,206,247';\nfunction $addHighlightToDOM(editor, cell) {\n  const element = cell.elem;\n  const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(element);\n  if (!$isTableCellNode(node)) {\n    throw Error(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n  const backgroundColor = node.getBackgroundColor();\n  if (backgroundColor === null) {\n    element.style.setProperty('background-color', `rgb(${BROWSER_BLUE_RGB})`);\n  } else {\n    element.style.setProperty('background-image', `linear-gradient(to right, rgba(${BROWSER_BLUE_RGB},0.85), rgba(${BROWSER_BLUE_RGB},0.85))`);\n  }\n  element.style.setProperty('caret-color', 'transparent');\n}\nfunction $removeHighlightFromDOM(editor, cell) {\n  const element = cell.elem;\n  const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(element);\n  if (!$isTableCellNode(node)) {\n    throw Error(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n  const backgroundColor = node.getBackgroundColor();\n  if (backgroundColor === null) {\n    element.style.removeProperty('background-color');\n  }\n  element.style.removeProperty('background-image');\n  element.style.removeProperty('caret-color');\n}\nfunction $findCellNode(node) {\n  const cellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(node, $isTableCellNode);\n  return $isTableCellNode(cellNode) ? cellNode : null;\n}\nfunction $findTableNode(node) {\n  const tableNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(node, $isTableNode);\n  return $isTableNode(tableNode) ? tableNode : null;\n}\nfunction $handleArrowKey(editor, event, direction, tableNode, tableObserver) {\n  if ((direction === 'up' || direction === 'down') && isTypeaheadMenuInView(editor)) {\n    return false;\n  }\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!$isSelectionInTable(selection, tableNode)) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      if (selection.isCollapsed() && direction === 'backward') {\n        const anchorType = selection.anchor.type;\n        const anchorOffset = selection.anchor.offset;\n        if (anchorType !== 'element' && !(anchorType === 'text' && anchorOffset === 0)) {\n          return false;\n        }\n        const anchorNode = selection.anchor.getNode();\n        if (!anchorNode) {\n          return false;\n        }\n        const parentNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchorNode, n => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(n) && !n.isInline());\n        if (!parentNode) {\n          return false;\n        }\n        const siblingNode = parentNode.getPreviousSibling();\n        if (!siblingNode || !$isTableNode(siblingNode)) {\n          return false;\n        }\n        stopEvent(event);\n        siblingNode.selectEnd();\n        return true;\n      } else if (event.shiftKey && (direction === 'up' || direction === 'down')) {\n        const focusNode = selection.focus.getNode();\n        const isTableUnselect = !selection.isCollapsed() && (direction === 'up' && !selection.isBackward() || direction === 'down' && selection.isBackward());\n        if (isTableUnselect) {\n          let focusParentNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focusNode, n => $isTableNode(n));\n          if ($isTableCellNode(focusParentNode)) {\n            focusParentNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focusParentNode, $isTableNode);\n          }\n          if (focusParentNode !== tableNode) {\n            return false;\n          }\n          if (!focusParentNode) {\n            return false;\n          }\n          const sibling = direction === 'down' ? focusParentNode.getNextSibling() : focusParentNode.getPreviousSibling();\n          if (!sibling) {\n            return false;\n          }\n          let newOffset = 0;\n          if (direction === 'up') {\n            if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(sibling)) {\n              newOffset = sibling.getChildrenSize();\n            }\n          }\n          let newFocusNode = sibling;\n          if (direction === 'up') {\n            if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(sibling)) {\n              const lastCell = sibling.getLastChild();\n              newFocusNode = lastCell ? lastCell : sibling;\n              newOffset = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(newFocusNode) ? newFocusNode.getTextContentSize() : 0;\n            }\n          }\n          const newSelection = selection.clone();\n          newSelection.focus.set(newFocusNode.getKey(), newOffset, (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(newFocusNode) ? 'text' : 'element');\n          (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(newSelection);\n          stopEvent(event);\n          return true;\n        } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(focusNode)) {\n          const selectedNode = direction === 'up' ? selection.getNodes()[selection.getNodes().length - 1] : selection.getNodes()[0];\n          if (selectedNode) {\n            const tableCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selectedNode, $isTableCellNode);\n            if (tableCellNode && tableNode.isParentOf(tableCellNode)) {\n              const firstDescendant = tableNode.getFirstDescendant();\n              const lastDescendant = tableNode.getLastDescendant();\n              if (!firstDescendant || !lastDescendant) {\n                return false;\n              }\n              const [firstCellNode] = $getNodeTriplet(firstDescendant);\n              const [lastCellNode] = $getNodeTriplet(lastDescendant);\n              const firstCellCoords = tableNode.getCordsFromCellNode(firstCellNode, tableObserver.table);\n              const lastCellCoords = tableNode.getCordsFromCellNode(lastCellNode, tableObserver.table);\n              const firstCellDOM = tableNode.getDOMCellFromCordsOrThrow(firstCellCoords.x, firstCellCoords.y, tableObserver.table);\n              const lastCellDOM = tableNode.getDOMCellFromCordsOrThrow(lastCellCoords.x, lastCellCoords.y, tableObserver.table);\n              tableObserver.setAnchorCellForSelection(firstCellDOM);\n              tableObserver.setFocusCellForSelection(lastCellDOM, true);\n              return true;\n            }\n          }\n          return false;\n        } else {\n          let focusParentNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focusNode, n => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(n) && !n.isInline());\n          if ($isTableCellNode(focusParentNode)) {\n            focusParentNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focusParentNode, $isTableNode);\n          }\n          if (!focusParentNode) {\n            return false;\n          }\n          const sibling = direction === 'down' ? focusParentNode.getNextSibling() : focusParentNode.getPreviousSibling();\n          if ($isTableNode(sibling) && tableObserver.tableNodeKey === sibling.getKey()) {\n            const firstDescendant = sibling.getFirstDescendant();\n            const lastDescendant = sibling.getLastDescendant();\n            if (!firstDescendant || !lastDescendant) {\n              return false;\n            }\n            const [firstCellNode] = $getNodeTriplet(firstDescendant);\n            const [lastCellNode] = $getNodeTriplet(lastDescendant);\n            const newSelection = selection.clone();\n            newSelection.focus.set((direction === 'up' ? firstCellNode : lastCellNode).getKey(), direction === 'up' ? 0 : lastCellNode.getChildrenSize(), 'element');\n            stopEvent(event);\n            (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(newSelection);\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed()) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    const anchorCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchor.getNode(), $isTableCellNode);\n    const focusCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focus.getNode(), $isTableCellNode);\n    if (!$isTableCellNode(anchorCellNode) || !anchorCellNode.is(focusCellNode)) {\n      return false;\n    }\n    const anchorCellTable = $findTableNode(anchorCellNode);\n    if (anchorCellTable !== tableNode && anchorCellTable != null) {\n      const anchorCellTableElement = editor.getElementByKey(anchorCellTable.getKey());\n      if (anchorCellTableElement != null) {\n        tableObserver.table = getTable(anchorCellTableElement);\n        return $handleArrowKey(editor, event, direction, anchorCellTable, tableObserver);\n      }\n    }\n    if (direction === 'backward' || direction === 'forward') {\n      const anchorType = anchor.type;\n      const anchorOffset = anchor.offset;\n      const anchorNode = anchor.getNode();\n      if (!anchorNode) {\n        return false;\n      }\n      const selectedNodes = selection.getNodes();\n      if (selectedNodes.length === 1 && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(selectedNodes[0])) {\n        return false;\n      }\n      if (isExitingTableAnchor(anchorType, anchorOffset, anchorNode, direction)) {\n        return $handleTableExit(event, anchorNode, tableNode, direction);\n      }\n      return false;\n    }\n    const anchorCellDom = editor.getElementByKey(anchorCellNode.__key);\n    const anchorDOM = editor.getElementByKey(anchor.key);\n    if (anchorDOM == null || anchorCellDom == null) {\n      return false;\n    }\n    let edgeSelectionRect;\n    if (anchor.type === 'element') {\n      edgeSelectionRect = anchorDOM.getBoundingClientRect();\n    } else {\n      const domSelection = window.getSelection();\n      if (domSelection === null || domSelection.rangeCount === 0) {\n        return false;\n      }\n      const range = domSelection.getRangeAt(0);\n      edgeSelectionRect = range.getBoundingClientRect();\n    }\n    const edgeChild = direction === 'up' ? anchorCellNode.getFirstChild() : anchorCellNode.getLastChild();\n    if (edgeChild == null) {\n      return false;\n    }\n    const edgeChildDOM = editor.getElementByKey(edgeChild.__key);\n    if (edgeChildDOM == null) {\n      return false;\n    }\n    const edgeRect = edgeChildDOM.getBoundingClientRect();\n    const isExiting = direction === 'up' ? edgeRect.top > edgeSelectionRect.top - edgeSelectionRect.height : edgeSelectionRect.bottom + edgeSelectionRect.height > edgeRect.bottom;\n    if (isExiting) {\n      stopEvent(event);\n      const cords = tableNode.getCordsFromCellNode(anchorCellNode, tableObserver.table);\n      if (event.shiftKey) {\n        const cell = tableNode.getDOMCellFromCordsOrThrow(cords.x, cords.y, tableObserver.table);\n        tableObserver.setAnchorCellForSelection(cell);\n        tableObserver.setFocusCellForSelection(cell, true);\n      } else {\n        return selectTableNodeInDirection(tableObserver, tableNode, cords.x, cords.y, direction);\n      }\n      return true;\n    }\n  } else if ($isTableSelection(selection)) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    const anchorCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchor.getNode(), $isTableCellNode);\n    const focusCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focus.getNode(), $isTableCellNode);\n    const [tableNodeFromSelection] = selection.getNodes();\n    const tableElement = editor.getElementByKey(tableNodeFromSelection.getKey());\n    if (!$isTableCellNode(anchorCellNode) || !$isTableCellNode(focusCellNode) || !$isTableNode(tableNodeFromSelection) || tableElement == null) {\n      return false;\n    }\n    tableObserver.updateTableTableSelection(selection);\n    const grid = getTable(tableElement);\n    const cordsAnchor = tableNode.getCordsFromCellNode(anchorCellNode, grid);\n    const anchorCell = tableNode.getDOMCellFromCordsOrThrow(cordsAnchor.x, cordsAnchor.y, grid);\n    tableObserver.setAnchorCellForSelection(anchorCell);\n    stopEvent(event);\n    if (event.shiftKey) {\n      const cords = tableNode.getCordsFromCellNode(focusCellNode, grid);\n      return adjustFocusNodeInDirection(tableObserver, tableNodeFromSelection, cords.x, cords.y, direction);\n    } else {\n      focusCellNode.selectEnd();\n    }\n    return true;\n  }\n  return false;\n}\nfunction stopEvent(event) {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n  event.stopPropagation();\n}\nfunction isTypeaheadMenuInView(editor) {\n  // There is no inbuilt way to check if the component picker is in view\n  // but we can check if the root DOM element has the aria-controls attribute \"typeahead-menu\".\n  const root = editor.getRootElement();\n  if (!root) {\n    return false;\n  }\n  return root.hasAttribute('aria-controls') && root.getAttribute('aria-controls') === 'typeahead-menu';\n}\nfunction isExitingTableAnchor(type, offset, anchorNode, direction) {\n  return isExitingTableElementAnchor(type, anchorNode, direction) || $isExitingTableTextAnchor(type, offset, anchorNode, direction);\n}\nfunction isExitingTableElementAnchor(type, anchorNode, direction) {\n  return type === 'element' && (direction === 'backward' ? anchorNode.getPreviousSibling() === null : anchorNode.getNextSibling() === null);\n}\nfunction $isExitingTableTextAnchor(type, offset, anchorNode, direction) {\n  const parentNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchorNode, n => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(n) && !n.isInline());\n  if (!parentNode) {\n    return false;\n  }\n  const hasValidOffset = direction === 'backward' ? offset === 0 : offset === anchorNode.getTextContentSize();\n  return type === 'text' && hasValidOffset && (direction === 'backward' ? parentNode.getPreviousSibling() === null : parentNode.getNextSibling() === null);\n}\nfunction $handleTableExit(event, anchorNode, tableNode, direction) {\n  const anchorCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchorNode, $isTableCellNode);\n  if (!$isTableCellNode(anchorCellNode)) {\n    return false;\n  }\n  const [tableMap, cellValue] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n  if (!isExitingCell(tableMap, cellValue, direction)) {\n    return false;\n  }\n  const toNode = $getExitingToNode(anchorNode, direction, tableNode);\n  if (!toNode || $isTableNode(toNode)) {\n    return false;\n  }\n  stopEvent(event);\n  if (direction === 'backward') {\n    toNode.selectEnd();\n  } else {\n    toNode.selectStart();\n  }\n  return true;\n}\nfunction isExitingCell(tableMap, cellValue, direction) {\n  const firstCell = tableMap[0][0];\n  const lastCell = tableMap[tableMap.length - 1][tableMap[0].length - 1];\n  const {\n    startColumn,\n    startRow\n  } = cellValue;\n  return direction === 'backward' ? startColumn === firstCell.startColumn && startRow === firstCell.startRow : startColumn === lastCell.startColumn && startRow === lastCell.startRow;\n}\nfunction $getExitingToNode(anchorNode, direction, tableNode) {\n  const parentNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchorNode, n => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(n) && !n.isInline());\n  if (!parentNode) {\n    return undefined;\n  }\n  const anchorSibling = direction === 'backward' ? parentNode.getPreviousSibling() : parentNode.getNextSibling();\n  return anchorSibling && $isTableNode(anchorSibling) ? anchorSibling : direction === 'backward' ? tableNode.getPreviousSibling() : tableNode.getNextSibling();\n}\nfunction $insertParagraphAtTableEdge(edgePosition, tableNode, children) {\n  const paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n  if (edgePosition === 'first') {\n    tableNode.insertBefore(paragraphNode);\n  } else {\n    tableNode.insertAfter(paragraphNode);\n  }\n  paragraphNode.append(...(children || []));\n  paragraphNode.selectEnd();\n}\nfunction $getTableEdgeCursorPosition(editor, selection, tableNode) {\n  const tableNodeParent = tableNode.getParent();\n  if (!tableNodeParent) {\n    return undefined;\n  }\n  const tableNodeParentDOM = editor.getElementByKey(tableNodeParent.getKey());\n  if (!tableNodeParentDOM) {\n    return undefined;\n  }\n\n  // TODO: Add support for nested tables\n  const domSelection = window.getSelection();\n  if (!domSelection || domSelection.anchorNode !== tableNodeParentDOM) {\n    return undefined;\n  }\n  const anchorCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => $isTableCellNode(n));\n  if (!anchorCellNode) {\n    return undefined;\n  }\n  const parentTable = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchorCellNode, n => $isTableNode(n));\n  if (!$isTableNode(parentTable) || !parentTable.is(tableNode)) {\n    return undefined;\n  }\n  const [tableMap, cellValue] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n  const firstCell = tableMap[0][0];\n  const lastCell = tableMap[tableMap.length - 1][tableMap[0].length - 1];\n  const {\n    startRow,\n    startColumn\n  } = cellValue;\n  const isAtFirstCell = startRow === firstCell.startRow && startColumn === firstCell.startColumn;\n  const isAtLastCell = startRow === lastCell.startRow && startColumn === lastCell.startColumn;\n  if (isAtFirstCell) {\n    return 'first';\n  } else if (isAtLastCell) {\n    return 'last';\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction updateColgroup(dom, config, colCount, colWidths) {\n  const colGroup = dom.querySelector('colgroup');\n  if (!colGroup) {\n    return;\n  }\n  const cols = [];\n  for (let i = 0; i < colCount; i++) {\n    const col = document.createElement('col');\n    const width = colWidths && colWidths[i];\n    if (width) {\n      col.style.width = `${width}px`;\n    }\n    cols.push(col);\n  }\n  colGroup.replaceChildren(...cols);\n}\nfunction setRowStriping(dom, config, rowStriping) {\n  if (rowStriping) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(dom, config.theme.tableRowStriping);\n    dom.setAttribute('data-lexical-row-striping', 'true');\n  } else {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(dom, config.theme.tableRowStriping);\n    dom.removeAttribute('data-lexical-row-striping');\n  }\n}\n\n/** @noInheritDoc */\nclass TableNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'table';\n  }\n  getColWidths() {\n    const self = this.getLatest();\n    return self.__colWidths;\n  }\n  setColWidths(colWidths) {\n    const self = this.getWritable();\n    // NOTE: Node properties should be immutable. Freeze to prevent accidental mutation.\n    self.__colWidths = Object.freeze(colWidths) ;\n    return self;\n  }\n  static clone(node) {\n    return new TableNode(node.__key);\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__colWidths = prevNode.__colWidths;\n    this.__rowStriping = prevNode.__rowStriping;\n  }\n  static importDOM() {\n    return {\n      table: _node => ({\n        conversion: $convertTableElement,\n        priority: 1\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const tableNode = $createTableNode();\n    tableNode.__rowStriping = serializedNode.rowStriping || false;\n    tableNode.__colWidths = serializedNode.colWidths;\n    return tableNode;\n  }\n  constructor(key) {\n    super(key);\n    this.__rowStriping = false;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      colWidths: this.getColWidths(),\n      rowStriping: this.__rowStriping ? this.__rowStriping : undefined,\n      type: 'table',\n      version: 1\n    };\n  }\n  createDOM(config, editor) {\n    const tableElement = document.createElement('table');\n    const colGroup = document.createElement('colgroup');\n    tableElement.appendChild(colGroup);\n    updateColgroup(tableElement, config, this.getColumnCount(), this.getColWidths());\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(tableElement, config.theme.table);\n    if (this.__rowStriping) {\n      setRowStriping(tableElement, config, true);\n    }\n    return tableElement;\n  }\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__rowStriping !== this.__rowStriping) {\n      setRowStriping(dom, config, this.__rowStriping);\n    }\n    updateColgroup(dom, config, this.getColumnCount(), this.getColWidths());\n    return false;\n  }\n  exportDOM(editor) {\n    return {\n      ...super.exportDOM(editor),\n      after: tableElement => {\n        if (tableElement) {\n          const newElement = tableElement.cloneNode();\n          const colGroup = document.createElement('colgroup');\n          const tBody = document.createElement('tbody');\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(tableElement)) {\n            const cols = tableElement.querySelectorAll('col');\n            colGroup.append(...cols);\n            const rows = tableElement.querySelectorAll('tr');\n            tBody.append(...rows);\n          }\n          newElement.replaceChildren(colGroup, tBody);\n          return newElement;\n        }\n      }\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  getCordsFromCellNode(tableCellNode, table) {\n    const {\n      rows,\n      domRows\n    } = table;\n    for (let y = 0; y < rows; y++) {\n      const row = domRows[y];\n      if (row == null) {\n        continue;\n      }\n      const x = row.findIndex(cell => {\n        if (!cell) {\n          return;\n        }\n        const {\n          elem\n        } = cell;\n        const cellNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(elem);\n        return cellNode === tableCellNode;\n      });\n      if (x !== -1) {\n        return {\n          x,\n          y\n        };\n      }\n    }\n    throw new Error('Cell not found in table.');\n  }\n  getDOMCellFromCords(x, y, table) {\n    const {\n      domRows\n    } = table;\n    const row = domRows[y];\n    if (row == null) {\n      return null;\n    }\n    const index = x < row.length ? x : row.length - 1;\n    const cell = row[index];\n    if (cell == null) {\n      return null;\n    }\n    return cell;\n  }\n  getDOMCellFromCordsOrThrow(x, y, table) {\n    const cell = this.getDOMCellFromCords(x, y, table);\n    if (!cell) {\n      throw new Error('Cell not found at cords.');\n    }\n    return cell;\n  }\n  getCellNodeFromCords(x, y, table) {\n    const cell = this.getDOMCellFromCords(x, y, table);\n    if (cell == null) {\n      return null;\n    }\n    const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(cell.elem);\n    if ($isTableCellNode(node)) {\n      return node;\n    }\n    return null;\n  }\n  getCellNodeFromCordsOrThrow(x, y, table) {\n    const node = this.getCellNodeFromCords(x, y, table);\n    if (!node) {\n      throw new Error('Node at cords not TableCellNode.');\n    }\n    return node;\n  }\n  getRowStriping() {\n    return Boolean(this.getLatest().__rowStriping);\n  }\n  setRowStriping(newRowStriping) {\n    this.getWritable().__rowStriping = newRowStriping;\n  }\n  canSelectBefore() {\n    return true;\n  }\n  canIndent() {\n    return false;\n  }\n  getColumnCount() {\n    const firstRow = this.getFirstChild();\n    if (!firstRow) {\n      return 0;\n    }\n    let columnCount = 0;\n    firstRow.getChildren().forEach(cell => {\n      if ($isTableCellNode(cell)) {\n        columnCount += cell.getColSpan();\n      }\n    });\n    return columnCount;\n  }\n}\nfunction $getElementForTableNode(editor, tableNode) {\n  const tableElement = editor.getElementByKey(tableNode.getKey());\n  if (tableElement == null) {\n    throw new Error('Table Element Not Found');\n  }\n  return getTable(tableElement);\n}\nfunction $convertTableElement(domNode) {\n  const tableNode = $createTableNode();\n  if (domNode.hasAttribute('data-lexical-row-striping')) {\n    tableNode.setRowStriping(true);\n  }\n  const colGroup = domNode.querySelector(':scope > colgroup');\n  if (colGroup) {\n    let columns = [];\n    for (const col of colGroup.querySelectorAll(':scope > col')) {\n      const width = col.style.width;\n      if (!width || !PIXEL_VALUE_REG_EXP.test(width)) {\n        columns = undefined;\n        break;\n      }\n      columns.push(parseFloat(width));\n    }\n    if (columns) {\n      tableNode.setColWidths(columns);\n    }\n  }\n  return {\n    node: tableNode\n  };\n}\nfunction $createTableNode() {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new TableNode());\n}\nfunction $isTableNode(node) {\n  return node instanceof TableNode;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxleGljYWwrdGFibGVAMC4yMC4wL25vZGVfbW9kdWxlcy9AbGV4aWNhbC90YWJsZS9MZXhpY2FsVGFibGUuZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNEk7QUFDKzBCO0FBQ3Q0Qjs7QUFFckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdEQUFXO0FBQ3ZDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsYUFBYTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksc0VBQXNCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdDQUFnQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtRUFBMEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtRUFBMEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsOERBQXFCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVnNkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9rYXJlbGxlL3ZzY3Byb2plY3RzL3RlY2gtZmxlZXQvdGFpbm8tbGFuZ3VhZ2UtYXBwL2xlc3Nvbi1hdXRob3Jpbmcvbm9kZV9tb2R1bGVzLy5wbnBtL0BsZXhpY2FsK3RhYmxlQDAuMjAuMC9ub2RlX21vZHVsZXMvQGxleGljYWwvdGFibGUvTGV4aWNhbFRhYmxlLmRldi5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyBhZGRDbGFzc05hbWVzVG9FbGVtZW50LCAkZmluZE1hdGNoaW5nUGFyZW50LCByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQsIG9iamVjdEtsYXNzRXF1YWxzLCBpc0hUTUxFbGVtZW50IH0gZnJvbSAnQGxleGljYWwvdXRpbHMnO1xuaW1wb3J0IHsgRWxlbWVudE5vZGUsICRjcmVhdGVQYXJhZ3JhcGhOb2RlLCAkaXNFbGVtZW50Tm9kZSwgJGlzTGluZUJyZWFrTm9kZSwgJGlzVGV4dE5vZGUsICRhcHBseU5vZGVSZXBsYWNlbWVudCwgY3JlYXRlQ29tbWFuZCwgJGNyZWF0ZVRleHROb2RlLCAkZ2V0U2VsZWN0aW9uLCAkaXNSYW5nZVNlbGVjdGlvbiwgJGNyZWF0ZVBvaW50LCAkaXNQYXJhZ3JhcGhOb2RlLCAkbm9ybWFsaXplU2VsZWN0aW9uX19FWFBFUklNRU5UQUwsICRnZXROb2RlQnlLZXksIGlzQ3VycmVudGx5UmVhZE9ubHlNb2RlLCBURVhUX1RZUEVfVE9fRk9STUFULCAkc2V0U2VsZWN0aW9uLCBTRUxFQ1RJT05fQ0hBTkdFX0NPTU1BTkQsICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlLCAkY3JlYXRlUmFuZ2VTZWxlY3Rpb24sICRnZXRSb290LCBLRVlfQVJST1dfRE9XTl9DT01NQU5ELCBDT01NQU5EX1BSSU9SSVRZX0hJR0gsIEtFWV9BUlJPV19VUF9DT01NQU5ELCBLRVlfQVJST1dfTEVGVF9DT01NQU5ELCBLRVlfQVJST1dfUklHSFRfQ09NTUFORCwgS0VZX0VTQ0FQRV9DT01NQU5ELCBERUxFVEVfV09SRF9DT01NQU5ELCBERUxFVEVfTElORV9DT01NQU5ELCBERUxFVEVfQ0hBUkFDVEVSX0NPTU1BTkQsIENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwsIEtFWV9CQUNLU1BBQ0VfQ09NTUFORCwgS0VZX0RFTEVURV9DT01NQU5ELCBDVVRfQ09NTUFORCwgRk9STUFUX1RFWFRfQ09NTUFORCwgRk9STUFUX0VMRU1FTlRfQ09NTUFORCwgQ09OVFJPTExFRF9URVhUX0lOU0VSVElPTl9DT01NQU5ELCBLRVlfVEFCX0NPTU1BTkQsIEZPQ1VTX0NPTU1BTkQsIFNFTEVDVElPTl9JTlNFUlRfQ0xJUEJPQVJEX05PREVTX0NPTU1BTkQsICRnZXRQcmV2aW91c1NlbGVjdGlvbiwgJGNyZWF0ZVJhbmdlU2VsZWN0aW9uRnJvbURvbSwgSU5TRVJUX1BBUkFHUkFQSF9DT01NQU5ELCAkaXNSb290T3JTaGFkb3dSb290LCAkaXNEZWNvcmF0b3JOb2RlIH0gZnJvbSAnbGV4aWNhbCc7XG5pbXBvcnQgeyBjb3B5VG9DbGlwYm9hcmQsICRnZXRDbGlwYm9hcmREYXRhRnJvbVNlbGVjdGlvbiB9IGZyb20gJ0BsZXhpY2FsL2NsaXBib2FyZCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgUElYRUxfVkFMVUVfUkVHX0VYUCA9IC9eKFxcZCsoPzpcXC5cXGQrKT8pcHgkLztcblxuLy8gLlBsYXlncm91bmRFZGl0b3JUaGVtZV9fdGFibGVDZWxsIHdpZHRoIHZhbHVlIGZyb21cbi8vIHBhY2thZ2VzL2xleGljYWwtcGxheWdyb3VuZC9zcmMvdGhlbWVzL1BsYXlncm91bmRFZGl0b3JUaGVtZS5jc3NcbmNvbnN0IENPTFVNTl9XSURUSCA9IDc1O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IFRhYmxlQ2VsbEhlYWRlclN0YXRlcyA9IHtcbiAgQk9USDogMyxcbiAgQ09MVU1OOiAyLFxuICBOT19TVEFUVVM6IDAsXG4gIFJPVzogMVxufTtcbi8qKiBAbm9Jbmhlcml0RG9jICovXG5jbGFzcyBUYWJsZUNlbGxOb2RlIGV4dGVuZHMgRWxlbWVudE5vZGUge1xuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAndGFibGVjZWxsJztcbiAgfVxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgVGFibGVDZWxsTm9kZShub2RlLl9faGVhZGVyU3RhdGUsIG5vZGUuX19jb2xTcGFuLCBub2RlLl9fd2lkdGgsIG5vZGUuX19rZXkpO1xuICB9XG4gIGFmdGVyQ2xvbmVGcm9tKG5vZGUpIHtcbiAgICBzdXBlci5hZnRlckNsb25lRnJvbShub2RlKTtcbiAgICB0aGlzLl9fcm93U3BhbiA9IG5vZGUuX19yb3dTcGFuO1xuICAgIHRoaXMuX19iYWNrZ3JvdW5kQ29sb3IgPSBub2RlLl9fYmFja2dyb3VuZENvbG9yO1xuICB9XG4gIHN0YXRpYyBpbXBvcnRET00oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRkOiBub2RlID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246ICRjb252ZXJ0VGFibGVDZWxsTm9kZUVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KSxcbiAgICAgIHRoOiBub2RlID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246ICRjb252ZXJ0VGFibGVDZWxsTm9kZUVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICBjb25zdCBjb2xTcGFuID0gc2VyaWFsaXplZE5vZGUuY29sU3BhbiB8fCAxO1xuICAgIGNvbnN0IHJvd1NwYW4gPSBzZXJpYWxpemVkTm9kZS5yb3dTcGFuIHx8IDE7XG4gICAgcmV0dXJuICRjcmVhdGVUYWJsZUNlbGxOb2RlKHNlcmlhbGl6ZWROb2RlLmhlYWRlclN0YXRlLCBjb2xTcGFuLCBzZXJpYWxpemVkTm9kZS53aWR0aCB8fCB1bmRlZmluZWQpLnNldFJvd1NwYW4ocm93U3Bhbikuc2V0QmFja2dyb3VuZENvbG9yKHNlcmlhbGl6ZWROb2RlLmJhY2tncm91bmRDb2xvciB8fCBudWxsKTtcbiAgfVxuICBjb25zdHJ1Y3RvcihoZWFkZXJTdGF0ZSA9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5OT19TVEFUVVMsIGNvbFNwYW4gPSAxLCB3aWR0aCwga2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICB0aGlzLl9fY29sU3BhbiA9IGNvbFNwYW47XG4gICAgdGhpcy5fX3Jvd1NwYW4gPSAxO1xuICAgIHRoaXMuX19oZWFkZXJTdGF0ZSA9IGhlYWRlclN0YXRlO1xuICAgIHRoaXMuX193aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuX19iYWNrZ3JvdW5kQ29sb3IgPSBudWxsO1xuICB9XG4gIGNyZWF0ZURPTShjb25maWcpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLmdldFRhZygpKTtcbiAgICBpZiAodGhpcy5fX3dpZHRoKSB7XG4gICAgICBlbGVtZW50LnN0eWxlLndpZHRoID0gYCR7dGhpcy5fX3dpZHRofXB4YDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX19jb2xTcGFuID4gMSkge1xuICAgICAgZWxlbWVudC5jb2xTcGFuID0gdGhpcy5fX2NvbFNwYW47XG4gICAgfVxuICAgIGlmICh0aGlzLl9fcm93U3BhbiA+IDEpIHtcbiAgICAgIGVsZW1lbnQucm93U3BhbiA9IHRoaXMuX19yb3dTcGFuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fX2JhY2tncm91bmRDb2xvciAhPT0gbnVsbCkge1xuICAgICAgZWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLl9fYmFja2dyb3VuZENvbG9yO1xuICAgIH1cbiAgICBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIGNvbmZpZy50aGVtZS50YWJsZUNlbGwsIHRoaXMuaGFzSGVhZGVyKCkgJiYgY29uZmlnLnRoZW1lLnRhYmxlQ2VsbEhlYWRlcik7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgZXhwb3J0RE9NKGVkaXRvcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW1lbnRcbiAgICB9ID0gc3VwZXIuZXhwb3J0RE9NKGVkaXRvcik7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRfID0gZWxlbWVudDtcbiAgICAgIGVsZW1lbnRfLnN0eWxlLmJvcmRlciA9ICcxcHggc29saWQgYmxhY2snO1xuICAgICAgaWYgKHRoaXMuX19jb2xTcGFuID4gMSkge1xuICAgICAgICBlbGVtZW50Xy5jb2xTcGFuID0gdGhpcy5fX2NvbFNwYW47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fX3Jvd1NwYW4gPiAxKSB7XG4gICAgICAgIGVsZW1lbnRfLnJvd1NwYW4gPSB0aGlzLl9fcm93U3BhbjtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnRfLnN0eWxlLndpZHRoID0gYCR7dGhpcy5nZXRXaWR0aCgpIHx8IENPTFVNTl9XSURUSH1weGA7XG4gICAgICBlbGVtZW50Xy5zdHlsZS52ZXJ0aWNhbEFsaWduID0gJ3RvcCc7XG4gICAgICBlbGVtZW50Xy5zdHlsZS50ZXh0QWxpZ24gPSAnc3RhcnQnO1xuICAgICAgY29uc3QgYmFja2dyb3VuZENvbG9yID0gdGhpcy5nZXRCYWNrZ3JvdW5kQ29sb3IoKTtcbiAgICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IgIT09IG51bGwpIHtcbiAgICAgICAgZWxlbWVudF8uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gYmFja2dyb3VuZENvbG9yO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmhhc0hlYWRlcigpKSB7XG4gICAgICAgIGVsZW1lbnRfLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjZjJmM2Y1JztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnRcbiAgICB9O1xuICB9XG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5nZXRCYWNrZ3JvdW5kQ29sb3IoKSxcbiAgICAgIGNvbFNwYW46IHRoaXMuX19jb2xTcGFuLFxuICAgICAgaGVhZGVyU3RhdGU6IHRoaXMuX19oZWFkZXJTdGF0ZSxcbiAgICAgIHJvd1NwYW46IHRoaXMuX19yb3dTcGFuLFxuICAgICAgdHlwZTogJ3RhYmxlY2VsbCcsXG4gICAgICB3aWR0aDogdGhpcy5nZXRXaWR0aCgpXG4gICAgfTtcbiAgfVxuICBnZXRDb2xTcGFuKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9fY29sU3BhbjtcbiAgfVxuICBzZXRDb2xTcGFuKGNvbFNwYW4pIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19jb2xTcGFuID0gY29sU3BhbjtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBnZXRSb3dTcGFuKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9fcm93U3BhbjtcbiAgfVxuICBzZXRSb3dTcGFuKHJvd1NwYW4pIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19yb3dTcGFuID0gcm93U3BhbjtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBnZXRUYWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzSGVhZGVyKCkgPyAndGgnIDogJ3RkJztcbiAgfVxuICBzZXRIZWFkZXJTdHlsZXMoaGVhZGVyU3RhdGUsIG1hc2sgPSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuQk9USCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2hlYWRlclN0YXRlID0gaGVhZGVyU3RhdGUgJiBtYXNrIHwgc2VsZi5fX2hlYWRlclN0YXRlICYgfm1hc2s7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgZ2V0SGVhZGVyU3R5bGVzKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9faGVhZGVyU3RhdGU7XG4gIH1cbiAgc2V0V2lkdGgod2lkdGgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX193aWR0aCA9IHdpZHRoO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGdldFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9fd2lkdGg7XG4gIH1cbiAgZ2V0QmFja2dyb3VuZENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9fYmFja2dyb3VuZENvbG9yO1xuICB9XG4gIHNldEJhY2tncm91bmRDb2xvcihuZXdCYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19iYWNrZ3JvdW5kQ29sb3IgPSBuZXdCYWNrZ3JvdW5kQ29sb3I7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgdG9nZ2xlSGVhZGVyU3R5bGUoaGVhZGVyU3RhdGVUb1RvZ2dsZSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgaWYgKChzZWxmLl9faGVhZGVyU3RhdGUgJiBoZWFkZXJTdGF0ZVRvVG9nZ2xlKSA9PT0gaGVhZGVyU3RhdGVUb1RvZ2dsZSkge1xuICAgICAgc2VsZi5fX2hlYWRlclN0YXRlIC09IGhlYWRlclN0YXRlVG9Ub2dnbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuX19oZWFkZXJTdGF0ZSArPSBoZWFkZXJTdGF0ZVRvVG9nZ2xlO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBoYXNIZWFkZXJTdGF0ZShoZWFkZXJTdGF0ZSkge1xuICAgIHJldHVybiAodGhpcy5nZXRIZWFkZXJTdHlsZXMoKSAmIGhlYWRlclN0YXRlKSA9PT0gaGVhZGVyU3RhdGU7XG4gIH1cbiAgaGFzSGVhZGVyKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9faGVhZGVyU3RhdGUgIT09IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5OT19TVEFUVVM7XG4gIH1cbiAgdXBkYXRlRE9NKHByZXZOb2RlKSB7XG4gICAgcmV0dXJuIHByZXZOb2RlLl9faGVhZGVyU3RhdGUgIT09IHRoaXMuX19oZWFkZXJTdGF0ZSB8fCBwcmV2Tm9kZS5fX3dpZHRoICE9PSB0aGlzLl9fd2lkdGggfHwgcHJldk5vZGUuX19jb2xTcGFuICE9PSB0aGlzLl9fY29sU3BhbiB8fCBwcmV2Tm9kZS5fX3Jvd1NwYW4gIT09IHRoaXMuX19yb3dTcGFuIHx8IHByZXZOb2RlLl9fYmFja2dyb3VuZENvbG9yICE9PSB0aGlzLl9fYmFja2dyb3VuZENvbG9yO1xuICB9XG4gIGlzU2hhZG93Um9vdCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb2xsYXBzZUF0U3RhcnQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY2FuQmVFbXB0eSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY2FuSW5kZW50KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gJGNvbnZlcnRUYWJsZUNlbGxOb2RlRWxlbWVudChkb21Ob2RlKSB7XG4gIGNvbnN0IGRvbU5vZGVfID0gZG9tTm9kZTtcbiAgY29uc3Qgbm9kZU5hbWUgPSBkb21Ob2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIGxldCB3aWR0aCA9IHVuZGVmaW5lZDtcbiAgaWYgKFBJWEVMX1ZBTFVFX1JFR19FWFAudGVzdChkb21Ob2RlXy5zdHlsZS53aWR0aCkpIHtcbiAgICB3aWR0aCA9IHBhcnNlRmxvYXQoZG9tTm9kZV8uc3R5bGUud2lkdGgpO1xuICB9XG4gIGNvbnN0IHRhYmxlQ2VsbE5vZGUgPSAkY3JlYXRlVGFibGVDZWxsTm9kZShub2RlTmFtZSA9PT0gJ3RoJyA/IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5ST1cgOiBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuTk9fU1RBVFVTLCBkb21Ob2RlXy5jb2xTcGFuLCB3aWR0aCk7XG4gIHRhYmxlQ2VsbE5vZGUuX19yb3dTcGFuID0gZG9tTm9kZV8ucm93U3BhbjtcbiAgY29uc3QgYmFja2dyb3VuZENvbG9yID0gZG9tTm9kZV8uc3R5bGUuYmFja2dyb3VuZENvbG9yO1xuICBpZiAoYmFja2dyb3VuZENvbG9yICE9PSAnJykge1xuICAgIHRhYmxlQ2VsbE5vZGUuX19iYWNrZ3JvdW5kQ29sb3IgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gIH1cbiAgY29uc3Qgc3R5bGUgPSBkb21Ob2RlXy5zdHlsZTtcbiAgY29uc3QgdGV4dERlY29yYXRpb24gPSAoc3R5bGUgJiYgc3R5bGUudGV4dERlY29yYXRpb24gfHwgJycpLnNwbGl0KCcgJyk7XG4gIGNvbnN0IGhhc0JvbGRGb250V2VpZ2h0ID0gc3R5bGUuZm9udFdlaWdodCA9PT0gJzcwMCcgfHwgc3R5bGUuZm9udFdlaWdodCA9PT0gJ2JvbGQnO1xuICBjb25zdCBoYXNMaW5ldGhyb3VnaFRleHREZWNvcmF0aW9uID0gdGV4dERlY29yYXRpb24uaW5jbHVkZXMoJ2xpbmUtdGhyb3VnaCcpO1xuICBjb25zdCBoYXNJdGFsaWNGb250U3R5bGUgPSBzdHlsZS5mb250U3R5bGUgPT09ICdpdGFsaWMnO1xuICBjb25zdCBoYXNVbmRlcmxpbmVUZXh0RGVjb3JhdGlvbiA9IHRleHREZWNvcmF0aW9uLmluY2x1ZGVzKCd1bmRlcmxpbmUnKTtcbiAgcmV0dXJuIHtcbiAgICBhZnRlcjogY2hpbGRMZXhpY2FsTm9kZXMgPT4ge1xuICAgICAgaWYgKGNoaWxkTGV4aWNhbE5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjaGlsZExleGljYWxOb2Rlcy5wdXNoKCRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNoaWxkTGV4aWNhbE5vZGVzO1xuICAgIH0sXG4gICAgZm9yQ2hpbGQ6IChsZXhpY2FsTm9kZSwgcGFyZW50TGV4aWNhbE5vZGUpID0+IHtcbiAgICAgIGlmICgkaXNUYWJsZUNlbGxOb2RlKHBhcmVudExleGljYWxOb2RlKSAmJiAhJGlzRWxlbWVudE5vZGUobGV4aWNhbE5vZGUpKSB7XG4gICAgICAgIGNvbnN0IHBhcmFncmFwaE5vZGUgPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgICAgICBpZiAoJGlzTGluZUJyZWFrTm9kZShsZXhpY2FsTm9kZSkgJiYgbGV4aWNhbE5vZGUuZ2V0VGV4dENvbnRlbnQoKSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJGlzVGV4dE5vZGUobGV4aWNhbE5vZGUpKSB7XG4gICAgICAgICAgaWYgKGhhc0JvbGRGb250V2VpZ2h0KSB7XG4gICAgICAgICAgICBsZXhpY2FsTm9kZS50b2dnbGVGb3JtYXQoJ2JvbGQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhc0xpbmV0aHJvdWdoVGV4dERlY29yYXRpb24pIHtcbiAgICAgICAgICAgIGxleGljYWxOb2RlLnRvZ2dsZUZvcm1hdCgnc3RyaWtldGhyb3VnaCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFzSXRhbGljRm9udFN0eWxlKSB7XG4gICAgICAgICAgICBsZXhpY2FsTm9kZS50b2dnbGVGb3JtYXQoJ2l0YWxpYycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFzVW5kZXJsaW5lVGV4dERlY29yYXRpb24pIHtcbiAgICAgICAgICAgIGxleGljYWxOb2RlLnRvZ2dsZUZvcm1hdCgndW5kZXJsaW5lJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBhcmFncmFwaE5vZGUuYXBwZW5kKGxleGljYWxOb2RlKTtcbiAgICAgICAgcmV0dXJuIHBhcmFncmFwaE5vZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGV4aWNhbE5vZGU7XG4gICAgfSxcbiAgICBub2RlOiB0YWJsZUNlbGxOb2RlXG4gIH07XG59XG5mdW5jdGlvbiAkY3JlYXRlVGFibGVDZWxsTm9kZShoZWFkZXJTdGF0ZSwgY29sU3BhbiA9IDEsIHdpZHRoKSB7XG4gIHJldHVybiAkYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IFRhYmxlQ2VsbE5vZGUoaGVhZGVyU3RhdGUsIGNvbFNwYW4sIHdpZHRoKSk7XG59XG5mdW5jdGlvbiAkaXNUYWJsZUNlbGxOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBUYWJsZUNlbGxOb2RlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IElOU0VSVF9UQUJMRV9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnSU5TRVJUX1RBQkxFX0NPTU1BTkQnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBDQU5fVVNFX0RPTSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIFRhYmxlUm93Tm9kZSBleHRlbmRzIEVsZW1lbnROb2RlIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAndGFibGVyb3cnO1xuICB9XG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBUYWJsZVJvd05vZGUobm9kZS5fX2hlaWdodCwgbm9kZS5fX2tleSk7XG4gIH1cbiAgc3RhdGljIGltcG9ydERPTSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHI6IG5vZGUgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogJGNvbnZlcnRUYWJsZVJvd0VsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICByZXR1cm4gJGNyZWF0ZVRhYmxlUm93Tm9kZShzZXJpYWxpemVkTm9kZS5oZWlnaHQpO1xuICB9XG4gIGNvbnN0cnVjdG9yKGhlaWdodCwga2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICB0aGlzLl9faGVpZ2h0ID0gaGVpZ2h0O1xuICB9XG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIC4uLih0aGlzLmdldEhlaWdodCgpICYmIHtcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmdldEhlaWdodCgpXG4gICAgICB9KSxcbiAgICAgIHR5cGU6ICd0YWJsZXJvdycsXG4gICAgICB2ZXJzaW9uOiAxXG4gICAgfTtcbiAgfVxuICBjcmVhdGVET00oY29uZmlnKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XG4gICAgaWYgKHRoaXMuX19oZWlnaHQpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYCR7dGhpcy5fX2hlaWdodH1weGA7XG4gICAgfVxuICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgY29uZmlnLnRoZW1lLnRhYmxlUm93KTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICBpc1NoYWRvd1Jvb3QoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc2V0SGVpZ2h0KGhlaWdodCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2hlaWdodCA9IGhlaWdodDtcbiAgICByZXR1cm4gdGhpcy5fX2hlaWdodDtcbiAgfVxuICBnZXRIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX19oZWlnaHQ7XG4gIH1cbiAgdXBkYXRlRE9NKHByZXZOb2RlKSB7XG4gICAgcmV0dXJuIHByZXZOb2RlLl9faGVpZ2h0ICE9PSB0aGlzLl9faGVpZ2h0O1xuICB9XG4gIGNhbkJlRW1wdHkoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNhbkluZGVudCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uICRjb252ZXJ0VGFibGVSb3dFbGVtZW50KGRvbU5vZGUpIHtcbiAgY29uc3QgZG9tTm9kZV8gPSBkb21Ob2RlO1xuICBsZXQgaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICBpZiAoUElYRUxfVkFMVUVfUkVHX0VYUC50ZXN0KGRvbU5vZGVfLnN0eWxlLmhlaWdodCkpIHtcbiAgICBoZWlnaHQgPSBwYXJzZUZsb2F0KGRvbU5vZGVfLnN0eWxlLmhlaWdodCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBub2RlOiAkY3JlYXRlVGFibGVSb3dOb2RlKGhlaWdodClcbiAgfTtcbn1cbmZ1bmN0aW9uICRjcmVhdGVUYWJsZVJvd05vZGUoaGVpZ2h0KSB7XG4gIHJldHVybiAkYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IFRhYmxlUm93Tm9kZShoZWlnaHQpKTtcbn1cbmZ1bmN0aW9uICRpc1RhYmxlUm93Tm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgVGFibGVSb3dOb2RlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uICRjcmVhdGVUYWJsZU5vZGVXaXRoRGltZW5zaW9ucyhyb3dDb3VudCwgY29sdW1uQ291bnQsIGluY2x1ZGVIZWFkZXJzID0gdHJ1ZSkge1xuICBjb25zdCB0YWJsZU5vZGUgPSAkY3JlYXRlVGFibGVOb2RlKCk7XG4gIGZvciAobGV0IGlSb3cgPSAwOyBpUm93IDwgcm93Q291bnQ7IGlSb3crKykge1xuICAgIGNvbnN0IHRhYmxlUm93Tm9kZSA9ICRjcmVhdGVUYWJsZVJvd05vZGUoKTtcbiAgICBmb3IgKGxldCBpQ29sdW1uID0gMDsgaUNvbHVtbiA8IGNvbHVtbkNvdW50OyBpQ29sdW1uKyspIHtcbiAgICAgIGxldCBoZWFkZXJTdGF0ZSA9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5OT19TVEFUVVM7XG4gICAgICBpZiAodHlwZW9mIGluY2x1ZGVIZWFkZXJzID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoaVJvdyA9PT0gMCAmJiBpbmNsdWRlSGVhZGVycy5yb3dzKSB7XG4gICAgICAgICAgaGVhZGVyU3RhdGUgfD0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLlJPVztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaUNvbHVtbiA9PT0gMCAmJiBpbmNsdWRlSGVhZGVycy5jb2x1bW5zKSB7XG4gICAgICAgICAgaGVhZGVyU3RhdGUgfD0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLkNPTFVNTjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpbmNsdWRlSGVhZGVycykge1xuICAgICAgICBpZiAoaVJvdyA9PT0gMCkge1xuICAgICAgICAgIGhlYWRlclN0YXRlIHw9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5ST1c7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlDb2x1bW4gPT09IDApIHtcbiAgICAgICAgICBoZWFkZXJTdGF0ZSB8PSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuQ09MVU1OO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB0YWJsZUNlbGxOb2RlID0gJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoaGVhZGVyU3RhdGUpO1xuICAgICAgY29uc3QgcGFyYWdyYXBoTm9kZSA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgICBwYXJhZ3JhcGhOb2RlLmFwcGVuZCgkY3JlYXRlVGV4dE5vZGUoKSk7XG4gICAgICB0YWJsZUNlbGxOb2RlLmFwcGVuZChwYXJhZ3JhcGhOb2RlKTtcbiAgICAgIHRhYmxlUm93Tm9kZS5hcHBlbmQodGFibGVDZWxsTm9kZSk7XG4gICAgfVxuICAgIHRhYmxlTm9kZS5hcHBlbmQodGFibGVSb3dOb2RlKTtcbiAgfVxuICByZXR1cm4gdGFibGVOb2RlO1xufVxuZnVuY3Rpb24gJGdldFRhYmxlQ2VsbE5vZGVGcm9tTGV4aWNhbE5vZGUoc3RhcnRpbmdOb2RlKSB7XG4gIGNvbnN0IG5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KHN0YXJ0aW5nTm9kZSwgbiA9PiAkaXNUYWJsZUNlbGxOb2RlKG4pKTtcbiAgaWYgKCRpc1RhYmxlQ2VsbE5vZGUobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uICRnZXRUYWJsZVJvd05vZGVGcm9tVGFibGVDZWxsTm9kZU9yVGhyb3coc3RhcnRpbmdOb2RlKSB7XG4gIGNvbnN0IG5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KHN0YXJ0aW5nTm9kZSwgbiA9PiAkaXNUYWJsZVJvd05vZGUobikpO1xuICBpZiAoJGlzVGFibGVSb3dOb2RlKG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0YWJsZSBjZWxsIHRvIGJlIGluc2lkZSBvZiB0YWJsZSByb3cuJyk7XG59XG5mdW5jdGlvbiAkZ2V0VGFibGVOb2RlRnJvbUxleGljYWxOb2RlT3JUaHJvdyhzdGFydGluZ05vZGUpIHtcbiAgY29uc3Qgbm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc3RhcnRpbmdOb2RlLCBuID0+ICRpc1RhYmxlTm9kZShuKSk7XG4gIGlmICgkaXNUYWJsZU5vZGUobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRhYmxlIGNlbGwgdG8gYmUgaW5zaWRlIG9mIHRhYmxlLicpO1xufVxuZnVuY3Rpb24gJGdldFRhYmxlUm93SW5kZXhGcm9tVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxOb2RlKSB7XG4gIGNvbnN0IHRhYmxlUm93Tm9kZSA9ICRnZXRUYWJsZVJvd05vZGVGcm9tVGFibGVDZWxsTm9kZU9yVGhyb3codGFibGVDZWxsTm9kZSk7XG4gIGNvbnN0IHRhYmxlTm9kZSA9ICRnZXRUYWJsZU5vZGVGcm9tTGV4aWNhbE5vZGVPclRocm93KHRhYmxlUm93Tm9kZSk7XG4gIHJldHVybiB0YWJsZU5vZGUuZ2V0Q2hpbGRyZW4oKS5maW5kSW5kZXgobiA9PiBuLmlzKHRhYmxlUm93Tm9kZSkpO1xufVxuZnVuY3Rpb24gJGdldFRhYmxlQ29sdW1uSW5kZXhGcm9tVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxOb2RlKSB7XG4gIGNvbnN0IHRhYmxlUm93Tm9kZSA9ICRnZXRUYWJsZVJvd05vZGVGcm9tVGFibGVDZWxsTm9kZU9yVGhyb3codGFibGVDZWxsTm9kZSk7XG4gIHJldHVybiB0YWJsZVJvd05vZGUuZ2V0Q2hpbGRyZW4oKS5maW5kSW5kZXgobiA9PiBuLmlzKHRhYmxlQ2VsbE5vZGUpKTtcbn1cbmZ1bmN0aW9uICRnZXRUYWJsZUNlbGxTaWJsaW5nc0Zyb21UYWJsZUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUsIHRhYmxlKSB7XG4gIGNvbnN0IHRhYmxlTm9kZSA9ICRnZXRUYWJsZU5vZGVGcm9tTGV4aWNhbE5vZGVPclRocm93KHRhYmxlQ2VsbE5vZGUpO1xuICBjb25zdCB7XG4gICAgeCxcbiAgICB5XG4gIH0gPSB0YWJsZU5vZGUuZ2V0Q29yZHNGcm9tQ2VsbE5vZGUodGFibGVDZWxsTm9kZSwgdGFibGUpO1xuICByZXR1cm4ge1xuICAgIGFib3ZlOiB0YWJsZU5vZGUuZ2V0Q2VsbE5vZGVGcm9tQ29yZHMoeCwgeSAtIDEsIHRhYmxlKSxcbiAgICBiZWxvdzogdGFibGVOb2RlLmdldENlbGxOb2RlRnJvbUNvcmRzKHgsIHkgKyAxLCB0YWJsZSksXG4gICAgbGVmdDogdGFibGVOb2RlLmdldENlbGxOb2RlRnJvbUNvcmRzKHggLSAxLCB5LCB0YWJsZSksXG4gICAgcmlnaHQ6IHRhYmxlTm9kZS5nZXRDZWxsTm9kZUZyb21Db3Jkcyh4ICsgMSwgeSwgdGFibGUpXG4gIH07XG59XG5mdW5jdGlvbiAkcmVtb3ZlVGFibGVSb3dBdEluZGV4KHRhYmxlTm9kZSwgaW5kZXhUb0RlbGV0ZSkge1xuICBjb25zdCB0YWJsZVJvd3MgPSB0YWJsZU5vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgaWYgKGluZGV4VG9EZWxldGUgPj0gdGFibGVSb3dzLmxlbmd0aCB8fCBpbmRleFRvRGVsZXRlIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGFibGUgY2VsbCB0byBiZSBpbnNpZGUgb2YgdGFibGUgcm93LicpO1xuICB9XG4gIGNvbnN0IHRhcmdldFJvd05vZGUgPSB0YWJsZVJvd3NbaW5kZXhUb0RlbGV0ZV07XG4gIHRhcmdldFJvd05vZGUucmVtb3ZlKCk7XG4gIHJldHVybiB0YWJsZU5vZGU7XG59XG5mdW5jdGlvbiAkaW5zZXJ0VGFibGVSb3codGFibGVOb2RlLCB0YXJnZXRJbmRleCwgc2hvdWxkSW5zZXJ0QWZ0ZXIgPSB0cnVlLCByb3dDb3VudCwgdGFibGUpIHtcbiAgY29uc3QgdGFibGVSb3dzID0gdGFibGVOb2RlLmdldENoaWxkcmVuKCk7XG4gIGlmICh0YXJnZXRJbmRleCA+PSB0YWJsZVJvd3MubGVuZ3RoIHx8IHRhcmdldEluZGV4IDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGFibGUgcm93IHRhcmdldCBpbmRleCBvdXQgb2YgcmFuZ2UnKTtcbiAgfVxuICBjb25zdCB0YXJnZXRSb3dOb2RlID0gdGFibGVSb3dzW3RhcmdldEluZGV4XTtcbiAgaWYgKCRpc1RhYmxlUm93Tm9kZSh0YXJnZXRSb3dOb2RlKSkge1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgcm93Q291bnQ7IHIrKykge1xuICAgICAgY29uc3QgdGFibGVSb3dDZWxscyA9IHRhcmdldFJvd05vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgIGNvbnN0IHRhYmxlQ29sdW1uQ291bnQgPSB0YWJsZVJvd0NlbGxzLmxlbmd0aDtcbiAgICAgIGNvbnN0IG5ld1RhYmxlUm93Tm9kZSA9ICRjcmVhdGVUYWJsZVJvd05vZGUoKTtcbiAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgdGFibGVDb2x1bW5Db3VudDsgYysrKSB7XG4gICAgICAgIGNvbnN0IHRhYmxlQ2VsbEZyb21UYXJnZXRSb3cgPSB0YWJsZVJvd0NlbGxzW2NdO1xuICAgICAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUodGFibGVDZWxsRnJvbVRhcmdldFJvdykpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgdGFibGUgY2VsbGApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBhYm92ZSxcbiAgICAgICAgICBiZWxvd1xuICAgICAgICB9ID0gJGdldFRhYmxlQ2VsbFNpYmxpbmdzRnJvbVRhYmxlQ2VsbE5vZGUodGFibGVDZWxsRnJvbVRhcmdldFJvdywgdGFibGUpO1xuICAgICAgICBsZXQgaGVhZGVyU3RhdGUgPSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuTk9fU1RBVFVTO1xuICAgICAgICBjb25zdCB3aWR0aCA9IGFib3ZlICYmIGFib3ZlLmdldFdpZHRoKCkgfHwgYmVsb3cgJiYgYmVsb3cuZ2V0V2lkdGgoKSB8fCB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChhYm92ZSAmJiBhYm92ZS5oYXNIZWFkZXJTdGF0ZShUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuQ09MVU1OKSB8fCBiZWxvdyAmJiBiZWxvdy5oYXNIZWFkZXJTdGF0ZShUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuQ09MVU1OKSkge1xuICAgICAgICAgIGhlYWRlclN0YXRlIHw9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5DT0xVTU47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFibGVDZWxsTm9kZSA9ICRjcmVhdGVUYWJsZUNlbGxOb2RlKGhlYWRlclN0YXRlLCAxLCB3aWR0aCk7XG4gICAgICAgIHRhYmxlQ2VsbE5vZGUuYXBwZW5kKCRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkpO1xuICAgICAgICBuZXdUYWJsZVJvd05vZGUuYXBwZW5kKHRhYmxlQ2VsbE5vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZEluc2VydEFmdGVyKSB7XG4gICAgICAgIHRhcmdldFJvd05vZGUuaW5zZXJ0QWZ0ZXIobmV3VGFibGVSb3dOb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldFJvd05vZGUuaW5zZXJ0QmVmb3JlKG5ld1RhYmxlUm93Tm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignUm93IGJlZm9yZSBpbnNlcnRpb24gaW5kZXggZG9lcyBub3QgZXhpc3QuJyk7XG4gIH1cbiAgcmV0dXJuIHRhYmxlTm9kZTtcbn1cbmNvbnN0IGdldEhlYWRlclN0YXRlID0gKGN1cnJlbnRTdGF0ZSwgcG9zc2libGVTdGF0ZSkgPT4ge1xuICBpZiAoY3VycmVudFN0YXRlID09PSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuQk9USCB8fCBjdXJyZW50U3RhdGUgPT09IHBvc3NpYmxlU3RhdGUpIHtcbiAgICByZXR1cm4gcG9zc2libGVTdGF0ZTtcbiAgfVxuICByZXR1cm4gVGFibGVDZWxsSGVhZGVyU3RhdGVzLk5PX1NUQVRVUztcbn07XG5cbi8qKlxuICogSW5zZXJ0cyBhIHRhYmxlIHJvdyBiZWZvcmUgb3IgYWZ0ZXIgdGhlIGN1cnJlbnQgZm9jdXMgY2VsbCBub2RlLFxuICogdGFraW5nIGludG8gYWNjb3VudCBhbnkgc3BhbnMuIElmIHN1Y2Nlc3NmdWwsIHJldHVybnMgdGhlXG4gKiBpbnNlcnRlZCB0YWJsZSByb3cgbm9kZS5cbiAqL1xuZnVuY3Rpb24gJGluc2VydFRhYmxlUm93X19FWFBFUklNRU5UQUwoaW5zZXJ0QWZ0ZXIgPSB0cnVlKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCEoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCAkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSkge1xuICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBhIFJhbmdlU2VsZWN0aW9uIG9yIFRhYmxlU2VsZWN0aW9uYCk7XG4gIH1cbiAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpO1xuICBjb25zdCBbZm9jdXNDZWxsLCwgZ3JpZF0gPSAkZ2V0Tm9kZVRyaXBsZXQoZm9jdXMpO1xuICBjb25zdCBbZ3JpZE1hcCwgZm9jdXNDZWxsTWFwXSA9ICRjb21wdXRlVGFibGVNYXAoZ3JpZCwgZm9jdXNDZWxsLCBmb2N1c0NlbGwpO1xuICBjb25zdCBjb2x1bW5Db3VudCA9IGdyaWRNYXBbMF0ubGVuZ3RoO1xuICBjb25zdCB7XG4gICAgc3RhcnRSb3c6IGZvY3VzU3RhcnRSb3dcbiAgfSA9IGZvY3VzQ2VsbE1hcDtcbiAgbGV0IGluc2VydGVkUm93ID0gbnVsbDtcbiAgaWYgKGluc2VydEFmdGVyKSB7XG4gICAgY29uc3QgZm9jdXNFbmRSb3cgPSBmb2N1c1N0YXJ0Um93ICsgZm9jdXNDZWxsLl9fcm93U3BhbiAtIDE7XG4gICAgY29uc3QgZm9jdXNFbmRSb3dNYXAgPSBncmlkTWFwW2ZvY3VzRW5kUm93XTtcbiAgICBjb25zdCBuZXdSb3cgPSAkY3JlYXRlVGFibGVSb3dOb2RlKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5Db3VudDsgaSsrKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNlbGwsXG4gICAgICAgIHN0YXJ0Um93XG4gICAgICB9ID0gZm9jdXNFbmRSb3dNYXBbaV07XG4gICAgICBpZiAoc3RhcnRSb3cgKyBjZWxsLl9fcm93U3BhbiAtIDEgPD0gZm9jdXNFbmRSb3cpIHtcbiAgICAgICAgY29uc3QgY3VycmVudENlbGwgPSBmb2N1c0VuZFJvd01hcFtpXS5jZWxsO1xuICAgICAgICBjb25zdCBjdXJyZW50Q2VsbEhlYWRlclN0YXRlID0gY3VycmVudENlbGwuX19oZWFkZXJTdGF0ZTtcbiAgICAgICAgY29uc3QgaGVhZGVyU3RhdGUgPSBnZXRIZWFkZXJTdGF0ZShjdXJyZW50Q2VsbEhlYWRlclN0YXRlLCBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuQ09MVU1OKTtcbiAgICAgICAgbmV3Um93LmFwcGVuZCgkY3JlYXRlVGFibGVDZWxsTm9kZShoZWFkZXJTdGF0ZSkuYXBwZW5kKCRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNlbGwuc2V0Um93U3BhbihjZWxsLl9fcm93U3BhbiArIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmb2N1c0VuZFJvd05vZGUgPSBncmlkLmdldENoaWxkQXRJbmRleChmb2N1c0VuZFJvdyk7XG4gICAgaWYgKCEkaXNUYWJsZVJvd05vZGUoZm9jdXNFbmRSb3dOb2RlKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYGZvY3VzRW5kUm93IGlzIG5vdCBhIFRhYmxlUm93Tm9kZWApO1xuICAgIH1cbiAgICBmb2N1c0VuZFJvd05vZGUuaW5zZXJ0QWZ0ZXIobmV3Um93KTtcbiAgICBpbnNlcnRlZFJvdyA9IG5ld1JvdztcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBmb2N1c1N0YXJ0Um93TWFwID0gZ3JpZE1hcFtmb2N1c1N0YXJ0Um93XTtcbiAgICBjb25zdCBuZXdSb3cgPSAkY3JlYXRlVGFibGVSb3dOb2RlKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5Db3VudDsgaSsrKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNlbGwsXG4gICAgICAgIHN0YXJ0Um93XG4gICAgICB9ID0gZm9jdXNTdGFydFJvd01hcFtpXTtcbiAgICAgIGlmIChzdGFydFJvdyA9PT0gZm9jdXNTdGFydFJvdykge1xuICAgICAgICBjb25zdCBjdXJyZW50Q2VsbCA9IGZvY3VzU3RhcnRSb3dNYXBbaV0uY2VsbDtcbiAgICAgICAgY29uc3QgY3VycmVudENlbGxIZWFkZXJTdGF0ZSA9IGN1cnJlbnRDZWxsLl9faGVhZGVyU3RhdGU7XG4gICAgICAgIGNvbnN0IGhlYWRlclN0YXRlID0gZ2V0SGVhZGVyU3RhdGUoY3VycmVudENlbGxIZWFkZXJTdGF0ZSwgVGFibGVDZWxsSGVhZGVyU3RhdGVzLkNPTFVNTik7XG4gICAgICAgIG5ld1Jvdy5hcHBlbmQoJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoaGVhZGVyU3RhdGUpLmFwcGVuZCgkY3JlYXRlUGFyYWdyYXBoTm9kZSgpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjZWxsLnNldFJvd1NwYW4oY2VsbC5fX3Jvd1NwYW4gKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZm9jdXNTdGFydFJvd05vZGUgPSBncmlkLmdldENoaWxkQXRJbmRleChmb2N1c1N0YXJ0Um93KTtcbiAgICBpZiAoISRpc1RhYmxlUm93Tm9kZShmb2N1c1N0YXJ0Um93Tm9kZSkpIHtcbiAgICAgIHRocm93IEVycm9yKGBmb2N1c0VuZFJvdyBpcyBub3QgYSBUYWJsZVJvd05vZGVgKTtcbiAgICB9XG4gICAgZm9jdXNTdGFydFJvd05vZGUuaW5zZXJ0QmVmb3JlKG5ld1Jvdyk7XG4gICAgaW5zZXJ0ZWRSb3cgPSBuZXdSb3c7XG4gIH1cbiAgcmV0dXJuIGluc2VydGVkUm93O1xufVxuZnVuY3Rpb24gJGluc2VydFRhYmxlQ29sdW1uKHRhYmxlTm9kZSwgdGFyZ2V0SW5kZXgsIHNob3VsZEluc2VydEFmdGVyID0gdHJ1ZSwgY29sdW1uQ291bnQsIHRhYmxlKSB7XG4gIGNvbnN0IHRhYmxlUm93cyA9IHRhYmxlTm9kZS5nZXRDaGlsZHJlbigpO1xuICBjb25zdCB0YWJsZUNlbGxzVG9CZUluc2VydGVkID0gW107XG4gIGZvciAobGV0IHIgPSAwOyByIDwgdGFibGVSb3dzLmxlbmd0aDsgcisrKSB7XG4gICAgY29uc3QgY3VycmVudFRhYmxlUm93Tm9kZSA9IHRhYmxlUm93c1tyXTtcbiAgICBpZiAoJGlzVGFibGVSb3dOb2RlKGN1cnJlbnRUYWJsZVJvd05vZGUpKSB7XG4gICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGNvbHVtbkNvdW50OyBjKyspIHtcbiAgICAgICAgY29uc3QgdGFibGVSb3dDaGlsZHJlbiA9IGN1cnJlbnRUYWJsZVJvd05vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgaWYgKHRhcmdldEluZGV4ID49IHRhYmxlUm93Q2hpbGRyZW4ubGVuZ3RoIHx8IHRhcmdldEluZGV4IDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGFibGUgY29sdW1uIHRhcmdldCBpbmRleCBvdXQgb2YgcmFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXRDZWxsID0gdGFibGVSb3dDaGlsZHJlblt0YXJnZXRJbmRleF07XG4gICAgICAgIGlmICghJGlzVGFibGVDZWxsTm9kZSh0YXJnZXRDZWxsKSkge1xuICAgICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCB0YWJsZSBjZWxsYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgcmlnaHRcbiAgICAgICAgfSA9ICRnZXRUYWJsZUNlbGxTaWJsaW5nc0Zyb21UYWJsZUNlbGxOb2RlKHRhcmdldENlbGwsIHRhYmxlKTtcbiAgICAgICAgbGV0IGhlYWRlclN0YXRlID0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLk5PX1NUQVRVUztcbiAgICAgICAgaWYgKGxlZnQgJiYgbGVmdC5oYXNIZWFkZXJTdGF0ZShUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuUk9XKSB8fCByaWdodCAmJiByaWdodC5oYXNIZWFkZXJTdGF0ZShUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuUk9XKSkge1xuICAgICAgICAgIGhlYWRlclN0YXRlIHw9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5ST1c7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3VGFibGVDZWxsID0gJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoaGVhZGVyU3RhdGUpO1xuICAgICAgICBuZXdUYWJsZUNlbGwuYXBwZW5kKCRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkpO1xuICAgICAgICB0YWJsZUNlbGxzVG9CZUluc2VydGVkLnB1c2goe1xuICAgICAgICAgIG5ld1RhYmxlQ2VsbCxcbiAgICAgICAgICB0YXJnZXRDZWxsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0YWJsZUNlbGxzVG9CZUluc2VydGVkLmZvckVhY2goKHtcbiAgICBuZXdUYWJsZUNlbGwsXG4gICAgdGFyZ2V0Q2VsbFxuICB9KSA9PiB7XG4gICAgaWYgKHNob3VsZEluc2VydEFmdGVyKSB7XG4gICAgICB0YXJnZXRDZWxsLmluc2VydEFmdGVyKG5ld1RhYmxlQ2VsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldENlbGwuaW5zZXJ0QmVmb3JlKG5ld1RhYmxlQ2VsbCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRhYmxlTm9kZTtcbn1cblxuLyoqXG4gKiBJbnNlcnRzIGEgY29sdW1uIGJlZm9yZSBvciBhZnRlciB0aGUgY3VycmVudCBmb2N1cyBjZWxsIG5vZGUsXG4gKiB0YWtpbmcgaW50byBhY2NvdW50IGFueSBzcGFucy4gSWYgc3VjY2Vzc2Z1bCwgcmV0dXJucyB0aGVcbiAqIGZpcnN0IGluc2VydGVkIGNlbGwgbm9kZS5cbiAqL1xuZnVuY3Rpb24gJGluc2VydFRhYmxlQ29sdW1uX19FWFBFUklNRU5UQUwoaW5zZXJ0QWZ0ZXIgPSB0cnVlKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCEoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCAkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSkge1xuICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBhIFJhbmdlU2VsZWN0aW9uIG9yIFRhYmxlU2VsZWN0aW9uYCk7XG4gIH1cbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKTtcbiAgY29uc3QgW2FuY2hvckNlbGxdID0gJGdldE5vZGVUcmlwbGV0KGFuY2hvcik7XG4gIGNvbnN0IFtmb2N1c0NlbGwsLCBncmlkXSA9ICRnZXROb2RlVHJpcGxldChmb2N1cyk7XG4gIGNvbnN0IFtncmlkTWFwLCBmb2N1c0NlbGxNYXAsIGFuY2hvckNlbGxNYXBdID0gJGNvbXB1dGVUYWJsZU1hcChncmlkLCBmb2N1c0NlbGwsIGFuY2hvckNlbGwpO1xuICBjb25zdCByb3dDb3VudCA9IGdyaWRNYXAubGVuZ3RoO1xuICBjb25zdCBzdGFydENvbHVtbiA9IGluc2VydEFmdGVyID8gTWF0aC5tYXgoZm9jdXNDZWxsTWFwLnN0YXJ0Q29sdW1uLCBhbmNob3JDZWxsTWFwLnN0YXJ0Q29sdW1uKSA6IE1hdGgubWluKGZvY3VzQ2VsbE1hcC5zdGFydENvbHVtbiwgYW5jaG9yQ2VsbE1hcC5zdGFydENvbHVtbik7XG4gIGNvbnN0IGluc2VydEFmdGVyQ29sdW1uID0gaW5zZXJ0QWZ0ZXIgPyBzdGFydENvbHVtbiArIGZvY3VzQ2VsbC5fX2NvbFNwYW4gLSAxIDogc3RhcnRDb2x1bW4gLSAxO1xuICBjb25zdCBncmlkRmlyc3RDaGlsZCA9IGdyaWQuZ2V0Rmlyc3RDaGlsZCgpO1xuICBpZiAoISRpc1RhYmxlUm93Tm9kZShncmlkRmlyc3RDaGlsZCkpIHtcbiAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgZmlyc3RUYWJsZSBjaGlsZCB0byBiZSBhIHJvd2ApO1xuICB9XG4gIGxldCBmaXJzdEluc2VydGVkQ2VsbCA9IG51bGw7XG4gIGZ1bmN0aW9uICRjcmVhdGVUYWJsZUNlbGxOb2RlRm9ySW5zZXJ0VGFibGVDb2x1bW4oaGVhZGVyU3RhdGUgPSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuTk9fU1RBVFVTKSB7XG4gICAgY29uc3QgY2VsbCA9ICRjcmVhdGVUYWJsZUNlbGxOb2RlKGhlYWRlclN0YXRlKS5hcHBlbmQoJGNyZWF0ZVBhcmFncmFwaE5vZGUoKSk7XG4gICAgaWYgKGZpcnN0SW5zZXJ0ZWRDZWxsID09PSBudWxsKSB7XG4gICAgICBmaXJzdEluc2VydGVkQ2VsbCA9IGNlbGw7XG4gICAgfVxuICAgIHJldHVybiBjZWxsO1xuICB9XG4gIGxldCBsb29wUm93ID0gZ3JpZEZpcnN0Q2hpbGQ7XG4gIHJvd0xvb3A6IGZvciAobGV0IGkgPSAwOyBpIDwgcm93Q291bnQ7IGkrKykge1xuICAgIGlmIChpICE9PSAwKSB7XG4gICAgICBjb25zdCBjdXJyZW50Um93ID0gbG9vcFJvdy5nZXROZXh0U2libGluZygpO1xuICAgICAgaWYgKCEkaXNUYWJsZVJvd05vZGUoY3VycmVudFJvdykpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIHJvdyBuZXh0U2libGluZyB0byBiZSBhIHJvd2ApO1xuICAgICAgfVxuICAgICAgbG9vcFJvdyA9IGN1cnJlbnRSb3c7XG4gICAgfVxuICAgIGNvbnN0IHJvd01hcCA9IGdyaWRNYXBbaV07XG4gICAgY29uc3QgY3VycmVudENlbGxIZWFkZXJTdGF0ZSA9IHJvd01hcFtpbnNlcnRBZnRlckNvbHVtbiA8IDAgPyAwIDogaW5zZXJ0QWZ0ZXJDb2x1bW5dLmNlbGwuX19oZWFkZXJTdGF0ZTtcbiAgICBjb25zdCBoZWFkZXJTdGF0ZSA9IGdldEhlYWRlclN0YXRlKGN1cnJlbnRDZWxsSGVhZGVyU3RhdGUsIFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5ST1cpO1xuICAgIGlmIChpbnNlcnRBZnRlckNvbHVtbiA8IDApIHtcbiAgICAgICRpbnNlcnRGaXJzdChsb29wUm93LCAkY3JlYXRlVGFibGVDZWxsTm9kZUZvckluc2VydFRhYmxlQ29sdW1uKGhlYWRlclN0YXRlKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY2VsbDogY3VycmVudENlbGwsXG4gICAgICBzdGFydENvbHVtbjogY3VycmVudFN0YXJ0Q29sdW1uLFxuICAgICAgc3RhcnRSb3c6IGN1cnJlbnRTdGFydFJvd1xuICAgIH0gPSByb3dNYXBbaW5zZXJ0QWZ0ZXJDb2x1bW5dO1xuICAgIGlmIChjdXJyZW50U3RhcnRDb2x1bW4gKyBjdXJyZW50Q2VsbC5fX2NvbFNwYW4gLSAxIDw9IGluc2VydEFmdGVyQ29sdW1uKSB7XG4gICAgICBsZXQgaW5zZXJ0QWZ0ZXJDZWxsID0gY3VycmVudENlbGw7XG4gICAgICBsZXQgaW5zZXJ0QWZ0ZXJDZWxsUm93U3RhcnQgPSBjdXJyZW50U3RhcnRSb3c7XG4gICAgICBsZXQgcHJldkNlbGxJbmRleCA9IGluc2VydEFmdGVyQ29sdW1uO1xuICAgICAgd2hpbGUgKGluc2VydEFmdGVyQ2VsbFJvd1N0YXJ0ICE9PSBpICYmIGluc2VydEFmdGVyQ2VsbC5fX3Jvd1NwYW4gPiAxKSB7XG4gICAgICAgIHByZXZDZWxsSW5kZXggLT0gY3VycmVudENlbGwuX19jb2xTcGFuO1xuICAgICAgICBpZiAocHJldkNlbGxJbmRleCA+PSAwKSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgY2VsbDogY2VsbF8sXG4gICAgICAgICAgICBzdGFydFJvdzogc3RhcnRSb3dfXG4gICAgICAgICAgfSA9IHJvd01hcFtwcmV2Q2VsbEluZGV4XTtcbiAgICAgICAgICBpbnNlcnRBZnRlckNlbGwgPSBjZWxsXztcbiAgICAgICAgICBpbnNlcnRBZnRlckNlbGxSb3dTdGFydCA9IHN0YXJ0Um93XztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb29wUm93LmFwcGVuZCgkY3JlYXRlVGFibGVDZWxsTm9kZUZvckluc2VydFRhYmxlQ29sdW1uKGhlYWRlclN0YXRlKSk7XG4gICAgICAgICAgY29udGludWUgcm93TG9vcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaW5zZXJ0QWZ0ZXJDZWxsLmluc2VydEFmdGVyKCRjcmVhdGVUYWJsZUNlbGxOb2RlRm9ySW5zZXJ0VGFibGVDb2x1bW4oaGVhZGVyU3RhdGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudENlbGwuc2V0Q29sU3BhbihjdXJyZW50Q2VsbC5fX2NvbFNwYW4gKyAxKTtcbiAgICB9XG4gIH1cbiAgaWYgKGZpcnN0SW5zZXJ0ZWRDZWxsICE9PSBudWxsKSB7XG4gICAgJG1vdmVTZWxlY3Rpb25Ub0NlbGwoZmlyc3RJbnNlcnRlZENlbGwpO1xuICB9XG4gIGNvbnN0IGNvbFdpZHRocyA9IGdyaWQuZ2V0Q29sV2lkdGhzKCk7XG4gIGlmIChjb2xXaWR0aHMpIHtcbiAgICBjb25zdCBuZXdDb2xXaWR0aHMgPSBbLi4uY29sV2lkdGhzXTtcbiAgICBjb25zdCBjb2x1bW5JbmRleCA9IGluc2VydEFmdGVyQ29sdW1uIDwgMCA/IDAgOiBpbnNlcnRBZnRlckNvbHVtbjtcbiAgICBjb25zdCBuZXdXaWR0aCA9IG5ld0NvbFdpZHRoc1tjb2x1bW5JbmRleF07XG4gICAgbmV3Q29sV2lkdGhzLnNwbGljZShjb2x1bW5JbmRleCwgMCwgbmV3V2lkdGgpO1xuICAgIGdyaWQuc2V0Q29sV2lkdGhzKG5ld0NvbFdpZHRocyk7XG4gIH1cbiAgcmV0dXJuIGZpcnN0SW5zZXJ0ZWRDZWxsO1xufVxuZnVuY3Rpb24gJGRlbGV0ZVRhYmxlQ29sdW1uKHRhYmxlTm9kZSwgdGFyZ2V0SW5kZXgpIHtcbiAgY29uc3QgdGFibGVSb3dzID0gdGFibGVOb2RlLmdldENoaWxkcmVuKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGFibGVSb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY3VycmVudFRhYmxlUm93Tm9kZSA9IHRhYmxlUm93c1tpXTtcbiAgICBpZiAoJGlzVGFibGVSb3dOb2RlKGN1cnJlbnRUYWJsZVJvd05vZGUpKSB7XG4gICAgICBjb25zdCB0YWJsZVJvd0NoaWxkcmVuID0gY3VycmVudFRhYmxlUm93Tm9kZS5nZXRDaGlsZHJlbigpO1xuICAgICAgaWYgKHRhcmdldEluZGV4ID49IHRhYmxlUm93Q2hpbGRyZW4ubGVuZ3RoIHx8IHRhcmdldEluZGV4IDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RhYmxlIGNvbHVtbiB0YXJnZXQgaW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gICAgICB9XG4gICAgICB0YWJsZVJvd0NoaWxkcmVuW3RhcmdldEluZGV4XS5yZW1vdmUoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhYmxlTm9kZTtcbn1cbmZ1bmN0aW9uICRkZWxldGVUYWJsZVJvd19fRVhQRVJJTUVOVEFMKCkge1xuICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gIGlmICghKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkpIHtcbiAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgYSBSYW5nZVNlbGVjdGlvbiBvciBUYWJsZVNlbGVjdGlvbmApO1xuICB9XG4gIGNvbnN0IFthbmNob3IsIGZvY3VzXSA9IHNlbGVjdGlvbi5pc0JhY2t3YXJkKCkgPyBbc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKSwgc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCldIDogW3NlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpLCBzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpXTtcbiAgY29uc3QgW2FuY2hvckNlbGwsLCBncmlkXSA9ICRnZXROb2RlVHJpcGxldChhbmNob3IpO1xuICBjb25zdCBbZm9jdXNDZWxsXSA9ICRnZXROb2RlVHJpcGxldChmb2N1cyk7XG4gIGNvbnN0IFtncmlkTWFwLCBhbmNob3JDZWxsTWFwLCBmb2N1c0NlbGxNYXBdID0gJGNvbXB1dGVUYWJsZU1hcChncmlkLCBhbmNob3JDZWxsLCBmb2N1c0NlbGwpO1xuICBjb25zdCB7XG4gICAgc3RhcnRSb3c6IGFuY2hvclN0YXJ0Um93XG4gIH0gPSBhbmNob3JDZWxsTWFwO1xuICBjb25zdCB7XG4gICAgc3RhcnRSb3c6IGZvY3VzU3RhcnRSb3dcbiAgfSA9IGZvY3VzQ2VsbE1hcDtcbiAgY29uc3QgZm9jdXNFbmRSb3cgPSBmb2N1c1N0YXJ0Um93ICsgZm9jdXNDZWxsLl9fcm93U3BhbiAtIDE7XG4gIGlmIChncmlkTWFwLmxlbmd0aCA9PT0gZm9jdXNFbmRSb3cgLSBhbmNob3JTdGFydFJvdyArIDEpIHtcbiAgICAvLyBFbXB0eSBncmlkXG4gICAgZ3JpZC5yZW1vdmUoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgY29sdW1uQ291bnQgPSBncmlkTWFwWzBdLmxlbmd0aDtcbiAgY29uc3QgbmV4dFJvdyA9IGdyaWRNYXBbZm9jdXNFbmRSb3cgKyAxXTtcbiAgY29uc3QgbmV4dFJvd05vZGUgPSBncmlkLmdldENoaWxkQXRJbmRleChmb2N1c0VuZFJvdyArIDEpO1xuICBmb3IgKGxldCByb3cgPSBmb2N1c0VuZFJvdzsgcm93ID49IGFuY2hvclN0YXJ0Um93OyByb3ctLSkge1xuICAgIGZvciAobGV0IGNvbHVtbiA9IGNvbHVtbkNvdW50IC0gMTsgY29sdW1uID49IDA7IGNvbHVtbi0tKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNlbGwsXG4gICAgICAgIHN0YXJ0Um93OiBjZWxsU3RhcnRSb3csXG4gICAgICAgIHN0YXJ0Q29sdW1uOiBjZWxsU3RhcnRDb2x1bW5cbiAgICAgIH0gPSBncmlkTWFwW3Jvd11bY29sdW1uXTtcbiAgICAgIGlmIChjZWxsU3RhcnRDb2x1bW4gIT09IGNvbHVtbikge1xuICAgICAgICAvLyBEb24ndCByZXBlYXQgd29yayBmb3IgdGhlIHNhbWUgQ2VsbFxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIFJvd3Mgb3ZlcmZsb3dpbmcgdG9wIGhhdmUgdG8gYmUgdHJpbW1lZFxuICAgICAgaWYgKHJvdyA9PT0gYW5jaG9yU3RhcnRSb3cgJiYgY2VsbFN0YXJ0Um93IDwgYW5jaG9yU3RhcnRSb3cpIHtcbiAgICAgICAgY2VsbC5zZXRSb3dTcGFuKGNlbGwuX19yb3dTcGFuIC0gKGNlbGxTdGFydFJvdyAtIGFuY2hvclN0YXJ0Um93KSk7XG4gICAgICB9XG4gICAgICAvLyBSb3dzIG92ZXJmbG93aW5nIGJvdHRvbSBoYXZlIHRvIGJlIHRyaW1tZWQgYW5kIG1vdmVkIHRvIHRoZSBuZXh0IHJvd1xuICAgICAgaWYgKGNlbGxTdGFydFJvdyA+PSBhbmNob3JTdGFydFJvdyAmJiBjZWxsU3RhcnRSb3cgKyBjZWxsLl9fcm93U3BhbiAtIDEgPiBmb2N1c0VuZFJvdykge1xuICAgICAgICBjZWxsLnNldFJvd1NwYW4oY2VsbC5fX3Jvd1NwYW4gLSAoZm9jdXNFbmRSb3cgLSBjZWxsU3RhcnRSb3cgKyAxKSk7XG4gICAgICAgIGlmICghKG5leHRSb3dOb2RlICE9PSBudWxsKSkge1xuICAgICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBuZXh0Um93Tm9kZSBub3QgdG8gYmUgbnVsbGApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2x1bW4gPT09IDApIHtcbiAgICAgICAgICAkaW5zZXJ0Rmlyc3QobmV4dFJvd05vZGUsIGNlbGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGNlbGw6IHByZXZpb3VzQ2VsbFxuICAgICAgICAgIH0gPSBuZXh0Um93W2NvbHVtbiAtIDFdO1xuICAgICAgICAgIHByZXZpb3VzQ2VsbC5pbnNlcnRBZnRlcihjZWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByb3dOb2RlID0gZ3JpZC5nZXRDaGlsZEF0SW5kZXgocm93KTtcbiAgICBpZiAoISRpc1RhYmxlUm93Tm9kZShyb3dOb2RlKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIFRhYmxlTm9kZSBjaGlsZEF0SW5kZXgoJHtTdHJpbmcocm93KX0pIHRvIGJlIFJvd05vZGVgKTtcbiAgICB9XG4gICAgcm93Tm9kZS5yZW1vdmUoKTtcbiAgfVxuICBpZiAobmV4dFJvdyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3Qge1xuICAgICAgY2VsbFxuICAgIH0gPSBuZXh0Um93WzBdO1xuICAgICRtb3ZlU2VsZWN0aW9uVG9DZWxsKGNlbGwpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHByZXZpb3VzUm93ID0gZ3JpZE1hcFthbmNob3JTdGFydFJvdyAtIDFdO1xuICAgIGNvbnN0IHtcbiAgICAgIGNlbGxcbiAgICB9ID0gcHJldmlvdXNSb3dbMF07XG4gICAgJG1vdmVTZWxlY3Rpb25Ub0NlbGwoY2VsbCk7XG4gIH1cbn1cbmZ1bmN0aW9uICRkZWxldGVUYWJsZUNvbHVtbl9fRVhQRVJJTUVOVEFMKCkge1xuICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gIGlmICghKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkpIHtcbiAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgYSBSYW5nZVNlbGVjdGlvbiBvciBUYWJsZVNlbGVjdGlvbmApO1xuICB9XG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCk7XG4gIGNvbnN0IFthbmNob3JDZWxsLCwgZ3JpZF0gPSAkZ2V0Tm9kZVRyaXBsZXQoYW5jaG9yKTtcbiAgY29uc3QgW2ZvY3VzQ2VsbF0gPSAkZ2V0Tm9kZVRyaXBsZXQoZm9jdXMpO1xuICBjb25zdCBbZ3JpZE1hcCwgYW5jaG9yQ2VsbE1hcCwgZm9jdXNDZWxsTWFwXSA9ICRjb21wdXRlVGFibGVNYXAoZ3JpZCwgYW5jaG9yQ2VsbCwgZm9jdXNDZWxsKTtcbiAgY29uc3Qge1xuICAgIHN0YXJ0Q29sdW1uOiBhbmNob3JTdGFydENvbHVtblxuICB9ID0gYW5jaG9yQ2VsbE1hcDtcbiAgY29uc3Qge1xuICAgIHN0YXJ0Um93OiBmb2N1c1N0YXJ0Um93LFxuICAgIHN0YXJ0Q29sdW1uOiBmb2N1c1N0YXJ0Q29sdW1uXG4gIH0gPSBmb2N1c0NlbGxNYXA7XG4gIGNvbnN0IHN0YXJ0Q29sdW1uID0gTWF0aC5taW4oYW5jaG9yU3RhcnRDb2x1bW4sIGZvY3VzU3RhcnRDb2x1bW4pO1xuICBjb25zdCBlbmRDb2x1bW4gPSBNYXRoLm1heChhbmNob3JTdGFydENvbHVtbiArIGFuY2hvckNlbGwuX19jb2xTcGFuIC0gMSwgZm9jdXNTdGFydENvbHVtbiArIGZvY3VzQ2VsbC5fX2NvbFNwYW4gLSAxKTtcbiAgY29uc3Qgc2VsZWN0ZWRDb2x1bW5Db3VudCA9IGVuZENvbHVtbiAtIHN0YXJ0Q29sdW1uICsgMTtcbiAgY29uc3QgY29sdW1uQ291bnQgPSBncmlkTWFwWzBdLmxlbmd0aDtcbiAgaWYgKGNvbHVtbkNvdW50ID09PSBlbmRDb2x1bW4gLSBzdGFydENvbHVtbiArIDEpIHtcbiAgICAvLyBFbXB0eSBncmlkXG4gICAgZ3JpZC5zZWxlY3RQcmV2aW91cygpO1xuICAgIGdyaWQucmVtb3ZlKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJvd0NvdW50ID0gZ3JpZE1hcC5sZW5ndGg7XG4gIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd0NvdW50OyByb3crKykge1xuICAgIGZvciAobGV0IGNvbHVtbiA9IHN0YXJ0Q29sdW1uOyBjb2x1bW4gPD0gZW5kQ29sdW1uOyBjb2x1bW4rKykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjZWxsLFxuICAgICAgICBzdGFydENvbHVtbjogY2VsbFN0YXJ0Q29sdW1uXG4gICAgICB9ID0gZ3JpZE1hcFtyb3ddW2NvbHVtbl07XG4gICAgICBpZiAoY2VsbFN0YXJ0Q29sdW1uIDwgc3RhcnRDb2x1bW4pIHtcbiAgICAgICAgaWYgKGNvbHVtbiA9PT0gc3RhcnRDb2x1bW4pIHtcbiAgICAgICAgICBjb25zdCBvdmVyZmxvd0xlZnQgPSBzdGFydENvbHVtbiAtIGNlbGxTdGFydENvbHVtbjtcbiAgICAgICAgICAvLyBPdmVyZmxvd2luZyBsZWZ0XG4gICAgICAgICAgY2VsbC5zZXRDb2xTcGFuKGNlbGwuX19jb2xTcGFuIC1cbiAgICAgICAgICAvLyBQb3NzaWJsZSBvdmVyZmxvdyByaWdodCB0b29cbiAgICAgICAgICBNYXRoLm1pbihzZWxlY3RlZENvbHVtbkNvdW50LCBjZWxsLl9fY29sU3BhbiAtIG92ZXJmbG93TGVmdCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNlbGxTdGFydENvbHVtbiArIGNlbGwuX19jb2xTcGFuIC0gMSA+IGVuZENvbHVtbikge1xuICAgICAgICBpZiAoY29sdW1uID09PSBlbmRDb2x1bW4pIHtcbiAgICAgICAgICAvLyBPdmVyZmxvd2luZyByaWdodFxuICAgICAgICAgIGNvbnN0IGluU2VsZWN0ZWRBcmVhID0gZW5kQ29sdW1uIC0gY2VsbFN0YXJ0Q29sdW1uICsgMTtcbiAgICAgICAgICBjZWxsLnNldENvbFNwYW4oY2VsbC5fX2NvbFNwYW4gLSBpblNlbGVjdGVkQXJlYSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNlbGwucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IGZvY3VzUm93TWFwID0gZ3JpZE1hcFtmb2N1c1N0YXJ0Um93XTtcbiAgY29uc3QgbmV4dENvbHVtbiA9IGFuY2hvclN0YXJ0Q29sdW1uID4gZm9jdXNTdGFydENvbHVtbiA/IGZvY3VzUm93TWFwW2FuY2hvclN0YXJ0Q29sdW1uICsgYW5jaG9yQ2VsbC5fX2NvbFNwYW5dIDogZm9jdXNSb3dNYXBbZm9jdXNTdGFydENvbHVtbiArIGZvY3VzQ2VsbC5fX2NvbFNwYW5dO1xuICBpZiAobmV4dENvbHVtbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3Qge1xuICAgICAgY2VsbFxuICAgIH0gPSBuZXh0Q29sdW1uO1xuICAgICRtb3ZlU2VsZWN0aW9uVG9DZWxsKGNlbGwpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHByZXZpb3VzUm93ID0gZm9jdXNTdGFydENvbHVtbiA8IGFuY2hvclN0YXJ0Q29sdW1uID8gZm9jdXNSb3dNYXBbZm9jdXNTdGFydENvbHVtbiAtIDFdIDogZm9jdXNSb3dNYXBbYW5jaG9yU3RhcnRDb2x1bW4gLSAxXTtcbiAgICBjb25zdCB7XG4gICAgICBjZWxsXG4gICAgfSA9IHByZXZpb3VzUm93O1xuICAgICRtb3ZlU2VsZWN0aW9uVG9DZWxsKGNlbGwpO1xuICB9XG4gIGNvbnN0IGNvbFdpZHRocyA9IGdyaWQuZ2V0Q29sV2lkdGhzKCk7XG4gIGlmIChjb2xXaWR0aHMpIHtcbiAgICBjb25zdCBuZXdDb2xXaWR0aHMgPSBbLi4uY29sV2lkdGhzXTtcbiAgICBuZXdDb2xXaWR0aHMuc3BsaWNlKHN0YXJ0Q29sdW1uLCBzZWxlY3RlZENvbHVtbkNvdW50KTtcbiAgICBncmlkLnNldENvbFdpZHRocyhuZXdDb2xXaWR0aHMpO1xuICB9XG59XG5mdW5jdGlvbiAkbW92ZVNlbGVjdGlvblRvQ2VsbChjZWxsKSB7XG4gIGNvbnN0IGZpcnN0RGVzY2VuZGFudCA9IGNlbGwuZ2V0Rmlyc3REZXNjZW5kYW50KCk7XG4gIGlmIChmaXJzdERlc2NlbmRhbnQgPT0gbnVsbCkge1xuICAgIGNlbGwuc2VsZWN0U3RhcnQoKTtcbiAgfSBlbHNlIHtcbiAgICBmaXJzdERlc2NlbmRhbnQuZ2V0UGFyZW50T3JUaHJvdygpLnNlbGVjdFN0YXJ0KCk7XG4gIH1cbn1cbmZ1bmN0aW9uICRpbnNlcnRGaXJzdChwYXJlbnQsIG5vZGUpIHtcbiAgY29uc3QgZmlyc3RDaGlsZCA9IHBhcmVudC5nZXRGaXJzdENoaWxkKCk7XG4gIGlmIChmaXJzdENoaWxkICE9PSBudWxsKSB7XG4gICAgZmlyc3RDaGlsZC5pbnNlcnRCZWZvcmUobm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50LmFwcGVuZChub2RlKTtcbiAgfVxufVxuZnVuY3Rpb24gJHVubWVyZ2VDZWxsKCkge1xuICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gIGlmICghKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkpIHtcbiAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgYSBSYW5nZVNlbGVjdGlvbiBvciBUYWJsZVNlbGVjdGlvbmApO1xuICB9XG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICBjb25zdCBbY2VsbCwgcm93LCBncmlkXSA9ICRnZXROb2RlVHJpcGxldChhbmNob3IpO1xuICBjb25zdCBjb2xTcGFuID0gY2VsbC5fX2NvbFNwYW47XG4gIGNvbnN0IHJvd1NwYW4gPSBjZWxsLl9fcm93U3BhbjtcbiAgaWYgKGNvbFNwYW4gPT09IDEgJiYgcm93U3BhbiA9PT0gMSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBbbWFwLCBjZWxsTWFwXSA9ICRjb21wdXRlVGFibGVNYXAoZ3JpZCwgY2VsbCwgY2VsbCk7XG4gIGNvbnN0IHtcbiAgICBzdGFydENvbHVtbixcbiAgICBzdGFydFJvd1xuICB9ID0gY2VsbE1hcDtcbiAgLy8gQ3JlYXRlIGEgaGV1cmlzdGljIGZvciB3aGF0IHRoZSBzdHlsZSBvZiB0aGUgdW5tZXJnZWQgY2VsbHMgc2hvdWxkIGJlXG4gIC8vIGJhc2VkIG9uIHdoZXRoZXIgZXZlcnkgcm93IG9yIGNvbHVtbiBhbHJlYWR5IGhhZCB0aGF0IHN0YXRlIGJlZm9yZSB0aGVcbiAgLy8gdW5tZXJnZS5cbiAgY29uc3QgYmFzZUNvbFN0eWxlID0gY2VsbC5fX2hlYWRlclN0YXRlICYgVGFibGVDZWxsSGVhZGVyU3RhdGVzLkNPTFVNTjtcbiAgY29uc3QgY29sU3R5bGVzID0gQXJyYXkuZnJvbSh7XG4gICAgbGVuZ3RoOiBjb2xTcGFuXG4gIH0sIChfdiwgaSkgPT4ge1xuICAgIGxldCBjb2xTdHlsZSA9IGJhc2VDb2xTdHlsZTtcbiAgICBmb3IgKGxldCByb3dJZHggPSAwOyBjb2xTdHlsZSAhPT0gMCAmJiByb3dJZHggPCBtYXAubGVuZ3RoOyByb3dJZHgrKykge1xuICAgICAgY29sU3R5bGUgJj0gbWFwW3Jvd0lkeF1baSArIHN0YXJ0Q29sdW1uXS5jZWxsLl9faGVhZGVyU3RhdGU7XG4gICAgfVxuICAgIHJldHVybiBjb2xTdHlsZTtcbiAgfSk7XG4gIGNvbnN0IGJhc2VSb3dTdHlsZSA9IGNlbGwuX19oZWFkZXJTdGF0ZSAmIFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5ST1c7XG4gIGNvbnN0IHJvd1N0eWxlcyA9IEFycmF5LmZyb20oe1xuICAgIGxlbmd0aDogcm93U3BhblxuICB9LCAoX3YsIGkpID0+IHtcbiAgICBsZXQgcm93U3R5bGUgPSBiYXNlUm93U3R5bGU7XG4gICAgZm9yIChsZXQgY29sSWR4ID0gMDsgcm93U3R5bGUgIT09IDAgJiYgY29sSWR4IDwgbWFwWzBdLmxlbmd0aDsgY29sSWR4KyspIHtcbiAgICAgIHJvd1N0eWxlICY9IG1hcFtpICsgc3RhcnRSb3ddW2NvbElkeF0uY2VsbC5fX2hlYWRlclN0YXRlO1xuICAgIH1cbiAgICByZXR1cm4gcm93U3R5bGU7XG4gIH0pO1xuICBpZiAoY29sU3BhbiA+IDEpIHtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGNvbFNwYW47IGkrKykge1xuICAgICAgY2VsbC5pbnNlcnRBZnRlcigkY3JlYXRlVGFibGVDZWxsTm9kZShjb2xTdHlsZXNbaV0gfCByb3dTdHlsZXNbMF0pLmFwcGVuZCgkY3JlYXRlUGFyYWdyYXBoTm9kZSgpKSk7XG4gICAgfVxuICAgIGNlbGwuc2V0Q29sU3BhbigxKTtcbiAgfVxuICBpZiAocm93U3BhbiA+IDEpIHtcbiAgICBsZXQgY3VycmVudFJvd05vZGU7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCByb3dTcGFuOyBpKyspIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRSb3cgPSBzdGFydFJvdyArIGk7XG4gICAgICBjb25zdCBjdXJyZW50Um93TWFwID0gbWFwW2N1cnJlbnRSb3ddO1xuICAgICAgY3VycmVudFJvd05vZGUgPSAoY3VycmVudFJvd05vZGUgfHwgcm93KS5nZXROZXh0U2libGluZygpO1xuICAgICAgaWYgKCEkaXNUYWJsZVJvd05vZGUoY3VycmVudFJvd05vZGUpKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCByb3cgbmV4dCBzaWJsaW5nIHRvIGJlIGEgcm93YCk7XG4gICAgICB9XG4gICAgICBsZXQgaW5zZXJ0QWZ0ZXJDZWxsID0gbnVsbDtcbiAgICAgIGZvciAobGV0IGNvbHVtbiA9IDA7IGNvbHVtbiA8IHN0YXJ0Q29sdW1uOyBjb2x1bW4rKykge1xuICAgICAgICBjb25zdCBjdXJyZW50Q2VsbE1hcCA9IGN1cnJlbnRSb3dNYXBbY29sdW1uXTtcbiAgICAgICAgY29uc3QgY3VycmVudENlbGwgPSBjdXJyZW50Q2VsbE1hcC5jZWxsO1xuICAgICAgICBpZiAoY3VycmVudENlbGxNYXAuc3RhcnRSb3cgPT09IGN1cnJlbnRSb3cpIHtcbiAgICAgICAgICBpbnNlcnRBZnRlckNlbGwgPSBjdXJyZW50Q2VsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudENlbGwuX19jb2xTcGFuID4gMSkge1xuICAgICAgICAgIGNvbHVtbiArPSBjdXJyZW50Q2VsbC5fX2NvbFNwYW4gLSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaW5zZXJ0QWZ0ZXJDZWxsID09PSBudWxsKSB7XG4gICAgICAgIGZvciAobGV0IGogPSBjb2xTcGFuIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAkaW5zZXJ0Rmlyc3QoY3VycmVudFJvd05vZGUsICRjcmVhdGVUYWJsZUNlbGxOb2RlKGNvbFN0eWxlc1tqXSB8IHJvd1N0eWxlc1tpXSkuYXBwZW5kKCRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IGNvbFNwYW4gLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgIGluc2VydEFmdGVyQ2VsbC5pbnNlcnRBZnRlcigkY3JlYXRlVGFibGVDZWxsTm9kZShjb2xTdHlsZXNbal0gfCByb3dTdHlsZXNbaV0pLmFwcGVuZCgkY3JlYXRlUGFyYWdyYXBoTm9kZSgpKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY2VsbC5zZXRSb3dTcGFuKDEpO1xuICB9XG59XG5mdW5jdGlvbiAkY29tcHV0ZVRhYmxlTWFwKGdyaWQsIGNlbGxBLCBjZWxsQikge1xuICBjb25zdCBbdGFibGVNYXAsIGNlbGxBVmFsdWUsIGNlbGxCVmFsdWVdID0gJGNvbXB1dGVUYWJsZU1hcFNraXBDZWxsQ2hlY2soZ3JpZCwgY2VsbEEsIGNlbGxCKTtcbiAgaWYgKCEoY2VsbEFWYWx1ZSAhPT0gbnVsbCkpIHtcbiAgICB0aHJvdyBFcnJvcihgQW5jaG9yIG5vdCBmb3VuZCBpbiBUYWJsZWApO1xuICB9XG4gIGlmICghKGNlbGxCVmFsdWUgIT09IG51bGwpKSB7XG4gICAgdGhyb3cgRXJyb3IoYEZvY3VzIG5vdCBmb3VuZCBpbiBUYWJsZWApO1xuICB9XG4gIHJldHVybiBbdGFibGVNYXAsIGNlbGxBVmFsdWUsIGNlbGxCVmFsdWVdO1xufVxuZnVuY3Rpb24gJGNvbXB1dGVUYWJsZU1hcFNraXBDZWxsQ2hlY2soZ3JpZCwgY2VsbEEsIGNlbGxCKSB7XG4gIGNvbnN0IHRhYmxlTWFwID0gW107XG4gIGxldCBjZWxsQVZhbHVlID0gbnVsbDtcbiAgbGV0IGNlbGxCVmFsdWUgPSBudWxsO1xuICBmdW5jdGlvbiBnZXRNYXBSb3coaSkge1xuICAgIGxldCByb3cgPSB0YWJsZU1hcFtpXTtcbiAgICBpZiAocm93ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhYmxlTWFwW2ldID0gcm93ID0gW107XG4gICAgfVxuICAgIHJldHVybiByb3c7XG4gIH1cbiAgY29uc3QgZ3JpZENoaWxkcmVuID0gZ3JpZC5nZXRDaGlsZHJlbigpO1xuICBmb3IgKGxldCByb3dJZHggPSAwOyByb3dJZHggPCBncmlkQ2hpbGRyZW4ubGVuZ3RoOyByb3dJZHgrKykge1xuICAgIGNvbnN0IHJvdyA9IGdyaWRDaGlsZHJlbltyb3dJZHhdO1xuICAgIGlmICghJGlzVGFibGVSb3dOb2RlKHJvdykpIHtcbiAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBUYWJsZU5vZGUgY2hpbGRyZW4gdG8gYmUgVGFibGVSb3dOb2RlYCk7XG4gICAgfVxuICAgIGZvciAobGV0IGNlbGwgPSByb3cuZ2V0Rmlyc3RDaGlsZCgpLCBjb2xJZHggPSAwOyBjZWxsICE9IG51bGw7IGNlbGwgPSBjZWxsLmdldE5leHRTaWJsaW5nKCkpIHtcbiAgICAgIGlmICghJGlzVGFibGVDZWxsTm9kZShjZWxsKSkge1xuICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgVGFibGVSb3dOb2RlIGNoaWxkcmVuIHRvIGJlIFRhYmxlQ2VsbE5vZGVgKTtcbiAgICAgIH0gLy8gU2tpcCBwYXN0IGFueSBjb2x1bW5zIHRoYXQgd2VyZSBtZXJnZWQgZnJvbSBhIGhpZ2hlciByb3dcbiAgICAgIGNvbnN0IHN0YXJ0TWFwUm93ID0gZ2V0TWFwUm93KHJvd0lkeCk7XG4gICAgICB3aGlsZSAoc3RhcnRNYXBSb3dbY29sSWR4XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbElkeCsrO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWUgPSB7XG4gICAgICAgIGNlbGwsXG4gICAgICAgIHN0YXJ0Q29sdW1uOiBjb2xJZHgsXG4gICAgICAgIHN0YXJ0Um93OiByb3dJZHhcbiAgICAgIH07XG4gICAgICBjb25zdCB7XG4gICAgICAgIF9fcm93U3Bhbjogcm93U3BhbixcbiAgICAgICAgX19jb2xTcGFuOiBjb2xTcGFuXG4gICAgICB9ID0gY2VsbDtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcm93U3BhbjsgaisrKSB7XG4gICAgICAgIGlmIChyb3dJZHggKyBqID49IGdyaWRDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBUaGUgdGFibGUgaXMgbm9uLXJlY3Rhbmd1bGFyIHdpdGggYSByb3dTcGFuXG4gICAgICAgICAgLy8gYmVsb3cgdGhlIGxhc3QgPHRyPiBpbiB0aGUgdGFibGUuXG4gICAgICAgICAgLy8gV2Ugc2hvdWxkIHByb2JhYmx5IGhhbmRsZSB0aGlzIHdpdGggYSBub2RlIHRyYW5zZm9ybVxuICAgICAgICAgIC8vIHRvIGVuc3VyZSB0aGF0IHRhYmxlcyBhcmUgYWx3YXlzIHJlY3Rhbmd1bGFyIGJ1dCB0aGlzXG4gICAgICAgICAgLy8gd2lsbCBhdm9pZCBjcmFzaGVzIHN1Y2ggYXMgIzY1ODRcbiAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhlcmUgYXJlIHByb2JhYmx5IHN0aWxsIGxhdGVudCBidWdzXG4gICAgICAgICAgLy8gcmVnYXJkaW5nIGNvbFNwYW4gb3IgZ2VuZXJhbCBjZWxsIGNvdW50IG1pc21hdGNoZXMuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWFwUm93ID0gZ2V0TWFwUm93KHJvd0lkeCArIGopO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbFNwYW47IGkrKykge1xuICAgICAgICAgIG1hcFJvd1tjb2xJZHggKyBpXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2VsbEEgIT09IG51bGwgJiYgY2VsbEFWYWx1ZSA9PT0gbnVsbCAmJiBjZWxsQS5pcyhjZWxsKSkge1xuICAgICAgICBjZWxsQVZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoY2VsbEIgIT09IG51bGwgJiYgY2VsbEJWYWx1ZSA9PT0gbnVsbCAmJiBjZWxsQi5pcyhjZWxsKSkge1xuICAgICAgICBjZWxsQlZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBbdGFibGVNYXAsIGNlbGxBVmFsdWUsIGNlbGxCVmFsdWVdO1xufVxuZnVuY3Rpb24gJGdldE5vZGVUcmlwbGV0KHNvdXJjZSkge1xuICBsZXQgY2VsbDtcbiAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIFRhYmxlQ2VsbE5vZGUpIHtcbiAgICBjZWxsID0gc291cmNlO1xuICB9IGVsc2UgaWYgKCdfX3R5cGUnIGluIHNvdXJjZSkge1xuICAgIGNvbnN0IGNlbGxfID0gJGZpbmRNYXRjaGluZ1BhcmVudChzb3VyY2UsICRpc1RhYmxlQ2VsbE5vZGUpO1xuICAgIGlmICghJGlzVGFibGVDZWxsTm9kZShjZWxsXykpIHtcbiAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCB0byBmaW5kIGEgcGFyZW50IFRhYmxlQ2VsbE5vZGVgKTtcbiAgICB9XG4gICAgY2VsbCA9IGNlbGxfO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNlbGxfID0gJGZpbmRNYXRjaGluZ1BhcmVudChzb3VyY2UuZ2V0Tm9kZSgpLCAkaXNUYWJsZUNlbGxOb2RlKTtcbiAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUoY2VsbF8pKSB7XG4gICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgdG8gZmluZCBhIHBhcmVudCBUYWJsZUNlbGxOb2RlYCk7XG4gICAgfVxuICAgIGNlbGwgPSBjZWxsXztcbiAgfVxuICBjb25zdCByb3cgPSBjZWxsLmdldFBhcmVudCgpO1xuICBpZiAoISRpc1RhYmxlUm93Tm9kZShyb3cpKSB7XG4gICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIFRhYmxlQ2VsbE5vZGUgdG8gaGF2ZSBhIHBhcmVudCBUYWJsZVJvd05vZGVgKTtcbiAgfVxuICBjb25zdCBncmlkID0gcm93LmdldFBhcmVudCgpO1xuICBpZiAoISRpc1RhYmxlTm9kZShncmlkKSkge1xuICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBUYWJsZVJvd05vZGUgdG8gaGF2ZSBhIHBhcmVudCBUYWJsZU5vZGVgKTtcbiAgfVxuICByZXR1cm4gW2NlbGwsIHJvdywgZ3JpZF07XG59XG5mdW5jdGlvbiAkZ2V0VGFibGVDZWxsTm9kZVJlY3QodGFibGVDZWxsTm9kZSkge1xuICBjb25zdCBbY2VsbE5vZGUsLCBncmlkTm9kZV0gPSAkZ2V0Tm9kZVRyaXBsZXQodGFibGVDZWxsTm9kZSk7XG4gIGNvbnN0IHJvd3MgPSBncmlkTm9kZS5nZXRDaGlsZHJlbigpO1xuICBjb25zdCByb3dDb3VudCA9IHJvd3MubGVuZ3RoO1xuICBjb25zdCBjb2x1bW5Db3VudCA9IHJvd3NbMF0uZ2V0Q2hpbGRyZW4oKS5sZW5ndGg7XG5cbiAgLy8gQ3JlYXRlIGEgbWF0cml4IG9mIHRoZSBzYW1lIHNpemUgYXMgdGhlIHRhYmxlIHRvIHRyYWNrIHRoZSBwb3NpdGlvbiBvZiBlYWNoIGNlbGxcbiAgY29uc3QgY2VsbE1hdHJpeCA9IG5ldyBBcnJheShyb3dDb3VudCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm93Q291bnQ7IGkrKykge1xuICAgIGNlbGxNYXRyaXhbaV0gPSBuZXcgQXJyYXkoY29sdW1uQ291bnQpO1xuICB9XG4gIGZvciAobGV0IHJvd0luZGV4ID0gMDsgcm93SW5kZXggPCByb3dDb3VudDsgcm93SW5kZXgrKykge1xuICAgIGNvbnN0IHJvdyA9IHJvd3Nbcm93SW5kZXhdO1xuICAgIGNvbnN0IGNlbGxzID0gcm93LmdldENoaWxkcmVuKCk7XG4gICAgbGV0IGNvbHVtbkluZGV4ID0gMDtcbiAgICBmb3IgKGxldCBjZWxsSW5kZXggPSAwOyBjZWxsSW5kZXggPCBjZWxscy5sZW5ndGg7IGNlbGxJbmRleCsrKSB7XG4gICAgICAvLyBGaW5kIHRoZSBuZXh0IGF2YWlsYWJsZSBwb3NpdGlvbiBpbiB0aGUgbWF0cml4LCBza2lwIHRoZSBwb3NpdGlvbiBvZiBtZXJnZWQgY2VsbHNcbiAgICAgIHdoaWxlIChjZWxsTWF0cml4W3Jvd0luZGV4XVtjb2x1bW5JbmRleF0pIHtcbiAgICAgICAgY29sdW1uSW5kZXgrKztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNlbGwgPSBjZWxsc1tjZWxsSW5kZXhdO1xuICAgICAgY29uc3Qgcm93U3BhbiA9IGNlbGwuX19yb3dTcGFuIHx8IDE7XG4gICAgICBjb25zdCBjb2xTcGFuID0gY2VsbC5fX2NvbFNwYW4gfHwgMTtcblxuICAgICAgLy8gUHV0IHRoZSBjZWxsIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgcG9zaXRpb24gaW4gdGhlIG1hdHJpeFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dTcGFuOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2xTcGFuOyBqKyspIHtcbiAgICAgICAgICBjZWxsTWF0cml4W3Jvd0luZGV4ICsgaV1bY29sdW1uSW5kZXggKyBqXSA9IGNlbGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIHRvIHRoZSBvcmlnaW5hbCBpbmRleCwgcm93IHNwYW4gYW5kIGNvbHVtbiBzcGFuIG9mIHRoZSBjZWxsLlxuICAgICAgaWYgKGNlbGxOb2RlID09PSBjZWxsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29sU3BhbixcbiAgICAgICAgICBjb2x1bW5JbmRleCxcbiAgICAgICAgICByb3dJbmRleCxcbiAgICAgICAgICByb3dTcGFuXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb2x1bW5JbmRleCArPSBjb2xTcGFuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jbGFzcyBUYWJsZVNlbGVjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKHRhYmxlS2V5LCBhbmNob3IsIGZvY3VzKSB7XG4gICAgdGhpcy5hbmNob3IgPSBhbmNob3I7XG4gICAgdGhpcy5mb2N1cyA9IGZvY3VzO1xuICAgIGFuY2hvci5fc2VsZWN0aW9uID0gdGhpcztcbiAgICBmb2N1cy5fc2VsZWN0aW9uID0gdGhpcztcbiAgICB0aGlzLl9jYWNoZWROb2RlcyA9IG51bGw7XG4gICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgIHRoaXMudGFibGVLZXkgPSB0YWJsZUtleTtcbiAgfVxuICBnZXRTdGFydEVuZFBvaW50cygpIHtcbiAgICByZXR1cm4gW3RoaXMuYW5jaG9yLCB0aGlzLmZvY3VzXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIFNlbGVjdGlvbiBpcyBcImJhY2t3YXJkc1wiLCBtZWFuaW5nIHRoZSBmb2N1c1xuICAgKiBsb2dpY2FsbHkgcHJlY2VkZXMgdGhlIGFuY2hvciBpbiB0aGUgRWRpdG9yU3RhdGUuXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIFNlbGVjdGlvbiBpcyBiYWNrd2FyZHMsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzQmFja3dhcmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9jdXMuaXNCZWZvcmUodGhpcy5hbmNob3IpO1xuICB9XG4gIGdldENhY2hlZE5vZGVzKCkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZWROb2RlcztcbiAgfVxuICBzZXRDYWNoZWROb2Rlcyhub2Rlcykge1xuICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbm9kZXM7XG4gIH1cbiAgaXMoc2VsZWN0aW9uKSB7XG4gICAgaWYgKCEkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRhYmxlS2V5ID09PSBzZWxlY3Rpb24udGFibGVLZXkgJiYgdGhpcy5hbmNob3IuaXMoc2VsZWN0aW9uLmFuY2hvcikgJiYgdGhpcy5mb2N1cy5pcyhzZWxlY3Rpb24uZm9jdXMpO1xuICB9XG4gIHNldCh0YWJsZUtleSwgYW5jaG9yQ2VsbEtleSwgZm9jdXNDZWxsS2V5KSB7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgdGhpcy50YWJsZUtleSA9IHRhYmxlS2V5O1xuICAgIHRoaXMuYW5jaG9yLmtleSA9IGFuY2hvckNlbGxLZXk7XG4gICAgdGhpcy5mb2N1cy5rZXkgPSBmb2N1c0NlbGxLZXk7XG4gICAgdGhpcy5fY2FjaGVkTm9kZXMgPSBudWxsO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgVGFibGVTZWxlY3Rpb24odGhpcy50YWJsZUtleSwgdGhpcy5hbmNob3IsIHRoaXMuZm9jdXMpO1xuICB9XG4gIGlzQ29sbGFwc2VkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBleHRyYWN0KCkge1xuICAgIHJldHVybiB0aGlzLmdldE5vZGVzKCk7XG4gIH1cbiAgaW5zZXJ0UmF3VGV4dCh0ZXh0KSB7XG4gICAgLy8gRG8gbm90aGluZz9cbiAgfVxuICBpbnNlcnRUZXh0KCkge1xuICAgIC8vIERvIG5vdGhpbmc/XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCBUZXh0Rm9ybWF0VHlwZSBpcyBwcmVzZW50IG9uIHRoZSBTZWxlY3Rpb24uXG4gICAqIFRoaXMgd2lsbCBiZSB0cnVlIGlmIGFueSBwYXJhZ3JhcGggaW4gdGFibGUgY2VsbHMgaGFzIHRoZSBzcGVjaWZpZWQgZm9ybWF0LlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSB0aGUgVGV4dEZvcm1hdFR5cGUgdG8gY2hlY2sgZm9yLlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBmb3JtYXQgaXMgY3VycmVudGx5IHRvZ2dsZWQgb24gb24gdGhlIFNlbGVjdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaGFzRm9ybWF0KHR5cGUpIHtcbiAgICBsZXQgZm9ybWF0ID0gMDtcbiAgICBjb25zdCBjZWxsTm9kZXMgPSB0aGlzLmdldE5vZGVzKCkuZmlsdGVyKCRpc1RhYmxlQ2VsbE5vZGUpO1xuICAgIGNlbGxOb2Rlcy5mb3JFYWNoKGNlbGxOb2RlID0+IHtcbiAgICAgIGNvbnN0IHBhcmFncmFwaCA9IGNlbGxOb2RlLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgIGlmICgkaXNQYXJhZ3JhcGhOb2RlKHBhcmFncmFwaCkpIHtcbiAgICAgICAgZm9ybWF0IHw9IHBhcmFncmFwaC5nZXRUZXh0Rm9ybWF0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgZm9ybWF0RmxhZyA9IFRFWFRfVFlQRV9UT19GT1JNQVRbdHlwZV07XG4gICAgcmV0dXJuIChmb3JtYXQgJiBmb3JtYXRGbGFnKSAhPT0gMDtcbiAgfVxuICBpbnNlcnROb2Rlcyhub2Rlcykge1xuICAgIGNvbnN0IGZvY3VzTm9kZSA9IHRoaXMuZm9jdXMuZ2V0Tm9kZSgpO1xuICAgIGlmICghJGlzRWxlbWVudE5vZGUoZm9jdXNOb2RlKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIFRhYmxlU2VsZWN0aW9uIGZvY3VzIHRvIGJlIGFuIEVsZW1lbnROb2RlYCk7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRub3JtYWxpemVTZWxlY3Rpb25fX0VYUEVSSU1FTlRBTChmb2N1c05vZGUuc2VsZWN0KDAsIGZvY3VzTm9kZS5nZXRDaGlsZHJlblNpemUoKSkpO1xuICAgIHNlbGVjdGlvbi5pbnNlcnROb2Rlcyhub2Rlcyk7XG4gIH1cblxuICAvLyBUT0RPIERlcHJlY2F0ZSB0aGlzIG1ldGhvZC4gSXQncyBjb25mdXNpbmcgd2hlbiB1c2VkIHdpdGggY29sc3Bhbnxyb3dzcGFuXG4gIGdldFNoYXBlKCkge1xuICAgIGNvbnN0IGFuY2hvckNlbGxOb2RlID0gJGdldE5vZGVCeUtleSh0aGlzLmFuY2hvci5rZXkpO1xuICAgIGlmICghJGlzVGFibGVDZWxsTm9kZShhbmNob3JDZWxsTm9kZSkpIHtcbiAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBUYWJsZVNlbGVjdGlvbiBhbmNob3IgdG8gYmUgKG9yIGEgY2hpbGQgb2YpIFRhYmxlQ2VsbE5vZGVgKTtcbiAgICB9XG4gICAgY29uc3QgYW5jaG9yQ2VsbE5vZGVSZWN0ID0gJGdldFRhYmxlQ2VsbE5vZGVSZWN0KGFuY2hvckNlbGxOb2RlKTtcbiAgICBpZiAoIShhbmNob3JDZWxsTm9kZVJlY3QgIT09IG51bGwpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgZ2V0Q2VsbFJlY3Q6IGV4cGVjdGVkIHRvIGZpbmQgQW5jaG9yTm9kZWApO1xuICAgIH1cbiAgICBjb25zdCBmb2N1c0NlbGxOb2RlID0gJGdldE5vZGVCeUtleSh0aGlzLmZvY3VzLmtleSk7XG4gICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKGZvY3VzQ2VsbE5vZGUpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgVGFibGVTZWxlY3Rpb24gZm9jdXMgdG8gYmUgKG9yIGEgY2hpbGQgb2YpIFRhYmxlQ2VsbE5vZGVgKTtcbiAgICB9XG4gICAgY29uc3QgZm9jdXNDZWxsTm9kZVJlY3QgPSAkZ2V0VGFibGVDZWxsTm9kZVJlY3QoZm9jdXNDZWxsTm9kZSk7XG4gICAgaWYgKCEoZm9jdXNDZWxsTm9kZVJlY3QgIT09IG51bGwpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgZ2V0Q2VsbFJlY3Q6IGV4cGVjdGVkIHRvIGZpbmQgZm9jdXNDZWxsTm9kZWApO1xuICAgIH1cbiAgICBjb25zdCBzdGFydFggPSBNYXRoLm1pbihhbmNob3JDZWxsTm9kZVJlY3QuY29sdW1uSW5kZXgsIGZvY3VzQ2VsbE5vZGVSZWN0LmNvbHVtbkluZGV4KTtcbiAgICBjb25zdCBzdG9wWCA9IE1hdGgubWF4KGFuY2hvckNlbGxOb2RlUmVjdC5jb2x1bW5JbmRleCArIGFuY2hvckNlbGxOb2RlUmVjdC5jb2xTcGFuIC0gMSwgZm9jdXNDZWxsTm9kZVJlY3QuY29sdW1uSW5kZXggKyBmb2N1c0NlbGxOb2RlUmVjdC5jb2xTcGFuIC0gMSk7XG4gICAgY29uc3Qgc3RhcnRZID0gTWF0aC5taW4oYW5jaG9yQ2VsbE5vZGVSZWN0LnJvd0luZGV4LCBmb2N1c0NlbGxOb2RlUmVjdC5yb3dJbmRleCk7XG4gICAgY29uc3Qgc3RvcFkgPSBNYXRoLm1heChhbmNob3JDZWxsTm9kZVJlY3Qucm93SW5kZXggKyBhbmNob3JDZWxsTm9kZVJlY3Qucm93U3BhbiAtIDEsIGZvY3VzQ2VsbE5vZGVSZWN0LnJvd0luZGV4ICsgZm9jdXNDZWxsTm9kZVJlY3Qucm93U3BhbiAtIDEpO1xuICAgIHJldHVybiB7XG4gICAgICBmcm9tWDogTWF0aC5taW4oc3RhcnRYLCBzdG9wWCksXG4gICAgICBmcm9tWTogTWF0aC5taW4oc3RhcnRZLCBzdG9wWSksXG4gICAgICB0b1g6IE1hdGgubWF4KHN0YXJ0WCwgc3RvcFgpLFxuICAgICAgdG9ZOiBNYXRoLm1heChzdGFydFksIHN0b3BZKVxuICAgIH07XG4gIH1cbiAgZ2V0Tm9kZXMoKSB7XG4gICAgY29uc3QgY2FjaGVkTm9kZXMgPSB0aGlzLl9jYWNoZWROb2RlcztcbiAgICBpZiAoY2FjaGVkTm9kZXMgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBjYWNoZWROb2RlcztcbiAgICB9XG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IHRoaXMuYW5jaG9yLmdldE5vZGUoKTtcbiAgICBjb25zdCBmb2N1c05vZGUgPSB0aGlzLmZvY3VzLmdldE5vZGUoKTtcbiAgICBjb25zdCBhbmNob3JDZWxsID0gJGZpbmRNYXRjaGluZ1BhcmVudChhbmNob3JOb2RlLCAkaXNUYWJsZUNlbGxOb2RlKTtcbiAgICAvLyB0b2RvIHJlcGxhY2Ugd2l0aCB0cmlwbGV0XG4gICAgY29uc3QgZm9jdXNDZWxsID0gJGZpbmRNYXRjaGluZ1BhcmVudChmb2N1c05vZGUsICRpc1RhYmxlQ2VsbE5vZGUpO1xuICAgIGlmICghJGlzVGFibGVDZWxsTm9kZShhbmNob3JDZWxsKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIFRhYmxlU2VsZWN0aW9uIGFuY2hvciB0byBiZSAob3IgYSBjaGlsZCBvZikgVGFibGVDZWxsTm9kZWApO1xuICAgIH1cbiAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUoZm9jdXNDZWxsKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIFRhYmxlU2VsZWN0aW9uIGZvY3VzIHRvIGJlIChvciBhIGNoaWxkIG9mKSBUYWJsZUNlbGxOb2RlYCk7XG4gICAgfVxuICAgIGNvbnN0IGFuY2hvclJvdyA9IGFuY2hvckNlbGwuZ2V0UGFyZW50KCk7XG4gICAgaWYgKCEkaXNUYWJsZVJvd05vZGUoYW5jaG9yUm93KSkge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIGFuY2hvckNlbGwgdG8gaGF2ZSBhIHBhcmVudCBUYWJsZVJvd05vZGVgKTtcbiAgICB9XG4gICAgY29uc3QgdGFibGVOb2RlID0gYW5jaG9yUm93LmdldFBhcmVudCgpO1xuICAgIGlmICghJGlzVGFibGVOb2RlKHRhYmxlTm9kZSkpIHtcbiAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCB0YWJsZU5vZGUgdG8gaGF2ZSBhIHBhcmVudCBUYWJsZU5vZGVgKTtcbiAgICB9XG4gICAgY29uc3QgZm9jdXNDZWxsR3JpZCA9IGZvY3VzQ2VsbC5nZXRQYXJlbnRzKClbMV07XG4gICAgaWYgKGZvY3VzQ2VsbEdyaWQgIT09IHRhYmxlTm9kZSkge1xuICAgICAgaWYgKCF0YWJsZU5vZGUuaXNQYXJlbnRPZihmb2N1c0NlbGwpKSB7XG4gICAgICAgIC8vIGZvY3VzIGlzIG9uIGhpZ2hlciBHcmlkIGxldmVsIHRoYW4gYW5jaG9yXG4gICAgICAgIGNvbnN0IGdyaWRQYXJlbnQgPSB0YWJsZU5vZGUuZ2V0UGFyZW50KCk7XG4gICAgICAgIGlmICghKGdyaWRQYXJlbnQgIT0gbnVsbCkpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgZ3JpZFBhcmVudCB0byBoYXZlIGEgcGFyZW50YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXQodGhpcy50YWJsZUtleSwgZ3JpZFBhcmVudC5nZXRLZXkoKSwgZm9jdXNDZWxsLmdldEtleSgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGFuY2hvciBpcyBvbiBoaWdoZXIgR3JpZCBsZXZlbCB0aGFuIGZvY3VzXG4gICAgICAgIGNvbnN0IGZvY3VzQ2VsbFBhcmVudCA9IGZvY3VzQ2VsbEdyaWQuZ2V0UGFyZW50KCk7XG4gICAgICAgIGlmICghKGZvY3VzQ2VsbFBhcmVudCAhPSBudWxsKSkge1xuICAgICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBmb2N1c0NlbGxQYXJlbnQgdG8gaGF2ZSBhIHBhcmVudGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0KHRoaXMudGFibGVLZXksIGZvY3VzQ2VsbC5nZXRLZXkoKSwgZm9jdXNDZWxsUGFyZW50LmdldEtleSgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmdldE5vZGVzKCk7XG4gICAgfVxuXG4gICAgLy8gVE9ETyBNYXBwaW5nIHRoZSB3aG9sZSBHcmlkIGV2ZXJ5IHRpbWUgbm90IGVmZmljaWVudC4gV2UgbmVlZCB0byBjb21wdXRlIHRoZSBlbnRpcmUgc3RhdGUgb25seVxuICAgIC8vIG9uY2UgKG9uIGxvYWQpIGFuZCBpdGVyYXRlIG9uIGl0IGFzIHVwZGF0ZXMgb2NjdXIuIEhvd2V2ZXIsIHRvIGRvIHRoaXMgd2UgbmVlZCB0byBoYXZlIHRoZVxuICAgIC8vIGFiaWxpdHkgdG8gc3RvcmUgYSBzdGF0ZS4gS2lsbGluZyBUYWJsZVNlbGVjdGlvbiBhbmQgbW92aW5nIHRoZSBsb2dpYyB0byB0aGUgcGx1Z2luIHdvdWxkIG1ha2VcbiAgICAvLyB0aGlzIHBvc3NpYmxlLlxuICAgIGNvbnN0IFttYXAsIGNlbGxBTWFwLCBjZWxsQk1hcF0gPSAkY29tcHV0ZVRhYmxlTWFwKHRhYmxlTm9kZSwgYW5jaG9yQ2VsbCwgZm9jdXNDZWxsKTtcbiAgICBsZXQgbWluQ29sdW1uID0gTWF0aC5taW4oY2VsbEFNYXAuc3RhcnRDb2x1bW4sIGNlbGxCTWFwLnN0YXJ0Q29sdW1uKTtcbiAgICBsZXQgbWluUm93ID0gTWF0aC5taW4oY2VsbEFNYXAuc3RhcnRSb3csIGNlbGxCTWFwLnN0YXJ0Um93KTtcbiAgICBsZXQgbWF4Q29sdW1uID0gTWF0aC5tYXgoY2VsbEFNYXAuc3RhcnRDb2x1bW4gKyBjZWxsQU1hcC5jZWxsLl9fY29sU3BhbiAtIDEsIGNlbGxCTWFwLnN0YXJ0Q29sdW1uICsgY2VsbEJNYXAuY2VsbC5fX2NvbFNwYW4gLSAxKTtcbiAgICBsZXQgbWF4Um93ID0gTWF0aC5tYXgoY2VsbEFNYXAuc3RhcnRSb3cgKyBjZWxsQU1hcC5jZWxsLl9fcm93U3BhbiAtIDEsIGNlbGxCTWFwLnN0YXJ0Um93ICsgY2VsbEJNYXAuY2VsbC5fX3Jvd1NwYW4gLSAxKTtcbiAgICBsZXQgZXhwbG9yZWRNaW5Db2x1bW4gPSBtaW5Db2x1bW47XG4gICAgbGV0IGV4cGxvcmVkTWluUm93ID0gbWluUm93O1xuICAgIGxldCBleHBsb3JlZE1heENvbHVtbiA9IG1pbkNvbHVtbjtcbiAgICBsZXQgZXhwbG9yZWRNYXhSb3cgPSBtaW5Sb3c7XG4gICAgZnVuY3Rpb24gZXhwYW5kQm91bmRhcnkobWFwVmFsdWUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2VsbCxcbiAgICAgICAgc3RhcnRDb2x1bW46IGNlbGxTdGFydENvbHVtbixcbiAgICAgICAgc3RhcnRSb3c6IGNlbGxTdGFydFJvd1xuICAgICAgfSA9IG1hcFZhbHVlO1xuICAgICAgbWluQ29sdW1uID0gTWF0aC5taW4obWluQ29sdW1uLCBjZWxsU3RhcnRDb2x1bW4pO1xuICAgICAgbWluUm93ID0gTWF0aC5taW4obWluUm93LCBjZWxsU3RhcnRSb3cpO1xuICAgICAgbWF4Q29sdW1uID0gTWF0aC5tYXgobWF4Q29sdW1uLCBjZWxsU3RhcnRDb2x1bW4gKyBjZWxsLl9fY29sU3BhbiAtIDEpO1xuICAgICAgbWF4Um93ID0gTWF0aC5tYXgobWF4Um93LCBjZWxsU3RhcnRSb3cgKyBjZWxsLl9fcm93U3BhbiAtIDEpO1xuICAgIH1cbiAgICB3aGlsZSAobWluQ29sdW1uIDwgZXhwbG9yZWRNaW5Db2x1bW4gfHwgbWluUm93IDwgZXhwbG9yZWRNaW5Sb3cgfHwgbWF4Q29sdW1uID4gZXhwbG9yZWRNYXhDb2x1bW4gfHwgbWF4Um93ID4gZXhwbG9yZWRNYXhSb3cpIHtcbiAgICAgIGlmIChtaW5Db2x1bW4gPCBleHBsb3JlZE1pbkNvbHVtbikge1xuICAgICAgICAvLyBFeHBhbmQgb24gdGhlIGxlZnRcbiAgICAgICAgY29uc3Qgcm93RGlmZiA9IGV4cGxvcmVkTWF4Um93IC0gZXhwbG9yZWRNaW5Sb3c7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzQ29sdW1uID0gZXhwbG9yZWRNaW5Db2x1bW4gLSAxO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSByb3dEaWZmOyBpKyspIHtcbiAgICAgICAgICBleHBhbmRCb3VuZGFyeShtYXBbZXhwbG9yZWRNaW5Sb3cgKyBpXVtwcmV2aW91c0NvbHVtbl0pO1xuICAgICAgICB9XG4gICAgICAgIGV4cGxvcmVkTWluQ29sdW1uID0gcHJldmlvdXNDb2x1bW47XG4gICAgICB9XG4gICAgICBpZiAobWluUm93IDwgZXhwbG9yZWRNaW5Sb3cpIHtcbiAgICAgICAgLy8gRXhwYW5kIG9uIHRvcFxuICAgICAgICBjb25zdCBjb2x1bW5EaWZmID0gZXhwbG9yZWRNYXhDb2x1bW4gLSBleHBsb3JlZE1pbkNvbHVtbjtcbiAgICAgICAgY29uc3QgcHJldmlvdXNSb3cgPSBleHBsb3JlZE1pblJvdyAtIDE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGNvbHVtbkRpZmY7IGkrKykge1xuICAgICAgICAgIGV4cGFuZEJvdW5kYXJ5KG1hcFtwcmV2aW91c1Jvd11bZXhwbG9yZWRNaW5Db2x1bW4gKyBpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwbG9yZWRNaW5Sb3cgPSBwcmV2aW91c1JvdztcbiAgICAgIH1cbiAgICAgIGlmIChtYXhDb2x1bW4gPiBleHBsb3JlZE1heENvbHVtbikge1xuICAgICAgICAvLyBFeHBhbmQgb24gdGhlIHJpZ2h0XG4gICAgICAgIGNvbnN0IHJvd0RpZmYgPSBleHBsb3JlZE1heFJvdyAtIGV4cGxvcmVkTWluUm93O1xuICAgICAgICBjb25zdCBuZXh0Q29sdW1uID0gZXhwbG9yZWRNYXhDb2x1bW4gKyAxO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSByb3dEaWZmOyBpKyspIHtcbiAgICAgICAgICBleHBhbmRCb3VuZGFyeShtYXBbZXhwbG9yZWRNaW5Sb3cgKyBpXVtuZXh0Q29sdW1uXSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwbG9yZWRNYXhDb2x1bW4gPSBuZXh0Q29sdW1uO1xuICAgICAgfVxuICAgICAgaWYgKG1heFJvdyA+IGV4cGxvcmVkTWF4Um93KSB7XG4gICAgICAgIC8vIEV4cGFuZCBvbiB0aGUgYm90dG9tXG4gICAgICAgIGNvbnN0IGNvbHVtbkRpZmYgPSBleHBsb3JlZE1heENvbHVtbiAtIGV4cGxvcmVkTWluQ29sdW1uO1xuICAgICAgICBjb25zdCBuZXh0Um93ID0gZXhwbG9yZWRNYXhSb3cgKyAxO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBjb2x1bW5EaWZmOyBpKyspIHtcbiAgICAgICAgICBleHBhbmRCb3VuZGFyeShtYXBbbmV4dFJvd11bZXhwbG9yZWRNaW5Db2x1bW4gKyBpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwbG9yZWRNYXhSb3cgPSBuZXh0Um93O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdlIHVzZSBhIE1hcCBoZXJlIGJlY2F1c2UgbWVyZ2VkIGNlbGxzIGluIHRoZSBncmlkIHdvdWxkIG90aGVyd2lzZVxuICAgIC8vIHNob3cgdXAgbXVsdGlwbGUgdGltZXMgaW4gdGhlIG5vZGVzIGFycmF5XG4gICAgY29uc3Qgbm9kZU1hcCA9IG5ldyBNYXAoW1t0YWJsZU5vZGUuZ2V0S2V5KCksIHRhYmxlTm9kZV1dKTtcbiAgICBsZXQgbGFzdFJvdyA9IG51bGw7XG4gICAgZm9yIChsZXQgaSA9IG1pblJvdzsgaSA8PSBtYXhSb3c7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IG1pbkNvbHVtbjsgaiA8PSBtYXhDb2x1bW47IGorKykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgY2VsbFxuICAgICAgICB9ID0gbWFwW2ldW2pdO1xuICAgICAgICBjb25zdCBjdXJyZW50Um93ID0gY2VsbC5nZXRQYXJlbnQoKTtcbiAgICAgICAgaWYgKCEkaXNUYWJsZVJvd05vZGUoY3VycmVudFJvdykpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgVGFibGVDZWxsTm9kZSBwYXJlbnQgdG8gYmUgYSBUYWJsZVJvd05vZGVgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudFJvdyAhPT0gbGFzdFJvdykge1xuICAgICAgICAgIG5vZGVNYXAuc2V0KGN1cnJlbnRSb3cuZ2V0S2V5KCksIGN1cnJlbnRSb3cpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGVNYXAuc2V0KGNlbGwuZ2V0S2V5KCksIGNlbGwpO1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mICRnZXRDaGlsZHJlblJlY3Vyc2l2ZWx5KGNlbGwpKSB7XG4gICAgICAgICAgbm9kZU1hcC5zZXQoY2hpbGQuZ2V0S2V5KCksIGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0Um93ID0gY3VycmVudFJvdztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgbm9kZXMgPSBBcnJheS5mcm9tKG5vZGVNYXAudmFsdWVzKCkpO1xuICAgIGlmICghaXNDdXJyZW50bHlSZWFkT25seU1vZGUoKSkge1xuICAgICAgdGhpcy5fY2FjaGVkTm9kZXMgPSBub2RlcztcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzO1xuICB9XG4gIGdldFRleHRDb250ZW50KCkge1xuICAgIGNvbnN0IG5vZGVzID0gdGhpcy5nZXROb2RlcygpLmZpbHRlcihub2RlID0+ICRpc1RhYmxlQ2VsbE5vZGUobm9kZSkpO1xuICAgIGxldCB0ZXh0Q29udGVudCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIGNvbnN0IHJvdyA9IG5vZGUuX19wYXJlbnQ7XG4gICAgICBjb25zdCBuZXh0Um93ID0gKG5vZGVzW2kgKyAxXSB8fCB7fSkuX19wYXJlbnQ7XG4gICAgICB0ZXh0Q29udGVudCArPSBub2RlLmdldFRleHRDb250ZW50KCkgKyAobmV4dFJvdyAhPT0gcm93ID8gJ1xcbicgOiAnXFx0Jyk7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0Q29udGVudDtcbiAgfVxufVxuZnVuY3Rpb24gJGlzVGFibGVTZWxlY3Rpb24oeCkge1xuICByZXR1cm4geCBpbnN0YW5jZW9mIFRhYmxlU2VsZWN0aW9uO1xufVxuZnVuY3Rpb24gJGNyZWF0ZVRhYmxlU2VsZWN0aW9uKCkge1xuICBjb25zdCBhbmNob3IgPSAkY3JlYXRlUG9pbnQoJ3Jvb3QnLCAwLCAnZWxlbWVudCcpO1xuICBjb25zdCBmb2N1cyA9ICRjcmVhdGVQb2ludCgncm9vdCcsIDAsICdlbGVtZW50Jyk7XG4gIHJldHVybiBuZXcgVGFibGVTZWxlY3Rpb24oJ3Jvb3QnLCBhbmNob3IsIGZvY3VzKTtcbn1cbmZ1bmN0aW9uICRnZXRDaGlsZHJlblJlY3Vyc2l2ZWx5KG5vZGUpIHtcbiAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgY29uc3Qgc3RhY2sgPSBbbm9kZV07XG4gIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgY3VycmVudE5vZGUgPSBzdGFjay5wb3AoKTtcbiAgICBpZiAoIShjdXJyZW50Tm9kZSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYFN0YWNrLmxlbmd0aCA+IDA7IGNhbid0IGJlIHVuZGVmaW5lZGApO1xuICAgIH1cbiAgICBpZiAoJGlzRWxlbWVudE5vZGUoY3VycmVudE5vZGUpKSB7XG4gICAgICBzdGFjay51bnNoaWZ0KC4uLmN1cnJlbnROb2RlLmdldENoaWxkcmVuKCkpO1xuICAgIH1cbiAgICBpZiAoY3VycmVudE5vZGUgIT09IG5vZGUpIHtcbiAgICAgIG5vZGVzLnB1c2goY3VycmVudE5vZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9kZXM7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY2xhc3MgVGFibGVPYnNlcnZlciB7XG4gIGNvbnN0cnVjdG9yKGVkaXRvciwgdGFibGVOb2RlS2V5KSB7XG4gICAgdGhpcy5pc0hpZ2hsaWdodGluZ0NlbGxzID0gZmFsc2U7XG4gICAgdGhpcy5hbmNob3JYID0gLTE7XG4gICAgdGhpcy5hbmNob3JZID0gLTE7XG4gICAgdGhpcy5mb2N1c1ggPSAtMTtcbiAgICB0aGlzLmZvY3VzWSA9IC0xO1xuICAgIHRoaXMubGlzdGVuZXJzVG9SZW1vdmUgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy50YWJsZU5vZGVLZXkgPSB0YWJsZU5vZGVLZXk7XG4gICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgdGhpcy50YWJsZSA9IHtcbiAgICAgIGNvbHVtbnM6IDAsXG4gICAgICBkb21Sb3dzOiBbXSxcbiAgICAgIHJvd3M6IDBcbiAgICB9O1xuICAgIHRoaXMudGFibGVTZWxlY3Rpb24gPSBudWxsO1xuICAgIHRoaXMuYW5jaG9yQ2VsbE5vZGVLZXkgPSBudWxsO1xuICAgIHRoaXMuZm9jdXNDZWxsTm9kZUtleSA9IG51bGw7XG4gICAgdGhpcy5hbmNob3JDZWxsID0gbnVsbDtcbiAgICB0aGlzLmZvY3VzQ2VsbCA9IG51bGw7XG4gICAgdGhpcy5oYXNIaWphY2tlZFNlbGVjdGlvblN0eWxlcyA9IGZhbHNlO1xuICAgIHRoaXMudHJhY2tUYWJsZSgpO1xuICAgIHRoaXMuaXNTZWxlY3RpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICB0aGlzLmxpc3RlbmVyT3B0aW9ucyA9IHtcbiAgICAgIHNpZ25hbDogdGhpcy5hYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgfTtcbiAgfVxuICBnZXRUYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWJsZTtcbiAgfVxuICByZW1vdmVMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5hYm9ydENvbnRyb2xsZXIuYWJvcnQoJ3JlbW92ZUxpc3RlbmVycycpO1xuICAgIEFycmF5LmZyb20odGhpcy5saXN0ZW5lcnNUb1JlbW92ZSkuZm9yRWFjaChyZW1vdmVMaXN0ZW5lciA9PiByZW1vdmVMaXN0ZW5lcigpKTtcbiAgICB0aGlzLmxpc3RlbmVyc1RvUmVtb3ZlLmNsZWFyKCk7XG4gIH1cbiAgdHJhY2tUYWJsZSgpIHtcbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHJlY29yZHMgPT4ge1xuICAgICAgdGhpcy5lZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgICAgbGV0IGdyaWROZWVkc1JlZHJhdyA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCByZWNvcmQgPSByZWNvcmRzW2ldO1xuICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHJlY29yZC50YXJnZXQ7XG4gICAgICAgICAgY29uc3Qgbm9kZU5hbWUgPSB0YXJnZXQubm9kZU5hbWU7XG4gICAgICAgICAgaWYgKG5vZGVOYW1lID09PSAnVEFCTEUnIHx8IG5vZGVOYW1lID09PSAnVEJPRFknIHx8IG5vZGVOYW1lID09PSAnVEhFQUQnIHx8IG5vZGVOYW1lID09PSAnVFInKSB7XG4gICAgICAgICAgICBncmlkTmVlZHNSZWRyYXcgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZ3JpZE5lZWRzUmVkcmF3KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhYmxlRWxlbWVudCA9IHRoaXMuZWRpdG9yLmdldEVsZW1lbnRCeUtleSh0aGlzLnRhYmxlTm9kZUtleSk7XG4gICAgICAgIGlmICghdGFibGVFbGVtZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBmaW5kIFRhYmxlRWxlbWVudCBpbiBET00nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRhYmxlID0gZ2V0VGFibGUodGFibGVFbGVtZW50KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICBjb25zdCB0YWJsZUVsZW1lbnQgPSB0aGlzLmVkaXRvci5nZXRFbGVtZW50QnlLZXkodGhpcy50YWJsZU5vZGVLZXkpO1xuICAgICAgaWYgKCF0YWJsZUVsZW1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBmaW5kIFRhYmxlRWxlbWVudCBpbiBET00nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGFibGUgPSBnZXRUYWJsZSh0YWJsZUVsZW1lbnQpO1xuICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0YWJsZUVsZW1lbnQsIHtcbiAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICBzdWJ0cmVlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBjbGVhckhpZ2hsaWdodCgpIHtcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLmVkaXRvcjtcbiAgICB0aGlzLmlzSGlnaGxpZ2h0aW5nQ2VsbHMgPSBmYWxzZTtcbiAgICB0aGlzLmFuY2hvclggPSAtMTtcbiAgICB0aGlzLmFuY2hvclkgPSAtMTtcbiAgICB0aGlzLmZvY3VzWCA9IC0xO1xuICAgIHRoaXMuZm9jdXNZID0gLTE7XG4gICAgdGhpcy50YWJsZVNlbGVjdGlvbiA9IG51bGw7XG4gICAgdGhpcy5hbmNob3JDZWxsTm9kZUtleSA9IG51bGw7XG4gICAgdGhpcy5mb2N1c0NlbGxOb2RlS2V5ID0gbnVsbDtcbiAgICB0aGlzLmFuY2hvckNlbGwgPSBudWxsO1xuICAgIHRoaXMuZm9jdXNDZWxsID0gbnVsbDtcbiAgICB0aGlzLmhhc0hpamFja2VkU2VsZWN0aW9uU3R5bGVzID0gZmFsc2U7XG4gICAgdGhpcy5lbmFibGVIaWdobGlnaHRTdHlsZSgpO1xuICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgY29uc3QgdGFibGVOb2RlID0gJGdldE5vZGVCeUtleSh0aGlzLnRhYmxlTm9kZUtleSk7XG4gICAgICBpZiAoISRpc1RhYmxlTm9kZSh0YWJsZU5vZGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgVGFibGVOb2RlLicpO1xuICAgICAgfVxuICAgICAgY29uc3QgdGFibGVFbGVtZW50ID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleSh0aGlzLnRhYmxlTm9kZUtleSk7XG4gICAgICBpZiAoIXRhYmxlRWxlbWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgVGFibGVFbGVtZW50IGluIERPTScpO1xuICAgICAgfVxuICAgICAgY29uc3QgZ3JpZCA9IGdldFRhYmxlKHRhYmxlRWxlbWVudCk7XG4gICAgICAkdXBkYXRlRE9NRm9yU2VsZWN0aW9uKGVkaXRvciwgZ3JpZCwgbnVsbCk7XG4gICAgICAkc2V0U2VsZWN0aW9uKG51bGwpO1xuICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChTRUxFQ1RJT05fQ0hBTkdFX0NPTU1BTkQsIHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gIH1cbiAgZW5hYmxlSGlnaGxpZ2h0U3R5bGUoKSB7XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICBjb25zdCB0YWJsZUVsZW1lbnQgPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KHRoaXMudGFibGVOb2RlS2V5KTtcbiAgICAgIGlmICghdGFibGVFbGVtZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gZmluZCBUYWJsZUVsZW1lbnQgaW4gRE9NJyk7XG4gICAgICB9XG4gICAgICByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQodGFibGVFbGVtZW50LCBlZGl0b3IuX2NvbmZpZy50aGVtZS50YWJsZVNlbGVjdGlvbik7XG4gICAgICB0YWJsZUVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnZGlzYWJsZS1zZWxlY3Rpb24nKTtcbiAgICAgIHRoaXMuaGFzSGlqYWNrZWRTZWxlY3Rpb25TdHlsZXMgPSBmYWxzZTtcbiAgICB9KTtcbiAgfVxuICBkaXNhYmxlSGlnaGxpZ2h0U3R5bGUoKSB7XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICBjb25zdCB0YWJsZUVsZW1lbnQgPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KHRoaXMudGFibGVOb2RlS2V5KTtcbiAgICAgIGlmICghdGFibGVFbGVtZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gZmluZCBUYWJsZUVsZW1lbnQgaW4gRE9NJyk7XG4gICAgICB9XG4gICAgICBhZGRDbGFzc05hbWVzVG9FbGVtZW50KHRhYmxlRWxlbWVudCwgZWRpdG9yLl9jb25maWcudGhlbWUudGFibGVTZWxlY3Rpb24pO1xuICAgICAgdGhpcy5oYXNIaWphY2tlZFNlbGVjdGlvblN0eWxlcyA9IHRydWU7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlVGFibGVUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pIHtcbiAgICBpZiAoc2VsZWN0aW9uICE9PSBudWxsICYmIHNlbGVjdGlvbi50YWJsZUtleSA9PT0gdGhpcy50YWJsZU5vZGVLZXkpIHtcbiAgICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgdGhpcy50YWJsZVNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgICAgIHRoaXMuaXNIaWdobGlnaHRpbmdDZWxscyA9IHRydWU7XG4gICAgICB0aGlzLmRpc2FibGVIaWdobGlnaHRTdHlsZSgpO1xuICAgICAgJHVwZGF0ZURPTUZvclNlbGVjdGlvbihlZGl0b3IsIHRoaXMudGFibGUsIHRoaXMudGFibGVTZWxlY3Rpb24pO1xuICAgIH0gZWxzZSBpZiAoc2VsZWN0aW9uID09IG51bGwpIHtcbiAgICAgIHRoaXMuY2xlYXJIaWdobGlnaHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50YWJsZU5vZGVLZXkgPSBzZWxlY3Rpb24udGFibGVLZXk7XG4gICAgICB0aGlzLnVwZGF0ZVRhYmxlVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICB9XG4gIH1cbiAgc2V0Rm9jdXNDZWxsRm9yU2VsZWN0aW9uKGNlbGwsIGlnbm9yZVN0YXJ0ID0gZmFsc2UpIHtcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLmVkaXRvcjtcbiAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgIGNvbnN0IHRhYmxlTm9kZSA9ICRnZXROb2RlQnlLZXkodGhpcy50YWJsZU5vZGVLZXkpO1xuICAgICAgaWYgKCEkaXNUYWJsZU5vZGUodGFibGVOb2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIFRhYmxlTm9kZS4nKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhYmxlRWxlbWVudCA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkodGhpcy50YWJsZU5vZGVLZXkpO1xuICAgICAgaWYgKCF0YWJsZUVsZW1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBmaW5kIFRhYmxlRWxlbWVudCBpbiBET00nKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNlbGxYID0gY2VsbC54O1xuICAgICAgY29uc3QgY2VsbFkgPSBjZWxsLnk7XG4gICAgICB0aGlzLmZvY3VzQ2VsbCA9IGNlbGw7XG4gICAgICBpZiAodGhpcy5hbmNob3JDZWxsICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldERPTVNlbGVjdGlvbihlZGl0b3IuX3dpbmRvdyk7XG4gICAgICAgIC8vIENvbGxhcHNlIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgaWYgKGRvbVNlbGVjdGlvbikge1xuICAgICAgICAgIGRvbVNlbGVjdGlvbi5zZXRCYXNlQW5kRXh0ZW50KHRoaXMuYW5jaG9yQ2VsbC5lbGVtLCAwLCB0aGlzLmZvY3VzQ2VsbC5lbGVtLCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmlzSGlnaGxpZ2h0aW5nQ2VsbHMgJiYgKHRoaXMuYW5jaG9yWCAhPT0gY2VsbFggfHwgdGhpcy5hbmNob3JZICE9PSBjZWxsWSB8fCBpZ25vcmVTdGFydCkpIHtcbiAgICAgICAgdGhpcy5pc0hpZ2hsaWdodGluZ0NlbGxzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kaXNhYmxlSGlnaGxpZ2h0U3R5bGUoKTtcbiAgICAgIH0gZWxzZSBpZiAoY2VsbFggPT09IHRoaXMuZm9jdXNYICYmIGNlbGxZID09PSB0aGlzLmZvY3VzWSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmZvY3VzWCA9IGNlbGxYO1xuICAgICAgdGhpcy5mb2N1c1kgPSBjZWxsWTtcbiAgICAgIGlmICh0aGlzLmlzSGlnaGxpZ2h0aW5nQ2VsbHMpIHtcbiAgICAgICAgY29uc3QgZm9jdXNUYWJsZUNlbGxOb2RlID0gJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUoY2VsbC5lbGVtKTtcbiAgICAgICAgaWYgKHRoaXMudGFibGVTZWxlY3Rpb24gIT0gbnVsbCAmJiB0aGlzLmFuY2hvckNlbGxOb2RlS2V5ICE9IG51bGwgJiYgJGlzVGFibGVDZWxsTm9kZShmb2N1c1RhYmxlQ2VsbE5vZGUpICYmIHRhYmxlTm9kZS5pcygkZmluZFRhYmxlTm9kZShmb2N1c1RhYmxlQ2VsbE5vZGUpKSkge1xuICAgICAgICAgIGNvbnN0IGZvY3VzTm9kZUtleSA9IGZvY3VzVGFibGVDZWxsTm9kZS5nZXRLZXkoKTtcbiAgICAgICAgICB0aGlzLnRhYmxlU2VsZWN0aW9uID0gdGhpcy50YWJsZVNlbGVjdGlvbi5jbG9uZSgpIHx8ICRjcmVhdGVUYWJsZVNlbGVjdGlvbigpO1xuICAgICAgICAgIHRoaXMuZm9jdXNDZWxsTm9kZUtleSA9IGZvY3VzTm9kZUtleTtcbiAgICAgICAgICB0aGlzLnRhYmxlU2VsZWN0aW9uLnNldCh0aGlzLnRhYmxlTm9kZUtleSwgdGhpcy5hbmNob3JDZWxsTm9kZUtleSwgdGhpcy5mb2N1c0NlbGxOb2RlS2V5KTtcbiAgICAgICAgICAkc2V0U2VsZWN0aW9uKHRoaXMudGFibGVTZWxlY3Rpb24pO1xuICAgICAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoU0VMRUNUSU9OX0NIQU5HRV9DT01NQU5ELCB1bmRlZmluZWQpO1xuICAgICAgICAgICR1cGRhdGVET01Gb3JTZWxlY3Rpb24oZWRpdG9yLCB0aGlzLnRhYmxlLCB0aGlzLnRhYmxlU2VsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNldEFuY2hvckNlbGxGb3JTZWxlY3Rpb24oY2VsbCkge1xuICAgIHRoaXMuaXNIaWdobGlnaHRpbmdDZWxscyA9IGZhbHNlO1xuICAgIHRoaXMuYW5jaG9yQ2VsbCA9IGNlbGw7XG4gICAgdGhpcy5hbmNob3JYID0gY2VsbC54O1xuICAgIHRoaXMuYW5jaG9yWSA9IGNlbGwueTtcbiAgICB0aGlzLmVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgY29uc3QgYW5jaG9yVGFibGVDZWxsTm9kZSA9ICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGNlbGwuZWxlbSk7XG4gICAgICBpZiAoJGlzVGFibGVDZWxsTm9kZShhbmNob3JUYWJsZUNlbGxOb2RlKSkge1xuICAgICAgICBjb25zdCBhbmNob3JOb2RlS2V5ID0gYW5jaG9yVGFibGVDZWxsTm9kZS5nZXRLZXkoKTtcbiAgICAgICAgdGhpcy50YWJsZVNlbGVjdGlvbiA9IHRoaXMudGFibGVTZWxlY3Rpb24gIT0gbnVsbCA/IHRoaXMudGFibGVTZWxlY3Rpb24uY2xvbmUoKSA6ICRjcmVhdGVUYWJsZVNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLmFuY2hvckNlbGxOb2RlS2V5ID0gYW5jaG9yTm9kZUtleTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmb3JtYXRDZWxscyh0eXBlKSB7XG4gICAgdGhpcy5lZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICAgIGlmICghJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIGdyaWQgc2VsZWN0aW9uYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGZvcm1hdFNlbGVjdGlvbiA9ICRjcmVhdGVSYW5nZVNlbGVjdGlvbigpO1xuICAgICAgY29uc3QgYW5jaG9yID0gZm9ybWF0U2VsZWN0aW9uLmFuY2hvcjtcbiAgICAgIGNvbnN0IGZvY3VzID0gZm9ybWF0U2VsZWN0aW9uLmZvY3VzO1xuICAgICAgY29uc3QgY2VsbE5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCkuZmlsdGVyKCRpc1RhYmxlQ2VsbE5vZGUpO1xuICAgICAgY29uc3QgcGFyYWdyYXBoID0gY2VsbE5vZGVzWzBdLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgIGNvbnN0IGFsaWduRm9ybWF0V2l0aCA9ICRpc1BhcmFncmFwaE5vZGUocGFyYWdyYXBoKSA/IHBhcmFncmFwaC5nZXRGb3JtYXRGbGFncyh0eXBlLCBudWxsKSA6IG51bGw7XG4gICAgICBjZWxsTm9kZXMuZm9yRWFjaChjZWxsTm9kZSA9PiB7XG4gICAgICAgIGFuY2hvci5zZXQoY2VsbE5vZGUuZ2V0S2V5KCksIDAsICdlbGVtZW50Jyk7XG4gICAgICAgIGZvY3VzLnNldChjZWxsTm9kZS5nZXRLZXkoKSwgY2VsbE5vZGUuZ2V0Q2hpbGRyZW5TaXplKCksICdlbGVtZW50Jyk7XG4gICAgICAgIGZvcm1hdFNlbGVjdGlvbi5mb3JtYXRUZXh0KHR5cGUsIGFsaWduRm9ybWF0V2l0aCk7XG4gICAgICB9KTtcbiAgICAgICRzZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICAgIHRoaXMuZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChTRUxFQ1RJT05fQ0hBTkdFX0NPTU1BTkQsIHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gIH1cbiAgY2xlYXJUZXh0KCkge1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgY29uc3QgdGFibGVOb2RlID0gJGdldE5vZGVCeUtleSh0aGlzLnRhYmxlTm9kZUtleSk7XG4gICAgICBpZiAoISRpc1RhYmxlTm9kZSh0YWJsZU5vZGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgVGFibGVOb2RlLicpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgICAgaWYgKCEkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgZ3JpZCBzZWxlY3Rpb25gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgc2VsZWN0ZWROb2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpLmZpbHRlcigkaXNUYWJsZUNlbGxOb2RlKTtcbiAgICAgIGlmIChzZWxlY3RlZE5vZGVzLmxlbmd0aCA9PT0gdGhpcy50YWJsZS5jb2x1bW5zICogdGhpcy50YWJsZS5yb3dzKSB7XG4gICAgICAgIHRhYmxlTm9kZS5zZWxlY3RQcmV2aW91cygpO1xuICAgICAgICAvLyBEZWxldGUgZW50aXJlIHRhYmxlXG4gICAgICAgIHRhYmxlTm9kZS5yZW1vdmUoKTtcbiAgICAgICAgY29uc3Qgcm9vdE5vZGUgPSAkZ2V0Um9vdCgpO1xuICAgICAgICByb290Tm9kZS5zZWxlY3RTdGFydCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWxlY3RlZE5vZGVzLmZvckVhY2goY2VsbE5vZGUgPT4ge1xuICAgICAgICBpZiAoJGlzRWxlbWVudE5vZGUoY2VsbE5vZGUpKSB7XG4gICAgICAgICAgY29uc3QgcGFyYWdyYXBoTm9kZSA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgICAgICAgY29uc3QgdGV4dE5vZGUgPSAkY3JlYXRlVGV4dE5vZGUoKTtcbiAgICAgICAgICBwYXJhZ3JhcGhOb2RlLmFwcGVuZCh0ZXh0Tm9kZSk7XG4gICAgICAgICAgY2VsbE5vZGUuYXBwZW5kKHBhcmFncmFwaE5vZGUpO1xuICAgICAgICAgIGNlbGxOb2RlLmdldENoaWxkcmVuKCkuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgIT09IHBhcmFncmFwaE5vZGUpIHtcbiAgICAgICAgICAgICAgY2hpbGQucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgJHVwZGF0ZURPTUZvclNlbGVjdGlvbihlZGl0b3IsIHRoaXMudGFibGUsIG51bGwpO1xuICAgICAgJHNldFNlbGVjdGlvbihudWxsKTtcbiAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoU0VMRUNUSU9OX0NIQU5HRV9DT01NQU5ELCB1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgTEVYSUNBTF9FTEVNRU5UX0tFWSA9ICdfX2xleGljYWxUYWJsZVNlbGVjdGlvbic7XG5jb25zdCBnZXRET01TZWxlY3Rpb24gPSB0YXJnZXRXaW5kb3cgPT4gQ0FOX1VTRV9ET00gPyAodGFyZ2V0V2luZG93IHx8IHdpbmRvdykuZ2V0U2VsZWN0aW9uKCkgOiBudWxsO1xuY29uc3QgaXNNb3VzZURvd25PbkV2ZW50ID0gZXZlbnQgPT4ge1xuICByZXR1cm4gKGV2ZW50LmJ1dHRvbnMgJiAxKSA9PT0gMTtcbn07XG5mdW5jdGlvbiBhcHBseVRhYmxlSGFuZGxlcnModGFibGVOb2RlLCB0YWJsZUVsZW1lbnQsIGVkaXRvciwgaGFzVGFiSGFuZGxlcikge1xuICBjb25zdCByb290RWxlbWVudCA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuICBpZiAocm9vdEVsZW1lbnQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHJvb3QgZWxlbWVudC4nKTtcbiAgfVxuICBjb25zdCB0YWJsZU9ic2VydmVyID0gbmV3IFRhYmxlT2JzZXJ2ZXIoZWRpdG9yLCB0YWJsZU5vZGUuZ2V0S2V5KCkpO1xuICBjb25zdCBlZGl0b3JXaW5kb3cgPSBlZGl0b3IuX3dpbmRvdyB8fCB3aW5kb3c7XG4gIGF0dGFjaFRhYmxlT2JzZXJ2ZXJUb1RhYmxlRWxlbWVudCh0YWJsZUVsZW1lbnQsIHRhYmxlT2JzZXJ2ZXIpO1xuICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZCgoKSA9PiBkZWF0YXRjaFRhYmxlT2JzZXJ2ZXJGcm9tVGFibGVFbGVtZW50KHRhYmxlRWxlbWVudCwgdGFibGVPYnNlcnZlcikpO1xuICBjb25zdCBjcmVhdGVNb3VzZUhhbmRsZXJzID0gKCkgPT4ge1xuICAgIGNvbnN0IG9uTW91c2VVcCA9ICgpID0+IHtcbiAgICAgIHRhYmxlT2JzZXJ2ZXIuaXNTZWxlY3RpbmcgPSBmYWxzZTtcbiAgICAgIGVkaXRvcldpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICAgIGVkaXRvcldpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSk7XG4gICAgfTtcbiAgICBjb25zdCBvbk1vdXNlTW92ZSA9IG1vdmVFdmVudCA9PiB7XG4gICAgICAvLyBkZWxheWluZyBtb3VzZW1vdmUgaGFuZGxlciB0byBhbGxvdyBzZWxlY3Rpb25jaGFuZ2UgaGFuZGxlciBmcm9tIExleGljYWxFdmVudHMudHMgdG8gYmUgZXhlY3V0ZWQgZmlyc3RcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoIWlzTW91c2VEb3duT25FdmVudChtb3ZlRXZlbnQpICYmIHRhYmxlT2JzZXJ2ZXIuaXNTZWxlY3RpbmcpIHtcbiAgICAgICAgICB0YWJsZU9ic2VydmVyLmlzU2VsZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgZWRpdG9yV2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuICAgICAgICAgIGVkaXRvcldpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvY3VzQ2VsbCA9IGdldERPTUNlbGxGcm9tVGFyZ2V0KG1vdmVFdmVudC50YXJnZXQpO1xuICAgICAgICBpZiAoZm9jdXNDZWxsICE9PSBudWxsICYmICh0YWJsZU9ic2VydmVyLmFuY2hvclggIT09IGZvY3VzQ2VsbC54IHx8IHRhYmxlT2JzZXJ2ZXIuYW5jaG9yWSAhPT0gZm9jdXNDZWxsLnkpKSB7XG4gICAgICAgICAgbW92ZUV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGFibGVPYnNlcnZlci5zZXRGb2N1c0NlbGxGb3JTZWxlY3Rpb24oZm9jdXNDZWxsKTtcbiAgICAgICAgfVxuICAgICAgfSwgMCk7XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgb25Nb3VzZU1vdmUsXG4gICAgICBvbk1vdXNlVXBcbiAgICB9O1xuICB9O1xuICBjb25zdCBvbk1vdXNlRG93biA9IGV2ZW50ID0+IHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFlZGl0b3JXaW5kb3cpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgYW5jaG9yQ2VsbCA9IGdldERPTUNlbGxGcm9tVGFyZ2V0KGV2ZW50LnRhcmdldCk7XG4gICAgICBpZiAoYW5jaG9yQ2VsbCAhPT0gbnVsbCkge1xuICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICB0YWJsZU9ic2VydmVyLnNldEFuY2hvckNlbGxGb3JTZWxlY3Rpb24oYW5jaG9yQ2VsbCk7XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9uTW91c2VVcCxcbiAgICAgICAgb25Nb3VzZU1vdmVcbiAgICAgIH0gPSBjcmVhdGVNb3VzZUhhbmRsZXJzKCk7XG4gICAgICB0YWJsZU9ic2VydmVyLmlzU2VsZWN0aW5nID0gdHJ1ZTtcbiAgICAgIGVkaXRvcldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Nb3VzZVVwLCB0YWJsZU9ic2VydmVyLmxpc3RlbmVyT3B0aW9ucyk7XG4gICAgICBlZGl0b3JXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUsIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJPcHRpb25zKTtcbiAgICB9LCAwKTtcbiAgfTtcbiAgdGFibGVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uTW91c2VEb3duLCB0YWJsZU9ic2VydmVyLmxpc3RlbmVyT3B0aW9ucyk7XG5cbiAgLy8gQ2xlYXIgc2VsZWN0aW9uIHdoZW4gY2xpY2tpbmcgb3V0c2lkZSBvZiBkb20uXG4gIGNvbnN0IG1vdXNlRG93bkNhbGxiYWNrID0gZXZlbnQgPT4ge1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICBpZiAoJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiBzZWxlY3Rpb24udGFibGVLZXkgPT09IHRhYmxlT2JzZXJ2ZXIudGFibGVOb2RlS2V5ICYmIHJvb3RFbGVtZW50LmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgdGFibGVPYnNlcnZlci5jbGVhckhpZ2hsaWdodCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBlZGl0b3JXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbW91c2VEb3duQ2FsbGJhY2ssIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJPcHRpb25zKTtcbiAgdGFibGVPYnNlcnZlci5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChLRVlfQVJST1dfRE9XTl9DT01NQU5ELCBldmVudCA9PiAkaGFuZGxlQXJyb3dLZXkoZWRpdG9yLCBldmVudCwgJ2Rvd24nLCB0YWJsZU5vZGUsIHRhYmxlT2JzZXJ2ZXIpLCBDT01NQU5EX1BSSU9SSVRZX0hJR0gpKTtcbiAgdGFibGVPYnNlcnZlci5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChLRVlfQVJST1dfVVBfQ09NTUFORCwgZXZlbnQgPT4gJGhhbmRsZUFycm93S2V5KGVkaXRvciwgZXZlbnQsICd1cCcsIHRhYmxlTm9kZSwgdGFibGVPYnNlcnZlciksIENPTU1BTkRfUFJJT1JJVFlfSElHSCkpO1xuICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9BUlJPV19MRUZUX0NPTU1BTkQsIGV2ZW50ID0+ICRoYW5kbGVBcnJvd0tleShlZGl0b3IsIGV2ZW50LCAnYmFja3dhcmQnLCB0YWJsZU5vZGUsIHRhYmxlT2JzZXJ2ZXIpLCBDT01NQU5EX1BSSU9SSVRZX0hJR0gpKTtcbiAgdGFibGVPYnNlcnZlci5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChLRVlfQVJST1dfUklHSFRfQ09NTUFORCwgZXZlbnQgPT4gJGhhbmRsZUFycm93S2V5KGVkaXRvciwgZXZlbnQsICdmb3J3YXJkJywgdGFibGVOb2RlLCB0YWJsZU9ic2VydmVyKSwgQ09NTUFORF9QUklPUklUWV9ISUdIKSk7XG4gIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoS0VZX0VTQ0FQRV9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICgkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBmb2N1c0NlbGxOb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpLCAkaXNUYWJsZUNlbGxOb2RlKTtcbiAgICAgIGlmICgkaXNUYWJsZUNlbGxOb2RlKGZvY3VzQ2VsbE5vZGUpKSB7XG4gICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgIGZvY3VzQ2VsbE5vZGUuc2VsZWN0RW5kKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfSElHSCkpO1xuICBjb25zdCBkZWxldGVUZXh0SGFuZGxlciA9IGNvbW1hbmQgPT4gKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1NlbGVjdGlvbkluVGFibGUoc2VsZWN0aW9uLCB0YWJsZU5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICgkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICB0YWJsZU9ic2VydmVyLmNsZWFyVGV4dCgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCB0YWJsZUNlbGxOb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSwgbiA9PiAkaXNUYWJsZUNlbGxOb2RlKG4pKTtcbiAgICAgIGlmICghJGlzVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxOb2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gICAgICBjb25zdCBmb2N1c05vZGUgPSBzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpO1xuICAgICAgY29uc3QgaXNBbmNob3JJbnNpZGUgPSB0YWJsZU5vZGUuaXNQYXJlbnRPZihhbmNob3JOb2RlKTtcbiAgICAgIGNvbnN0IGlzRm9jdXNJbnNpZGUgPSB0YWJsZU5vZGUuaXNQYXJlbnRPZihmb2N1c05vZGUpO1xuICAgICAgY29uc3Qgc2VsZWN0aW9uQ29udGFpbnNQYXJ0aWFsVGFibGUgPSBpc0FuY2hvckluc2lkZSAmJiAhaXNGb2N1c0luc2lkZSB8fCBpc0ZvY3VzSW5zaWRlICYmICFpc0FuY2hvckluc2lkZTtcbiAgICAgIGlmIChzZWxlY3Rpb25Db250YWluc1BhcnRpYWxUYWJsZSkge1xuICAgICAgICB0YWJsZU9ic2VydmVyLmNsZWFyVGV4dCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5lYXJlc3RFbGVtZW50Tm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCksIG4gPT4gJGlzRWxlbWVudE5vZGUobikpO1xuICAgICAgY29uc3QgdG9wTGV2ZWxDZWxsRWxlbWVudE5vZGUgPSBuZWFyZXN0RWxlbWVudE5vZGUgJiYgJGZpbmRNYXRjaGluZ1BhcmVudChuZWFyZXN0RWxlbWVudE5vZGUsIG4gPT4gJGlzRWxlbWVudE5vZGUobikgJiYgJGlzVGFibGVDZWxsTm9kZShuLmdldFBhcmVudCgpKSk7XG4gICAgICBpZiAoISRpc0VsZW1lbnROb2RlKHRvcExldmVsQ2VsbEVsZW1lbnROb2RlKSB8fCAhJGlzRWxlbWVudE5vZGUobmVhcmVzdEVsZW1lbnROb2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoY29tbWFuZCA9PT0gREVMRVRFX0xJTkVfQ09NTUFORCAmJiB0b3BMZXZlbENlbGxFbGVtZW50Tm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBGaXggRGVsZXRlIExpbmUgaW4gVGFibGUgQ2VsbHMuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIFtERUxFVEVfV09SRF9DT01NQU5ELCBERUxFVEVfTElORV9DT01NQU5ELCBERUxFVEVfQ0hBUkFDVEVSX0NPTU1BTkRdLmZvckVhY2goY29tbWFuZCA9PiB7XG4gICAgdGFibGVPYnNlcnZlci5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChjb21tYW5kLCBkZWxldGVUZXh0SGFuZGxlcihjb21tYW5kKSwgQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCkpO1xuICB9KTtcbiAgY29uc3QgJGRlbGV0ZUNlbGxIYW5kbGVyID0gZXZlbnQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISgkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHNlbGVjdGlvbiBpcyBpbnNpZGUgdGhlIHRhYmxlIGJ1dCBzaG91bGQgcmVtb3ZlIHRoZSB3aG9sZSB0YWJsZVxuICAgIC8vIHdlIGV4cGFuZCB0aGUgc2VsZWN0aW9uIHNvIHRoYXQgYm90aCB0aGUgYW5jaG9yIGFuZCBmb2N1cyBhcmUgb3V0c2lkZVxuICAgIC8vIHRoZSB0YWJsZSBhbmQgdGhlIGVkaXRvcidzIGNvbW1hbmQgbGlzdGVuZXIgd2lsbCBoYW5kbGUgdGhlIGRlbGV0ZVxuICAgIGNvbnN0IGlzQW5jaG9ySW5zaWRlID0gdGFibGVOb2RlLmlzUGFyZW50T2Yoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCkpO1xuICAgIGNvbnN0IGlzRm9jdXNJbnNpZGUgPSB0YWJsZU5vZGUuaXNQYXJlbnRPZihzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpKTtcbiAgICBpZiAoaXNBbmNob3JJbnNpZGUgIT09IGlzRm9jdXNJbnNpZGUpIHtcbiAgICAgIGNvbnN0IHRhYmxlUG9pbnQgPSBpc0FuY2hvckluc2lkZSA/ICdhbmNob3InIDogJ2ZvY3VzJztcbiAgICAgIGNvbnN0IG91dGVyUG9pbnQgPSBpc0FuY2hvckluc2lkZSA/ICdmb2N1cycgOiAnYW5jaG9yJztcbiAgICAgIC8vIFByZXNlcnZlIHRoZSBvdXRlciBwb2ludFxuICAgICAgY29uc3Qge1xuICAgICAgICBrZXksXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgdHlwZVxuICAgICAgfSA9IHNlbGVjdGlvbltvdXRlclBvaW50XTtcbiAgICAgIC8vIEV4cGFuZCB0aGUgc2VsZWN0aW9uIGFyb3VuZCB0aGUgdGFibGVcbiAgICAgIGNvbnN0IG5ld1NlbGVjdGlvbiA9IHRhYmxlTm9kZVtzZWxlY3Rpb25bdGFibGVQb2ludF0uaXNCZWZvcmUoc2VsZWN0aW9uW291dGVyUG9pbnRdKSA/ICdzZWxlY3RQcmV2aW91cycgOiAnc2VsZWN0TmV4dCddKCk7XG4gICAgICAvLyBSZXN0b3JlIHRoZSBvdXRlciBwb2ludCBvZiB0aGUgc2VsZWN0aW9uXG4gICAgICBuZXdTZWxlY3Rpb25bb3V0ZXJQb2ludF0uc2V0KGtleSwgb2Zmc2V0LCB0eXBlKTtcbiAgICAgIC8vIExldCB0aGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBoYW5kbGUgdGhlIHJlc3RcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGlmIChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIHRhYmxlT2JzZXJ2ZXIuY2xlYXJUZXh0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9CQUNLU1BBQ0VfQ09NTUFORCwgJGRlbGV0ZUNlbGxIYW5kbGVyLCBDT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMKSk7XG4gIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoS0VZX0RFTEVURV9DT01NQU5ELCAkZGVsZXRlQ2VsbEhhbmRsZXIsIENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwpKTtcbiAgdGFibGVPYnNlcnZlci5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChDVVRfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICBpZiAoISgkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHlpbmcgdG8gdGhlIGNsaXBib2FyZCBpcyBhc3luYyBzbyB3ZSBtdXN0IGNhcHR1cmUgdGhlIGRhdGFcbiAgICAgIC8vIGJlZm9yZSB3ZSBkZWxldGUgaXRcbiAgICAgIHZvaWQgY29weVRvQ2xpcGJvYXJkKGVkaXRvciwgb2JqZWN0S2xhc3NFcXVhbHMoZXZlbnQsIENsaXBib2FyZEV2ZW50KSA/IGV2ZW50IDogbnVsbCwgJGdldENsaXBib2FyZERhdGFGcm9tU2VsZWN0aW9uKHNlbGVjdGlvbikpO1xuICAgICAgY29uc3QgaW50ZXJjZXB0ZWQgPSAkZGVsZXRlQ2VsbEhhbmRsZXIoZXZlbnQpO1xuICAgICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgc2VsZWN0aW9uLnJlbW92ZVRleHQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW50ZXJjZXB0ZWQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCkpO1xuICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEZPUk1BVF9URVhUX0NPTU1BTkQsIHBheWxvYWQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1NlbGVjdGlvbkluVGFibGUoc2VsZWN0aW9uLCB0YWJsZU5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICgkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICB0YWJsZU9ic2VydmVyLmZvcm1hdENlbGxzKHBheWxvYWQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCB0YWJsZUNlbGxOb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSwgbiA9PiAkaXNUYWJsZUNlbGxOb2RlKG4pKTtcbiAgICAgIGlmICghJGlzVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxOb2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCkpO1xuICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEZPUk1BVF9FTEVNRU5UX0NPTU1BTkQsIGZvcm1hdFR5cGUgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgISRpc1NlbGVjdGlvbkluVGFibGUoc2VsZWN0aW9uLCB0YWJsZU5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgICBjb25zdCBmb2N1c05vZGUgPSBzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpO1xuICAgIGlmICghJGlzVGFibGVDZWxsTm9kZShhbmNob3JOb2RlKSB8fCAhJGlzVGFibGVDZWxsTm9kZShmb2N1c05vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IFt0YWJsZU1hcCwgYW5jaG9yQ2VsbCwgZm9jdXNDZWxsXSA9ICRjb21wdXRlVGFibGVNYXAodGFibGVOb2RlLCBhbmNob3JOb2RlLCBmb2N1c05vZGUpO1xuICAgIGNvbnN0IG1heFJvdyA9IE1hdGgubWF4KGFuY2hvckNlbGwuc3RhcnRSb3csIGZvY3VzQ2VsbC5zdGFydFJvdyk7XG4gICAgY29uc3QgbWF4Q29sdW1uID0gTWF0aC5tYXgoYW5jaG9yQ2VsbC5zdGFydENvbHVtbiwgZm9jdXNDZWxsLnN0YXJ0Q29sdW1uKTtcbiAgICBjb25zdCBtaW5Sb3cgPSBNYXRoLm1pbihhbmNob3JDZWxsLnN0YXJ0Um93LCBmb2N1c0NlbGwuc3RhcnRSb3cpO1xuICAgIGNvbnN0IG1pbkNvbHVtbiA9IE1hdGgubWluKGFuY2hvckNlbGwuc3RhcnRDb2x1bW4sIGZvY3VzQ2VsbC5zdGFydENvbHVtbik7XG4gICAgZm9yIChsZXQgaSA9IG1pblJvdzsgaSA8PSBtYXhSb3c7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IG1pbkNvbHVtbjsgaiA8PSBtYXhDb2x1bW47IGorKykge1xuICAgICAgICBjb25zdCBjZWxsID0gdGFibGVNYXBbaV1bal0uY2VsbDtcbiAgICAgICAgY2VsbC5zZXRGb3JtYXQoZm9ybWF0VHlwZSk7XG4gICAgICAgIGNvbnN0IGNlbGxDaGlsZHJlbiA9IGNlbGwuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBjZWxsQ2hpbGRyZW4ubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICBjb25zdCBjaGlsZCA9IGNlbGxDaGlsZHJlbltrXTtcbiAgICAgICAgICBpZiAoJGlzRWxlbWVudE5vZGUoY2hpbGQpICYmICFjaGlsZC5pc0lubGluZSgpKSB7XG4gICAgICAgICAgICBjaGlsZC5zZXRGb3JtYXQoZm9ybWF0VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMKSk7XG4gIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoQ09OVFJPTExFRF9URVhUX0lOU0VSVElPTl9DT01NQU5ELCBwYXlsb2FkID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNTZWxlY3Rpb25JblRhYmxlKHNlbGVjdGlvbiwgdGFibGVOb2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgdGFibGVPYnNlcnZlci5jbGVhckhpZ2hsaWdodCgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgdGFibGVDZWxsTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCksIG4gPT4gJGlzVGFibGVDZWxsTm9kZShuKSk7XG4gICAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUodGFibGVDZWxsTm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBlZGdlUG9zaXRpb24gPSAkZ2V0VGFibGVFZGdlQ3Vyc29yUG9zaXRpb24oZWRpdG9yLCBzZWxlY3Rpb24sIHRhYmxlTm9kZSk7XG4gICAgICAgIGlmIChlZGdlUG9zaXRpb24pIHtcbiAgICAgICAgICAkaW5zZXJ0UGFyYWdyYXBoQXRUYWJsZUVkZ2UoZWRnZVBvc2l0aW9uLCB0YWJsZU5vZGUsIFskY3JlYXRlVGV4dE5vZGUocGF5bG9hZCldKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwpKTtcbiAgaWYgKGhhc1RhYkhhbmRsZXIpIHtcbiAgICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9UQUJfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICFzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSB8fCAhJGlzU2VsZWN0aW9uSW5UYWJsZShzZWxlY3Rpb24sIHRhYmxlTm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgdGFibGVDZWxsTm9kZSA9ICRmaW5kQ2VsbE5vZGUoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCkpO1xuICAgICAgaWYgKHRhYmxlQ2VsbE5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgIGNvbnN0IGN1cnJlbnRDb3JkcyA9IHRhYmxlTm9kZS5nZXRDb3Jkc0Zyb21DZWxsTm9kZSh0YWJsZUNlbGxOb2RlLCB0YWJsZU9ic2VydmVyLnRhYmxlKTtcbiAgICAgIHNlbGVjdFRhYmxlTm9kZUluRGlyZWN0aW9uKHRhYmxlT2JzZXJ2ZXIsIHRhYmxlTm9kZSwgY3VycmVudENvcmRzLngsIGN1cnJlbnRDb3Jkcy55LCAhZXZlbnQuc2hpZnRLZXkgPyAnZm9yd2FyZCcgOiAnYmFja3dhcmQnKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sIENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwpKTtcbiAgfVxuICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEZPQ1VTX0NPTU1BTkQsIHBheWxvYWQgPT4ge1xuICAgIHJldHVybiB0YWJsZU5vZGUuaXNTZWxlY3RlZCgpO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0hJR0gpKTtcbiAgZnVuY3Rpb24gZ2V0T2JzZXJ2ZXJDZWxsRnJvbUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUpIHtcbiAgICBjb25zdCBjdXJyZW50Q29yZHMgPSB0YWJsZU5vZGUuZ2V0Q29yZHNGcm9tQ2VsbE5vZGUodGFibGVDZWxsTm9kZSwgdGFibGVPYnNlcnZlci50YWJsZSk7XG4gICAgcmV0dXJuIHRhYmxlTm9kZS5nZXRET01DZWxsRnJvbUNvcmRzT3JUaHJvdyhjdXJyZW50Q29yZHMueCwgY3VycmVudENvcmRzLnksIHRhYmxlT2JzZXJ2ZXIudGFibGUpO1xuICB9XG4gIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoU0VMRUNUSU9OX0lOU0VSVF9DTElQQk9BUkRfTk9ERVNfQ09NTUFORCwgc2VsZWN0aW9uUGF5bG9hZCA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgbm9kZXMsXG4gICAgICBzZWxlY3Rpb25cbiAgICB9ID0gc2VsZWN0aW9uUGF5bG9hZDtcbiAgICBjb25zdCBhbmNob3JBbmRGb2N1cyA9IHNlbGVjdGlvbi5nZXRTdGFydEVuZFBvaW50cygpO1xuICAgIGNvbnN0IGlzVGFibGVTZWxlY3Rpb24gPSAkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIGNvbnN0IGlzUmFuZ2VTZWxlY3Rpb24gPSAkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIGNvbnN0IGlzU2VsZWN0aW9uSW5zaWRlT2ZHcmlkID0gaXNSYW5nZVNlbGVjdGlvbiAmJiAkZmluZE1hdGNoaW5nUGFyZW50KHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpLCBuID0+ICRpc1RhYmxlQ2VsbE5vZGUobikpICE9PSBudWxsICYmICRmaW5kTWF0Y2hpbmdQYXJlbnQoc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKSwgbiA9PiAkaXNUYWJsZUNlbGxOb2RlKG4pKSAhPT0gbnVsbCB8fCBpc1RhYmxlU2VsZWN0aW9uO1xuICAgIGlmIChub2Rlcy5sZW5ndGggIT09IDEgfHwgISRpc1RhYmxlTm9kZShub2Rlc1swXSkgfHwgIWlzU2VsZWN0aW9uSW5zaWRlT2ZHcmlkIHx8IGFuY2hvckFuZEZvY3VzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IFthbmNob3JdID0gYW5jaG9yQW5kRm9jdXM7XG4gICAgY29uc3QgbmV3R3JpZCA9IG5vZGVzWzBdO1xuICAgIGNvbnN0IG5ld0dyaWRSb3dzID0gbmV3R3JpZC5nZXRDaGlsZHJlbigpO1xuICAgIGNvbnN0IG5ld0NvbHVtbkNvdW50ID0gbmV3R3JpZC5nZXRGaXJzdENoaWxkT3JUaHJvdygpLmdldENoaWxkcmVuU2l6ZSgpO1xuICAgIGNvbnN0IG5ld1Jvd0NvdW50ID0gbmV3R3JpZC5nZXRDaGlsZHJlblNpemUoKTtcbiAgICBjb25zdCBncmlkQ2VsbE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGFuY2hvci5nZXROb2RlKCksIG4gPT4gJGlzVGFibGVDZWxsTm9kZShuKSk7XG4gICAgY29uc3QgZ3JpZFJvd05vZGUgPSBncmlkQ2VsbE5vZGUgJiYgJGZpbmRNYXRjaGluZ1BhcmVudChncmlkQ2VsbE5vZGUsIG4gPT4gJGlzVGFibGVSb3dOb2RlKG4pKTtcbiAgICBjb25zdCBncmlkTm9kZSA9IGdyaWRSb3dOb2RlICYmICRmaW5kTWF0Y2hpbmdQYXJlbnQoZ3JpZFJvd05vZGUsIG4gPT4gJGlzVGFibGVOb2RlKG4pKTtcbiAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUoZ3JpZENlbGxOb2RlKSB8fCAhJGlzVGFibGVSb3dOb2RlKGdyaWRSb3dOb2RlKSB8fCAhJGlzVGFibGVOb2RlKGdyaWROb2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBzdGFydFkgPSBncmlkUm93Tm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpO1xuICAgIGNvbnN0IHN0b3BZID0gTWF0aC5taW4oZ3JpZE5vZGUuZ2V0Q2hpbGRyZW5TaXplKCkgLSAxLCBzdGFydFkgKyBuZXdSb3dDb3VudCAtIDEpO1xuICAgIGNvbnN0IHN0YXJ0WCA9IGdyaWRDZWxsTm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpO1xuICAgIGNvbnN0IHN0b3BYID0gTWF0aC5taW4oZ3JpZFJvd05vZGUuZ2V0Q2hpbGRyZW5TaXplKCkgLSAxLCBzdGFydFggKyBuZXdDb2x1bW5Db3VudCAtIDEpO1xuICAgIGNvbnN0IGZyb21YID0gTWF0aC5taW4oc3RhcnRYLCBzdG9wWCk7XG4gICAgY29uc3QgZnJvbVkgPSBNYXRoLm1pbihzdGFydFksIHN0b3BZKTtcbiAgICBjb25zdCB0b1ggPSBNYXRoLm1heChzdGFydFgsIHN0b3BYKTtcbiAgICBjb25zdCB0b1kgPSBNYXRoLm1heChzdGFydFksIHN0b3BZKTtcbiAgICBjb25zdCBncmlkUm93Tm9kZXMgPSBncmlkTm9kZS5nZXRDaGlsZHJlbigpO1xuICAgIGxldCBuZXdSb3dJZHggPSAwO1xuICAgIGZvciAobGV0IHIgPSBmcm9tWTsgciA8PSB0b1k7IHIrKykge1xuICAgICAgY29uc3QgY3VycmVudEdyaWRSb3dOb2RlID0gZ3JpZFJvd05vZGVzW3JdO1xuICAgICAgaWYgKCEkaXNUYWJsZVJvd05vZGUoY3VycmVudEdyaWRSb3dOb2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBuZXdHcmlkUm93Tm9kZSA9IG5ld0dyaWRSb3dzW25ld1Jvd0lkeF07XG4gICAgICBpZiAoISRpc1RhYmxlUm93Tm9kZShuZXdHcmlkUm93Tm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgZ3JpZENlbGxOb2RlcyA9IGN1cnJlbnRHcmlkUm93Tm9kZS5nZXRDaGlsZHJlbigpO1xuICAgICAgY29uc3QgbmV3R3JpZENlbGxOb2RlcyA9IG5ld0dyaWRSb3dOb2RlLmdldENoaWxkcmVuKCk7XG4gICAgICBsZXQgbmV3Q29sdW1uSWR4ID0gMDtcbiAgICAgIGZvciAobGV0IGMgPSBmcm9tWDsgYyA8PSB0b1g7IGMrKykge1xuICAgICAgICBjb25zdCBjdXJyZW50R3JpZENlbGxOb2RlID0gZ3JpZENlbGxOb2Rlc1tjXTtcbiAgICAgICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKGN1cnJlbnRHcmlkQ2VsbE5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0dyaWRDZWxsTm9kZSA9IG5ld0dyaWRDZWxsTm9kZXNbbmV3Q29sdW1uSWR4XTtcbiAgICAgICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKG5ld0dyaWRDZWxsTm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3JpZ2luYWxDaGlsZHJlbiA9IGN1cnJlbnRHcmlkQ2VsbE5vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgbmV3R3JpZENlbGxOb2RlLmdldENoaWxkcmVuKCkuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgaWYgKCRpc1RleHROb2RlKGNoaWxkKSkge1xuICAgICAgICAgICAgY29uc3QgcGFyYWdyYXBoTm9kZSA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgICAgICAgICBwYXJhZ3JhcGhOb2RlLmFwcGVuZChjaGlsZCk7XG4gICAgICAgICAgICBjdXJyZW50R3JpZENlbGxOb2RlLmFwcGVuZChjaGlsZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJlbnRHcmlkQ2VsbE5vZGUuYXBwZW5kKGNoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBvcmlnaW5hbENoaWxkcmVuLmZvckVhY2gobiA9PiBuLnJlbW92ZSgpKTtcbiAgICAgICAgbmV3Q29sdW1uSWR4Kys7XG4gICAgICB9XG4gICAgICBuZXdSb3dJZHgrKztcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwpKTtcbiAgdGFibGVPYnNlcnZlci5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChTRUxFQ1RJT05fQ0hBTkdFX0NPTU1BTkQsICgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgY29uc3QgcHJldlNlbGVjdGlvbiA9ICRnZXRQcmV2aW91c1NlbGVjdGlvbigpO1xuICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgZm9jdXNcbiAgICAgIH0gPSBzZWxlY3Rpb247XG4gICAgICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgIGNvbnN0IGZvY3VzTm9kZSA9IGZvY3VzLmdldE5vZGUoKTtcbiAgICAgIC8vIFVzaW5nIGV4cGxpY2l0IGNvbXBhcmlzb24gd2l0aCB0YWJsZSBub2RlIHRvIGVuc3VyZSBpdCdzIG5vdCBhIG5lc3RlZCB0YWJsZVxuICAgICAgLy8gYXMgaW4gdGhhdCBjYXNlIHdlJ2xsIGxlYXZlIHNlbGVjdGlvbiByZXNvbHZpbmcgdG8gdGhhdCB0YWJsZVxuICAgICAgY29uc3QgYW5jaG9yQ2VsbE5vZGUgPSAkZmluZENlbGxOb2RlKGFuY2hvck5vZGUpO1xuICAgICAgY29uc3QgZm9jdXNDZWxsTm9kZSA9ICRmaW5kQ2VsbE5vZGUoZm9jdXNOb2RlKTtcbiAgICAgIGNvbnN0IGlzQW5jaG9ySW5zaWRlID0gISEoYW5jaG9yQ2VsbE5vZGUgJiYgdGFibGVOb2RlLmlzKCRmaW5kVGFibGVOb2RlKGFuY2hvckNlbGxOb2RlKSkpO1xuICAgICAgY29uc3QgaXNGb2N1c0luc2lkZSA9ICEhKGZvY3VzQ2VsbE5vZGUgJiYgdGFibGVOb2RlLmlzKCRmaW5kVGFibGVOb2RlKGZvY3VzQ2VsbE5vZGUpKSk7XG4gICAgICBjb25zdCBpc1BhcnRpYWx5V2l0aGluVGFibGUgPSBpc0FuY2hvckluc2lkZSAhPT0gaXNGb2N1c0luc2lkZTtcbiAgICAgIGNvbnN0IGlzV2l0aGluVGFibGUgPSBpc0FuY2hvckluc2lkZSAmJiBpc0ZvY3VzSW5zaWRlO1xuICAgICAgY29uc3QgaXNCYWNrd2FyZCA9IHNlbGVjdGlvbi5pc0JhY2t3YXJkKCk7XG4gICAgICBpZiAoaXNQYXJ0aWFseVdpdGhpblRhYmxlKSB7XG4gICAgICAgIGNvbnN0IG5ld1NlbGVjdGlvbiA9IHNlbGVjdGlvbi5jbG9uZSgpO1xuICAgICAgICBpZiAoaXNGb2N1c0luc2lkZSkge1xuICAgICAgICAgIGNvbnN0IFt0YWJsZU1hcF0gPSAkY29tcHV0ZVRhYmxlTWFwKHRhYmxlTm9kZSwgZm9jdXNDZWxsTm9kZSwgZm9jdXNDZWxsTm9kZSk7XG4gICAgICAgICAgY29uc3QgZmlyc3RDZWxsID0gdGFibGVNYXBbMF1bMF0uY2VsbDtcbiAgICAgICAgICBjb25zdCBsYXN0Q2VsbCA9IHRhYmxlTWFwW3RhYmxlTWFwLmxlbmd0aCAtIDFdLmF0KC0xKS5jZWxsO1xuICAgICAgICAgIG5ld1NlbGVjdGlvbi5mb2N1cy5zZXQoaXNCYWNrd2FyZCA/IGZpcnN0Q2VsbC5nZXRLZXkoKSA6IGxhc3RDZWxsLmdldEtleSgpLCBpc0JhY2t3YXJkID8gZmlyc3RDZWxsLmdldENoaWxkcmVuU2l6ZSgpIDogbGFzdENlbGwuZ2V0Q2hpbGRyZW5TaXplKCksICdlbGVtZW50Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBbmNob3JJbnNpZGUpIHtcbiAgICAgICAgICBjb25zdCBbdGFibGVNYXBdID0gJGNvbXB1dGVUYWJsZU1hcCh0YWJsZU5vZGUsIGFuY2hvckNlbGxOb2RlLCBhbmNob3JDZWxsTm9kZSk7XG4gICAgICAgICAgY29uc3QgZmlyc3RDZWxsID0gdGFibGVNYXBbMF1bMF0uY2VsbDtcbiAgICAgICAgICBjb25zdCBsYXN0Q2VsbCA9IHRhYmxlTWFwW3RhYmxlTWFwLmxlbmd0aCAtIDFdLmF0KC0xKS5jZWxsO1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIElmIGlzQmFja3dhcmQsIHNldCB0aGUgYW5jaG9yIHRvIGJlIGF0IHRoZSBlbmQgb2YgdGhlIHRhYmxlIHNvIHRoYXQgd2hlbiB0aGUgY3Vyc29yIG1vdmVzIG91dHNpZGUgb2ZcbiAgICAgICAgICAgKiB0aGUgdGFibGUgaW4gdGhlIGJhY2t3YXJkIGRpcmVjdGlvbiwgdGhlIGVudGlyZSB0YWJsZSB3aWxsIGJlIHNlbGVjdGVkIGZyb20gaXRzIGVuZC5cbiAgICAgICAgICAgKiBPdGhlcndpc2UsIGlmIGZvcndhcmQsIHNldCB0aGUgYW5jaG9yIHRvIGJlIGF0IHRoZSBzdGFydCBvZiB0aGUgdGFibGUgc28gdGhhdCB3aGVuIHRoZSBmb2N1cyBpcyBkcmFnZ2VkXG4gICAgICAgICAgICogb3V0c2lkZSB0aCBlbmQgb2YgdGhlIHRhYmxlLCBpdCB3aWxsIHN0YXJ0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgdGFibGUuXG4gICAgICAgICAgICovXG4gICAgICAgICAgbmV3U2VsZWN0aW9uLmFuY2hvci5zZXQoaXNCYWNrd2FyZCA/IGxhc3RDZWxsLmdldEtleSgpIDogZmlyc3RDZWxsLmdldEtleSgpLCBpc0JhY2t3YXJkID8gbGFzdENlbGwuZ2V0Q2hpbGRyZW5TaXplKCkgOiAwLCAnZWxlbWVudCcpO1xuICAgICAgICB9XG4gICAgICAgICRzZXRTZWxlY3Rpb24obmV3U2VsZWN0aW9uKTtcbiAgICAgICAgJGFkZEhpZ2hsaWdodFN0eWxlVG9UYWJsZShlZGl0b3IsIHRhYmxlT2JzZXJ2ZXIpO1xuICAgICAgfSBlbHNlIGlmIChpc1dpdGhpblRhYmxlKSB7XG4gICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gc2VsZWN0aW9uIHNwYW5zIGFjcm9zcyBtdWx0aXBsZSBjZWxscyBidXQgc3RpbGxcbiAgICAgICAgLy8gaGFzIHJhbmdlIHNlbGVjdGlvbiwgdGhlbiB3ZSBjb252ZXJ0IGl0IGludG8gZ3JpZCBzZWxlY3Rpb25cbiAgICAgICAgaWYgKCFhbmNob3JDZWxsTm9kZS5pcyhmb2N1c0NlbGxOb2RlKSkge1xuICAgICAgICAgIHRhYmxlT2JzZXJ2ZXIuc2V0QW5jaG9yQ2VsbEZvclNlbGVjdGlvbihnZXRPYnNlcnZlckNlbGxGcm9tQ2VsbE5vZGUoYW5jaG9yQ2VsbE5vZGUpKTtcbiAgICAgICAgICB0YWJsZU9ic2VydmVyLnNldEZvY3VzQ2VsbEZvclNlbGVjdGlvbihnZXRPYnNlcnZlckNlbGxGcm9tQ2VsbE5vZGUoZm9jdXNDZWxsTm9kZSksIHRydWUpO1xuICAgICAgICAgIGlmICghdGFibGVPYnNlcnZlci5pc1NlbGVjdGluZykge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBvbk1vdXNlVXAsXG4gICAgICAgICAgICAgICAgb25Nb3VzZU1vdmVcbiAgICAgICAgICAgICAgfSA9IGNyZWF0ZU1vdXNlSGFuZGxlcnMoKTtcbiAgICAgICAgICAgICAgdGFibGVPYnNlcnZlci5pc1NlbGVjdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgIGVkaXRvcldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICAgICAgICAgICAgZWRpdG9yV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2VsZWN0aW9uICYmICRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLmlzKHByZXZTZWxlY3Rpb24pICYmIHNlbGVjdGlvbi50YWJsZUtleSA9PT0gdGFibGVOb2RlLmdldEtleSgpKSB7XG4gICAgICAvLyBpZiBzZWxlY3Rpb24gZ29lcyBvdXRzaWRlIG9mIHRoZSB0YWJsZSB3ZSBuZWVkIHRvIGNoYW5nZSBpdCB0byBSYW5nZSBzZWxlY3Rpb25cbiAgICAgIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldERPTVNlbGVjdGlvbihlZGl0b3IuX3dpbmRvdyk7XG4gICAgICBpZiAoZG9tU2VsZWN0aW9uICYmIGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlICYmIGRvbVNlbGVjdGlvbi5mb2N1c05vZGUpIHtcbiAgICAgICAgY29uc3QgZm9jdXNOb2RlID0gJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUoZG9tU2VsZWN0aW9uLmZvY3VzTm9kZSk7XG4gICAgICAgIGNvbnN0IGlzRm9jdXNPdXRzaWRlID0gZm9jdXNOb2RlICYmICF0YWJsZU5vZGUuaXMoJGZpbmRUYWJsZU5vZGUoZm9jdXNOb2RlKSk7XG4gICAgICAgIGNvbnN0IGFuY2hvck5vZGUgPSAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShkb21TZWxlY3Rpb24uYW5jaG9yTm9kZSk7XG4gICAgICAgIGNvbnN0IGlzQW5jaG9ySW5zaWRlID0gYW5jaG9yTm9kZSAmJiB0YWJsZU5vZGUuaXMoJGZpbmRUYWJsZU5vZGUoYW5jaG9yTm9kZSkpO1xuICAgICAgICBpZiAoaXNGb2N1c091dHNpZGUgJiYgaXNBbmNob3JJbnNpZGUgJiYgZG9tU2VsZWN0aW9uLnJhbmdlQ291bnQgPiAwKSB7XG4gICAgICAgICAgY29uc3QgbmV3U2VsZWN0aW9uID0gJGNyZWF0ZVJhbmdlU2VsZWN0aW9uRnJvbURvbShkb21TZWxlY3Rpb24sIGVkaXRvcik7XG4gICAgICAgICAgaWYgKG5ld1NlbGVjdGlvbikge1xuICAgICAgICAgICAgbmV3U2VsZWN0aW9uLmFuY2hvci5zZXQodGFibGVOb2RlLmdldEtleSgpLCBzZWxlY3Rpb24uaXNCYWNrd2FyZCgpID8gdGFibGVOb2RlLmdldENoaWxkcmVuU2l6ZSgpIDogMCwgJ2VsZW1lbnQnKTtcbiAgICAgICAgICAgIGRvbVNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgICRzZXRTZWxlY3Rpb24obmV3U2VsZWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNlbGVjdGlvbiAmJiAhc2VsZWN0aW9uLmlzKHByZXZTZWxlY3Rpb24pICYmICgkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICRpc1RhYmxlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pKSAmJiB0YWJsZU9ic2VydmVyLnRhYmxlU2VsZWN0aW9uICYmICF0YWJsZU9ic2VydmVyLnRhYmxlU2VsZWN0aW9uLmlzKHByZXZTZWxlY3Rpb24pKSB7XG4gICAgICBpZiAoJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiBzZWxlY3Rpb24udGFibGVLZXkgPT09IHRhYmxlT2JzZXJ2ZXIudGFibGVOb2RlS2V5KSB7XG4gICAgICAgIHRhYmxlT2JzZXJ2ZXIudXBkYXRlVGFibGVUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgICAgfSBlbHNlIGlmICghJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiAkaXNUYWJsZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSAmJiBwcmV2U2VsZWN0aW9uLnRhYmxlS2V5ID09PSB0YWJsZU9ic2VydmVyLnRhYmxlTm9kZUtleSkge1xuICAgICAgICB0YWJsZU9ic2VydmVyLnVwZGF0ZVRhYmxlVGFibGVTZWxlY3Rpb24obnVsbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0YWJsZU9ic2VydmVyLmhhc0hpamFja2VkU2VsZWN0aW9uU3R5bGVzICYmICF0YWJsZU5vZGUuaXNTZWxlY3RlZCgpKSB7XG4gICAgICAkcmVtb3ZlSGlnaGxpZ2h0U3R5bGVUb1RhYmxlKGVkaXRvciwgdGFibGVPYnNlcnZlcik7XG4gICAgfSBlbHNlIGlmICghdGFibGVPYnNlcnZlci5oYXNIaWphY2tlZFNlbGVjdGlvblN0eWxlcyAmJiB0YWJsZU5vZGUuaXNTZWxlY3RlZCgpKSB7XG4gICAgICAkYWRkSGlnaGxpZ2h0U3R5bGVUb1RhYmxlKGVkaXRvciwgdGFibGVPYnNlcnZlcik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCkpO1xuICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKElOU0VSVF9QQVJBR1JBUEhfQ09NTUFORCwgKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpIHx8ICEkaXNTZWxlY3Rpb25JblRhYmxlKHNlbGVjdGlvbiwgdGFibGVOb2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBlZGdlUG9zaXRpb24gPSAkZ2V0VGFibGVFZGdlQ3Vyc29yUG9zaXRpb24oZWRpdG9yLCBzZWxlY3Rpb24sIHRhYmxlTm9kZSk7XG4gICAgaWYgKGVkZ2VQb3NpdGlvbikge1xuICAgICAgJGluc2VydFBhcmFncmFwaEF0VGFibGVFZGdlKGVkZ2VQb3NpdGlvbiwgdGFibGVOb2RlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwpKTtcbiAgcmV0dXJuIHRhYmxlT2JzZXJ2ZXI7XG59XG5mdW5jdGlvbiBkZWF0YXRjaFRhYmxlT2JzZXJ2ZXJGcm9tVGFibGVFbGVtZW50KHRhYmxlRWxlbWVudCwgdGFibGVPYnNlcnZlcikge1xuICBpZiAoZ2V0VGFibGVPYnNlcnZlckZyb21UYWJsZUVsZW1lbnQodGFibGVFbGVtZW50KSA9PT0gdGFibGVPYnNlcnZlcikge1xuICAgIGRlbGV0ZSB0YWJsZUVsZW1lbnRbTEVYSUNBTF9FTEVNRU5UX0tFWV07XG4gIH1cbn1cbmZ1bmN0aW9uIGF0dGFjaFRhYmxlT2JzZXJ2ZXJUb1RhYmxlRWxlbWVudCh0YWJsZUVsZW1lbnQsIHRhYmxlT2JzZXJ2ZXIpIHtcbiAgaWYgKCEoZ2V0VGFibGVPYnNlcnZlckZyb21UYWJsZUVsZW1lbnQodGFibGVFbGVtZW50KSA9PT0gbnVsbCkpIHtcbiAgICB0aHJvdyBFcnJvcihgdGFibGVFbGVtZW50IGFscmVhZHkgaGFzIGFuIGF0dGFjaGVkIFRhYmxlT2JzZXJ2ZXJgKTtcbiAgfVxuICB0YWJsZUVsZW1lbnRbTEVYSUNBTF9FTEVNRU5UX0tFWV0gPSB0YWJsZU9ic2VydmVyO1xufVxuZnVuY3Rpb24gZ2V0VGFibGVPYnNlcnZlckZyb21UYWJsZUVsZW1lbnQodGFibGVFbGVtZW50KSB7XG4gIHJldHVybiB0YWJsZUVsZW1lbnRbTEVYSUNBTF9FTEVNRU5UX0tFWV0gfHwgbnVsbDtcbn1cbmZ1bmN0aW9uIGdldERPTUNlbGxGcm9tVGFyZ2V0KG5vZGUpIHtcbiAgbGV0IGN1cnJlbnROb2RlID0gbm9kZTtcbiAgd2hpbGUgKGN1cnJlbnROb2RlICE9IG51bGwpIHtcbiAgICBjb25zdCBub2RlTmFtZSA9IGN1cnJlbnROb2RlLm5vZGVOYW1lO1xuICAgIGlmIChub2RlTmFtZSA9PT0gJ1REJyB8fCBub2RlTmFtZSA9PT0gJ1RIJykge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcbiAgICAgIGNvbnN0IGNlbGwgPSBjdXJyZW50Tm9kZS5fY2VsbDtcbiAgICAgIGlmIChjZWxsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2VsbDtcbiAgICB9XG4gICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0VGFibGUodGFibGVFbGVtZW50KSB7XG4gIGNvbnN0IGRvbVJvd3MgPSBbXTtcbiAgY29uc3QgZ3JpZCA9IHtcbiAgICBjb2x1bW5zOiAwLFxuICAgIGRvbVJvd3MsXG4gICAgcm93czogMFxuICB9O1xuICBsZXQgY3VycmVudE5vZGUgPSB0YWJsZUVsZW1lbnQucXVlcnlTZWxlY3RvcigndHInKTtcbiAgbGV0IHggPSAwO1xuICBsZXQgeSA9IDA7XG4gIGRvbVJvd3MubGVuZ3RoID0gMDtcbiAgd2hpbGUgKGN1cnJlbnROb2RlICE9IG51bGwpIHtcbiAgICBjb25zdCBub2RlTWFtZSA9IGN1cnJlbnROb2RlLm5vZGVOYW1lO1xuICAgIGlmIChub2RlTWFtZSA9PT0gJ1REJyB8fCBub2RlTWFtZSA9PT0gJ1RIJykge1xuICAgICAgY29uc3QgZWxlbSA9IGN1cnJlbnROb2RlO1xuICAgICAgY29uc3QgY2VsbCA9IHtcbiAgICAgICAgZWxlbSxcbiAgICAgICAgaGFzQmFja2dyb3VuZENvbG9yOiBlbGVtLnN0eWxlLmJhY2tncm91bmRDb2xvciAhPT0gJycsXG4gICAgICAgIGhpZ2hsaWdodGVkOiBmYWxzZSxcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfTtcblxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcbiAgICAgIGN1cnJlbnROb2RlLl9jZWxsID0gY2VsbDtcbiAgICAgIGxldCByb3cgPSBkb21Sb3dzW3ldO1xuICAgICAgaWYgKHJvdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJvdyA9IGRvbVJvd3NbeV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHJvd1t4XSA9IGNlbGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY3VycmVudE5vZGUuZmlyc3RDaGlsZDtcbiAgICAgIGlmIChjaGlsZCAhPSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnROb2RlID0gY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzaWJsaW5nID0gY3VycmVudE5vZGUubmV4dFNpYmxpbmc7XG4gICAgaWYgKHNpYmxpbmcgIT0gbnVsbCkge1xuICAgICAgeCsrO1xuICAgICAgY3VycmVudE5vZGUgPSBzaWJsaW5nO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudCA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgaWYgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgICBjb25zdCBwYXJlbnRTaWJsaW5nID0gcGFyZW50Lm5leHRTaWJsaW5nO1xuICAgICAgaWYgKHBhcmVudFNpYmxpbmcgPT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHkrKztcbiAgICAgIHggPSAwO1xuICAgICAgY3VycmVudE5vZGUgPSBwYXJlbnRTaWJsaW5nO1xuICAgIH1cbiAgfVxuICBncmlkLmNvbHVtbnMgPSB4ICsgMTtcbiAgZ3JpZC5yb3dzID0geSArIDE7XG4gIHJldHVybiBncmlkO1xufVxuZnVuY3Rpb24gJHVwZGF0ZURPTUZvclNlbGVjdGlvbihlZGl0b3IsIHRhYmxlLCBzZWxlY3Rpb24pIHtcbiAgY29uc3Qgc2VsZWN0ZWRDZWxsTm9kZXMgPSBuZXcgU2V0KHNlbGVjdGlvbiA/IHNlbGVjdGlvbi5nZXROb2RlcygpIDogW10pO1xuICAkZm9yRWFjaFRhYmxlQ2VsbCh0YWJsZSwgKGNlbGwsIGxleGljYWxOb2RlKSA9PiB7XG4gICAgY29uc3QgZWxlbSA9IGNlbGwuZWxlbTtcbiAgICBpZiAoc2VsZWN0ZWRDZWxsTm9kZXMuaGFzKGxleGljYWxOb2RlKSkge1xuICAgICAgY2VsbC5oaWdobGlnaHRlZCA9IHRydWU7XG4gICAgICAkYWRkSGlnaGxpZ2h0VG9ET00oZWRpdG9yLCBjZWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2VsbC5oaWdobGlnaHRlZCA9IGZhbHNlO1xuICAgICAgJHJlbW92ZUhpZ2hsaWdodEZyb21ET00oZWRpdG9yLCBjZWxsKTtcbiAgICAgIGlmICghZWxlbS5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykpIHtcbiAgICAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uICRmb3JFYWNoVGFibGVDZWxsKGdyaWQsIGNiKSB7XG4gIGNvbnN0IHtcbiAgICBkb21Sb3dzXG4gIH0gPSBncmlkO1xuICBmb3IgKGxldCB5ID0gMDsgeSA8IGRvbVJvd3MubGVuZ3RoOyB5KyspIHtcbiAgICBjb25zdCByb3cgPSBkb21Sb3dzW3ldO1xuICAgIGlmICghcm93KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCByb3cubGVuZ3RoOyB4KyspIHtcbiAgICAgIGNvbnN0IGNlbGwgPSByb3dbeF07XG4gICAgICBpZiAoIWNlbGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBsZXhpY2FsTm9kZSA9ICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGNlbGwuZWxlbSk7XG4gICAgICBpZiAobGV4aWNhbE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgY2IoY2VsbCwgbGV4aWNhbE5vZGUsIHtcbiAgICAgICAgICB4LFxuICAgICAgICAgIHlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiAkYWRkSGlnaGxpZ2h0U3R5bGVUb1RhYmxlKGVkaXRvciwgdGFibGVTZWxlY3Rpb24pIHtcbiAgdGFibGVTZWxlY3Rpb24uZGlzYWJsZUhpZ2hsaWdodFN0eWxlKCk7XG4gICRmb3JFYWNoVGFibGVDZWxsKHRhYmxlU2VsZWN0aW9uLnRhYmxlLCBjZWxsID0+IHtcbiAgICBjZWxsLmhpZ2hsaWdodGVkID0gdHJ1ZTtcbiAgICAkYWRkSGlnaGxpZ2h0VG9ET00oZWRpdG9yLCBjZWxsKTtcbiAgfSk7XG59XG5mdW5jdGlvbiAkcmVtb3ZlSGlnaGxpZ2h0U3R5bGVUb1RhYmxlKGVkaXRvciwgdGFibGVPYnNlcnZlcikge1xuICB0YWJsZU9ic2VydmVyLmVuYWJsZUhpZ2hsaWdodFN0eWxlKCk7XG4gICRmb3JFYWNoVGFibGVDZWxsKHRhYmxlT2JzZXJ2ZXIudGFibGUsIGNlbGwgPT4ge1xuICAgIGNvbnN0IGVsZW0gPSBjZWxsLmVsZW07XG4gICAgY2VsbC5oaWdobGlnaHRlZCA9IGZhbHNlO1xuICAgICRyZW1vdmVIaWdobGlnaHRGcm9tRE9NKGVkaXRvciwgY2VsbCk7XG4gICAgaWYgKCFlbGVtLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSkge1xuICAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgfVxuICB9KTtcbn1cbmNvbnN0IHNlbGVjdFRhYmxlTm9kZUluRGlyZWN0aW9uID0gKHRhYmxlT2JzZXJ2ZXIsIHRhYmxlTm9kZSwgeCwgeSwgZGlyZWN0aW9uKSA9PiB7XG4gIGNvbnN0IGlzRm9yd2FyZCA9IGRpcmVjdGlvbiA9PT0gJ2ZvcndhcmQnO1xuICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgIGNhc2UgJ2JhY2t3YXJkJzpcbiAgICBjYXNlICdmb3J3YXJkJzpcbiAgICAgIGlmICh4ICE9PSAoaXNGb3J3YXJkID8gdGFibGVPYnNlcnZlci50YWJsZS5jb2x1bW5zIC0gMSA6IDApKSB7XG4gICAgICAgIHNlbGVjdFRhYmxlQ2VsbE5vZGUodGFibGVOb2RlLmdldENlbGxOb2RlRnJvbUNvcmRzT3JUaHJvdyh4ICsgKGlzRm9yd2FyZCA/IDEgOiAtMSksIHksIHRhYmxlT2JzZXJ2ZXIudGFibGUpLCBpc0ZvcndhcmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHkgIT09IChpc0ZvcndhcmQgPyB0YWJsZU9ic2VydmVyLnRhYmxlLnJvd3MgLSAxIDogMCkpIHtcbiAgICAgICAgICBzZWxlY3RUYWJsZUNlbGxOb2RlKHRhYmxlTm9kZS5nZXRDZWxsTm9kZUZyb21Db3Jkc09yVGhyb3coaXNGb3J3YXJkID8gMCA6IHRhYmxlT2JzZXJ2ZXIudGFibGUuY29sdW1ucyAtIDEsIHkgKyAoaXNGb3J3YXJkID8gMSA6IC0xKSwgdGFibGVPYnNlcnZlci50YWJsZSksIGlzRm9yd2FyZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzRm9yd2FyZCkge1xuICAgICAgICAgIHRhYmxlTm9kZS5zZWxlY3RQcmV2aW91cygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhYmxlTm9kZS5zZWxlY3ROZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGNhc2UgJ3VwJzpcbiAgICAgIGlmICh5ICE9PSAwKSB7XG4gICAgICAgIHNlbGVjdFRhYmxlQ2VsbE5vZGUodGFibGVOb2RlLmdldENlbGxOb2RlRnJvbUNvcmRzT3JUaHJvdyh4LCB5IC0gMSwgdGFibGVPYnNlcnZlci50YWJsZSksIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhYmxlTm9kZS5zZWxlY3RQcmV2aW91cygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSAnZG93bic6XG4gICAgICBpZiAoeSAhPT0gdGFibGVPYnNlcnZlci50YWJsZS5yb3dzIC0gMSkge1xuICAgICAgICBzZWxlY3RUYWJsZUNlbGxOb2RlKHRhYmxlTm9kZS5nZXRDZWxsTm9kZUZyb21Db3Jkc09yVGhyb3coeCwgeSArIDEsIHRhYmxlT2JzZXJ2ZXIudGFibGUpLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhYmxlTm9kZS5zZWxlY3ROZXh0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuY29uc3QgYWRqdXN0Rm9jdXNOb2RlSW5EaXJlY3Rpb24gPSAodGFibGVPYnNlcnZlciwgdGFibGVOb2RlLCB4LCB5LCBkaXJlY3Rpb24pID0+IHtcbiAgY29uc3QgaXNGb3J3YXJkID0gZGlyZWN0aW9uID09PSAnZm9yd2FyZCc7XG4gIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgY2FzZSAnYmFja3dhcmQnOlxuICAgIGNhc2UgJ2ZvcndhcmQnOlxuICAgICAgaWYgKHggIT09IChpc0ZvcndhcmQgPyB0YWJsZU9ic2VydmVyLnRhYmxlLmNvbHVtbnMgLSAxIDogMCkpIHtcbiAgICAgICAgdGFibGVPYnNlcnZlci5zZXRGb2N1c0NlbGxGb3JTZWxlY3Rpb24odGFibGVOb2RlLmdldERPTUNlbGxGcm9tQ29yZHNPclRocm93KHggKyAoaXNGb3J3YXJkID8gMSA6IC0xKSwgeSwgdGFibGVPYnNlcnZlci50YWJsZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSAndXAnOlxuICAgICAgaWYgKHkgIT09IDApIHtcbiAgICAgICAgdGFibGVPYnNlcnZlci5zZXRGb2N1c0NlbGxGb3JTZWxlY3Rpb24odGFibGVOb2RlLmdldERPTUNlbGxGcm9tQ29yZHNPclRocm93KHgsIHkgLSAxLCB0YWJsZU9ic2VydmVyLnRhYmxlKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIGNhc2UgJ2Rvd24nOlxuICAgICAgaWYgKHkgIT09IHRhYmxlT2JzZXJ2ZXIudGFibGUucm93cyAtIDEpIHtcbiAgICAgICAgdGFibGVPYnNlcnZlci5zZXRGb2N1c0NlbGxGb3JTZWxlY3Rpb24odGFibGVOb2RlLmdldERPTUNlbGxGcm9tQ29yZHNPclRocm93KHgsIHkgKyAxLCB0YWJsZU9ic2VydmVyLnRhYmxlKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5mdW5jdGlvbiAkaXNTZWxlY3Rpb25JblRhYmxlKHNlbGVjdGlvbiwgdGFibGVOb2RlKSB7XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICBjb25zdCBpc0FuY2hvckluc2lkZSA9IHRhYmxlTm9kZS5pc1BhcmVudE9mKHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpKTtcbiAgICBjb25zdCBpc0ZvY3VzSW5zaWRlID0gdGFibGVOb2RlLmlzUGFyZW50T2Yoc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKSk7XG4gICAgcmV0dXJuIGlzQW5jaG9ySW5zaWRlICYmIGlzRm9jdXNJbnNpZGU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc2VsZWN0VGFibGVDZWxsTm9kZSh0YWJsZUNlbGwsIGZyb21TdGFydCkge1xuICBpZiAoZnJvbVN0YXJ0KSB7XG4gICAgdGFibGVDZWxsLnNlbGVjdFN0YXJ0KCk7XG4gIH0gZWxzZSB7XG4gICAgdGFibGVDZWxsLnNlbGVjdEVuZCgpO1xuICB9XG59XG5jb25zdCBCUk9XU0VSX0JMVUVfUkdCID0gJzE3MiwyMDYsMjQ3JztcbmZ1bmN0aW9uICRhZGRIaWdobGlnaHRUb0RPTShlZGl0b3IsIGNlbGwpIHtcbiAgY29uc3QgZWxlbWVudCA9IGNlbGwuZWxlbTtcbiAgY29uc3Qgbm9kZSA9ICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGVsZW1lbnQpO1xuICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUobm9kZSkpIHtcbiAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgdG8gZmluZCBMZXhpY2FsTm9kZSBmcm9tIFRhYmxlIENlbGwgRE9NTm9kZWApO1xuICB9XG4gIGNvbnN0IGJhY2tncm91bmRDb2xvciA9IG5vZGUuZ2V0QmFja2dyb3VuZENvbG9yKCk7XG4gIGlmIChiYWNrZ3JvdW5kQ29sb3IgPT09IG51bGwpIHtcbiAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KCdiYWNrZ3JvdW5kLWNvbG9yJywgYHJnYigke0JST1dTRVJfQkxVRV9SR0J9KWApO1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoJ2JhY2tncm91bmQtaW1hZ2UnLCBgbGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LCByZ2JhKCR7QlJPV1NFUl9CTFVFX1JHQn0sMC44NSksIHJnYmEoJHtCUk9XU0VSX0JMVUVfUkdCfSwwLjg1KSlgKTtcbiAgfVxuICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KCdjYXJldC1jb2xvcicsICd0cmFuc3BhcmVudCcpO1xufVxuZnVuY3Rpb24gJHJlbW92ZUhpZ2hsaWdodEZyb21ET00oZWRpdG9yLCBjZWxsKSB7XG4gIGNvbnN0IGVsZW1lbnQgPSBjZWxsLmVsZW07XG4gIGNvbnN0IG5vZGUgPSAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShlbGVtZW50KTtcbiAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKG5vZGUpKSB7XG4gICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIHRvIGZpbmQgTGV4aWNhbE5vZGUgZnJvbSBUYWJsZSBDZWxsIERPTU5vZGVgKTtcbiAgfVxuICBjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBub2RlLmdldEJhY2tncm91bmRDb2xvcigpO1xuICBpZiAoYmFja2dyb3VuZENvbG9yID09PSBudWxsKSB7XG4gICAgZWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnYmFja2dyb3VuZC1jb2xvcicpO1xuICB9XG4gIGVsZW1lbnQuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ2JhY2tncm91bmQtaW1hZ2UnKTtcbiAgZWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnY2FyZXQtY29sb3InKTtcbn1cbmZ1bmN0aW9uICRmaW5kQ2VsbE5vZGUobm9kZSkge1xuICBjb25zdCBjZWxsTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQobm9kZSwgJGlzVGFibGVDZWxsTm9kZSk7XG4gIHJldHVybiAkaXNUYWJsZUNlbGxOb2RlKGNlbGxOb2RlKSA/IGNlbGxOb2RlIDogbnVsbDtcbn1cbmZ1bmN0aW9uICRmaW5kVGFibGVOb2RlKG5vZGUpIHtcbiAgY29uc3QgdGFibGVOb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChub2RlLCAkaXNUYWJsZU5vZGUpO1xuICByZXR1cm4gJGlzVGFibGVOb2RlKHRhYmxlTm9kZSkgPyB0YWJsZU5vZGUgOiBudWxsO1xufVxuZnVuY3Rpb24gJGhhbmRsZUFycm93S2V5KGVkaXRvciwgZXZlbnQsIGRpcmVjdGlvbiwgdGFibGVOb2RlLCB0YWJsZU9ic2VydmVyKSB7XG4gIGlmICgoZGlyZWN0aW9uID09PSAndXAnIHx8IGRpcmVjdGlvbiA9PT0gJ2Rvd24nKSAmJiBpc1R5cGVhaGVhZE1lbnVJblZpZXcoZWRpdG9yKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gIGlmICghJGlzU2VsZWN0aW9uSW5UYWJsZShzZWxlY3Rpb24sIHRhYmxlTm9kZSkpIHtcbiAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgaWYgKHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpICYmIGRpcmVjdGlvbiA9PT0gJ2JhY2t3YXJkJykge1xuICAgICAgICBjb25zdCBhbmNob3JUeXBlID0gc2VsZWN0aW9uLmFuY2hvci50eXBlO1xuICAgICAgICBjb25zdCBhbmNob3JPZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yLm9mZnNldDtcbiAgICAgICAgaWYgKGFuY2hvclR5cGUgIT09ICdlbGVtZW50JyAmJiAhKGFuY2hvclR5cGUgPT09ICd0ZXh0JyAmJiBhbmNob3JPZmZzZXQgPT09IDApKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgICAgaWYgKCFhbmNob3JOb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGFuY2hvck5vZGUsIG4gPT4gJGlzRWxlbWVudE5vZGUobikgJiYgIW4uaXNJbmxpbmUoKSk7XG4gICAgICAgIGlmICghcGFyZW50Tm9kZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaWJsaW5nTm9kZSA9IHBhcmVudE5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICAgIGlmICghc2libGluZ05vZGUgfHwgISRpc1RhYmxlTm9kZShzaWJsaW5nTm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgc2libGluZ05vZGUuc2VsZWN0RW5kKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChldmVudC5zaGlmdEtleSAmJiAoZGlyZWN0aW9uID09PSAndXAnIHx8IGRpcmVjdGlvbiA9PT0gJ2Rvd24nKSkge1xuICAgICAgICBjb25zdCBmb2N1c05vZGUgPSBzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpO1xuICAgICAgICBjb25zdCBpc1RhYmxlVW5zZWxlY3QgPSAhc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgKGRpcmVjdGlvbiA9PT0gJ3VwJyAmJiAhc2VsZWN0aW9uLmlzQmFja3dhcmQoKSB8fCBkaXJlY3Rpb24gPT09ICdkb3duJyAmJiBzZWxlY3Rpb24uaXNCYWNrd2FyZCgpKTtcbiAgICAgICAgaWYgKGlzVGFibGVVbnNlbGVjdCkge1xuICAgICAgICAgIGxldCBmb2N1c1BhcmVudE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGZvY3VzTm9kZSwgbiA9PiAkaXNUYWJsZU5vZGUobikpO1xuICAgICAgICAgIGlmICgkaXNUYWJsZUNlbGxOb2RlKGZvY3VzUGFyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgIGZvY3VzUGFyZW50Tm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoZm9jdXNQYXJlbnROb2RlLCAkaXNUYWJsZU5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZm9jdXNQYXJlbnROb2RlICE9PSB0YWJsZU5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFmb2N1c1BhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc2libGluZyA9IGRpcmVjdGlvbiA9PT0gJ2Rvd24nID8gZm9jdXNQYXJlbnROb2RlLmdldE5leHRTaWJsaW5nKCkgOiBmb2N1c1BhcmVudE5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICAgICAgaWYgKCFzaWJsaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBuZXdPZmZzZXQgPSAwO1xuICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICd1cCcpIHtcbiAgICAgICAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShzaWJsaW5nKSkge1xuICAgICAgICAgICAgICBuZXdPZmZzZXQgPSBzaWJsaW5nLmdldENoaWxkcmVuU2l6ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgbmV3Rm9jdXNOb2RlID0gc2libGluZztcbiAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAndXAnKSB7XG4gICAgICAgICAgICBpZiAoJGlzRWxlbWVudE5vZGUoc2libGluZykpIHtcbiAgICAgICAgICAgICAgY29uc3QgbGFzdENlbGwgPSBzaWJsaW5nLmdldExhc3RDaGlsZCgpO1xuICAgICAgICAgICAgICBuZXdGb2N1c05vZGUgPSBsYXN0Q2VsbCA/IGxhc3RDZWxsIDogc2libGluZztcbiAgICAgICAgICAgICAgbmV3T2Zmc2V0ID0gJGlzVGV4dE5vZGUobmV3Rm9jdXNOb2RlKSA/IG5ld0ZvY3VzTm9kZS5nZXRUZXh0Q29udGVudFNpemUoKSA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG5ld1NlbGVjdGlvbiA9IHNlbGVjdGlvbi5jbG9uZSgpO1xuICAgICAgICAgIG5ld1NlbGVjdGlvbi5mb2N1cy5zZXQobmV3Rm9jdXNOb2RlLmdldEtleSgpLCBuZXdPZmZzZXQsICRpc1RleHROb2RlKG5ld0ZvY3VzTm9kZSkgPyAndGV4dCcgOiAnZWxlbWVudCcpO1xuICAgICAgICAgICRzZXRTZWxlY3Rpb24obmV3U2VsZWN0aW9uKTtcbiAgICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKCRpc1Jvb3RPclNoYWRvd1Jvb3QoZm9jdXNOb2RlKSkge1xuICAgICAgICAgIGNvbnN0IHNlbGVjdGVkTm9kZSA9IGRpcmVjdGlvbiA9PT0gJ3VwJyA/IHNlbGVjdGlvbi5nZXROb2RlcygpW3NlbGVjdGlvbi5nZXROb2RlcygpLmxlbmd0aCAtIDFdIDogc2VsZWN0aW9uLmdldE5vZGVzKClbMF07XG4gICAgICAgICAgaWYgKHNlbGVjdGVkTm9kZSkge1xuICAgICAgICAgICAgY29uc3QgdGFibGVDZWxsTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc2VsZWN0ZWROb2RlLCAkaXNUYWJsZUNlbGxOb2RlKTtcbiAgICAgICAgICAgIGlmICh0YWJsZUNlbGxOb2RlICYmIHRhYmxlTm9kZS5pc1BhcmVudE9mKHRhYmxlQ2VsbE5vZGUpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGZpcnN0RGVzY2VuZGFudCA9IHRhYmxlTm9kZS5nZXRGaXJzdERlc2NlbmRhbnQoKTtcbiAgICAgICAgICAgICAgY29uc3QgbGFzdERlc2NlbmRhbnQgPSB0YWJsZU5vZGUuZ2V0TGFzdERlc2NlbmRhbnQoKTtcbiAgICAgICAgICAgICAgaWYgKCFmaXJzdERlc2NlbmRhbnQgfHwgIWxhc3REZXNjZW5kYW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IFtmaXJzdENlbGxOb2RlXSA9ICRnZXROb2RlVHJpcGxldChmaXJzdERlc2NlbmRhbnQpO1xuICAgICAgICAgICAgICBjb25zdCBbbGFzdENlbGxOb2RlXSA9ICRnZXROb2RlVHJpcGxldChsYXN0RGVzY2VuZGFudCk7XG4gICAgICAgICAgICAgIGNvbnN0IGZpcnN0Q2VsbENvb3JkcyA9IHRhYmxlTm9kZS5nZXRDb3Jkc0Zyb21DZWxsTm9kZShmaXJzdENlbGxOb2RlLCB0YWJsZU9ic2VydmVyLnRhYmxlKTtcbiAgICAgICAgICAgICAgY29uc3QgbGFzdENlbGxDb29yZHMgPSB0YWJsZU5vZGUuZ2V0Q29yZHNGcm9tQ2VsbE5vZGUobGFzdENlbGxOb2RlLCB0YWJsZU9ic2VydmVyLnRhYmxlKTtcbiAgICAgICAgICAgICAgY29uc3QgZmlyc3RDZWxsRE9NID0gdGFibGVOb2RlLmdldERPTUNlbGxGcm9tQ29yZHNPclRocm93KGZpcnN0Q2VsbENvb3Jkcy54LCBmaXJzdENlbGxDb29yZHMueSwgdGFibGVPYnNlcnZlci50YWJsZSk7XG4gICAgICAgICAgICAgIGNvbnN0IGxhc3RDZWxsRE9NID0gdGFibGVOb2RlLmdldERPTUNlbGxGcm9tQ29yZHNPclRocm93KGxhc3RDZWxsQ29vcmRzLngsIGxhc3RDZWxsQ29vcmRzLnksIHRhYmxlT2JzZXJ2ZXIudGFibGUpO1xuICAgICAgICAgICAgICB0YWJsZU9ic2VydmVyLnNldEFuY2hvckNlbGxGb3JTZWxlY3Rpb24oZmlyc3RDZWxsRE9NKTtcbiAgICAgICAgICAgICAgdGFibGVPYnNlcnZlci5zZXRGb2N1c0NlbGxGb3JTZWxlY3Rpb24obGFzdENlbGxET00sIHRydWUpO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBmb2N1c1BhcmVudE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGZvY3VzTm9kZSwgbiA9PiAkaXNFbGVtZW50Tm9kZShuKSAmJiAhbi5pc0lubGluZSgpKTtcbiAgICAgICAgICBpZiAoJGlzVGFibGVDZWxsTm9kZShmb2N1c1BhcmVudE5vZGUpKSB7XG4gICAgICAgICAgICBmb2N1c1BhcmVudE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGZvY3VzUGFyZW50Tm9kZSwgJGlzVGFibGVOb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFmb2N1c1BhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc2libGluZyA9IGRpcmVjdGlvbiA9PT0gJ2Rvd24nID8gZm9jdXNQYXJlbnROb2RlLmdldE5leHRTaWJsaW5nKCkgOiBmb2N1c1BhcmVudE5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICAgICAgaWYgKCRpc1RhYmxlTm9kZShzaWJsaW5nKSAmJiB0YWJsZU9ic2VydmVyLnRhYmxlTm9kZUtleSA9PT0gc2libGluZy5nZXRLZXkoKSkge1xuICAgICAgICAgICAgY29uc3QgZmlyc3REZXNjZW5kYW50ID0gc2libGluZy5nZXRGaXJzdERlc2NlbmRhbnQoKTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3REZXNjZW5kYW50ID0gc2libGluZy5nZXRMYXN0RGVzY2VuZGFudCgpO1xuICAgICAgICAgICAgaWYgKCFmaXJzdERlc2NlbmRhbnQgfHwgIWxhc3REZXNjZW5kYW50KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IFtmaXJzdENlbGxOb2RlXSA9ICRnZXROb2RlVHJpcGxldChmaXJzdERlc2NlbmRhbnQpO1xuICAgICAgICAgICAgY29uc3QgW2xhc3RDZWxsTm9kZV0gPSAkZ2V0Tm9kZVRyaXBsZXQobGFzdERlc2NlbmRhbnQpO1xuICAgICAgICAgICAgY29uc3QgbmV3U2VsZWN0aW9uID0gc2VsZWN0aW9uLmNsb25lKCk7XG4gICAgICAgICAgICBuZXdTZWxlY3Rpb24uZm9jdXMuc2V0KChkaXJlY3Rpb24gPT09ICd1cCcgPyBmaXJzdENlbGxOb2RlIDogbGFzdENlbGxOb2RlKS5nZXRLZXkoKSwgZGlyZWN0aW9uID09PSAndXAnID8gMCA6IGxhc3RDZWxsTm9kZS5nZXRDaGlsZHJlblNpemUoKSwgJ2VsZW1lbnQnKTtcbiAgICAgICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgICAgICAkc2V0U2VsZWN0aW9uKG5ld1NlbGVjdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgY29uc3Qge1xuICAgICAgYW5jaG9yLFxuICAgICAgZm9jdXNcbiAgICB9ID0gc2VsZWN0aW9uO1xuICAgIGNvbnN0IGFuY2hvckNlbGxOb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChhbmNob3IuZ2V0Tm9kZSgpLCAkaXNUYWJsZUNlbGxOb2RlKTtcbiAgICBjb25zdCBmb2N1c0NlbGxOb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChmb2N1cy5nZXROb2RlKCksICRpc1RhYmxlQ2VsbE5vZGUpO1xuICAgIGlmICghJGlzVGFibGVDZWxsTm9kZShhbmNob3JDZWxsTm9kZSkgfHwgIWFuY2hvckNlbGxOb2RlLmlzKGZvY3VzQ2VsbE5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGFuY2hvckNlbGxUYWJsZSA9ICRmaW5kVGFibGVOb2RlKGFuY2hvckNlbGxOb2RlKTtcbiAgICBpZiAoYW5jaG9yQ2VsbFRhYmxlICE9PSB0YWJsZU5vZGUgJiYgYW5jaG9yQ2VsbFRhYmxlICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGFuY2hvckNlbGxUYWJsZUVsZW1lbnQgPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGFuY2hvckNlbGxUYWJsZS5nZXRLZXkoKSk7XG4gICAgICBpZiAoYW5jaG9yQ2VsbFRhYmxlRWxlbWVudCAhPSBudWxsKSB7XG4gICAgICAgIHRhYmxlT2JzZXJ2ZXIudGFibGUgPSBnZXRUYWJsZShhbmNob3JDZWxsVGFibGVFbGVtZW50KTtcbiAgICAgICAgcmV0dXJuICRoYW5kbGVBcnJvd0tleShlZGl0b3IsIGV2ZW50LCBkaXJlY3Rpb24sIGFuY2hvckNlbGxUYWJsZSwgdGFibGVPYnNlcnZlcik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkaXJlY3Rpb24gPT09ICdiYWNrd2FyZCcgfHwgZGlyZWN0aW9uID09PSAnZm9yd2FyZCcpIHtcbiAgICAgIGNvbnN0IGFuY2hvclR5cGUgPSBhbmNob3IudHlwZTtcbiAgICAgIGNvbnN0IGFuY2hvck9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gICAgICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgIGlmICghYW5jaG9yTm9kZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBzZWxlY3RlZE5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gICAgICBpZiAoc2VsZWN0ZWROb2Rlcy5sZW5ndGggPT09IDEgJiYgJGlzRGVjb3JhdG9yTm9kZShzZWxlY3RlZE5vZGVzWzBdKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNFeGl0aW5nVGFibGVBbmNob3IoYW5jaG9yVHlwZSwgYW5jaG9yT2Zmc2V0LCBhbmNob3JOb2RlLCBkaXJlY3Rpb24pKSB7XG4gICAgICAgIHJldHVybiAkaGFuZGxlVGFibGVFeGl0KGV2ZW50LCBhbmNob3JOb2RlLCB0YWJsZU5vZGUsIGRpcmVjdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGFuY2hvckNlbGxEb20gPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGFuY2hvckNlbGxOb2RlLl9fa2V5KTtcbiAgICBjb25zdCBhbmNob3JET00gPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGFuY2hvci5rZXkpO1xuICAgIGlmIChhbmNob3JET00gPT0gbnVsbCB8fCBhbmNob3JDZWxsRG9tID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IGVkZ2VTZWxlY3Rpb25SZWN0O1xuICAgIGlmIChhbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnKSB7XG4gICAgICBlZGdlU2VsZWN0aW9uUmVjdCA9IGFuY2hvckRPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZG9tU2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgaWYgKGRvbVNlbGVjdGlvbiA9PT0gbnVsbCB8fCBkb21TZWxlY3Rpb24ucmFuZ2VDb3VudCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCByYW5nZSA9IGRvbVNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuICAgICAgZWRnZVNlbGVjdGlvblJlY3QgPSByYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG4gICAgY29uc3QgZWRnZUNoaWxkID0gZGlyZWN0aW9uID09PSAndXAnID8gYW5jaG9yQ2VsbE5vZGUuZ2V0Rmlyc3RDaGlsZCgpIDogYW5jaG9yQ2VsbE5vZGUuZ2V0TGFzdENoaWxkKCk7XG4gICAgaWYgKGVkZ2VDaGlsZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGVkZ2VDaGlsZERPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoZWRnZUNoaWxkLl9fa2V5KTtcbiAgICBpZiAoZWRnZUNoaWxkRE9NID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgZWRnZVJlY3QgPSBlZGdlQ2hpbGRET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgaXNFeGl0aW5nID0gZGlyZWN0aW9uID09PSAndXAnID8gZWRnZVJlY3QudG9wID4gZWRnZVNlbGVjdGlvblJlY3QudG9wIC0gZWRnZVNlbGVjdGlvblJlY3QuaGVpZ2h0IDogZWRnZVNlbGVjdGlvblJlY3QuYm90dG9tICsgZWRnZVNlbGVjdGlvblJlY3QuaGVpZ2h0ID4gZWRnZVJlY3QuYm90dG9tO1xuICAgIGlmIChpc0V4aXRpbmcpIHtcbiAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICBjb25zdCBjb3JkcyA9IHRhYmxlTm9kZS5nZXRDb3Jkc0Zyb21DZWxsTm9kZShhbmNob3JDZWxsTm9kZSwgdGFibGVPYnNlcnZlci50YWJsZSk7XG4gICAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgY29uc3QgY2VsbCA9IHRhYmxlTm9kZS5nZXRET01DZWxsRnJvbUNvcmRzT3JUaHJvdyhjb3Jkcy54LCBjb3Jkcy55LCB0YWJsZU9ic2VydmVyLnRhYmxlKTtcbiAgICAgICAgdGFibGVPYnNlcnZlci5zZXRBbmNob3JDZWxsRm9yU2VsZWN0aW9uKGNlbGwpO1xuICAgICAgICB0YWJsZU9ic2VydmVyLnNldEZvY3VzQ2VsbEZvclNlbGVjdGlvbihjZWxsLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzZWxlY3RUYWJsZU5vZGVJbkRpcmVjdGlvbih0YWJsZU9ic2VydmVyLCB0YWJsZU5vZGUsIGNvcmRzLngsIGNvcmRzLnksIGRpcmVjdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfSA9IHNlbGVjdGlvbjtcbiAgICBjb25zdCBhbmNob3JDZWxsTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoYW5jaG9yLmdldE5vZGUoKSwgJGlzVGFibGVDZWxsTm9kZSk7XG4gICAgY29uc3QgZm9jdXNDZWxsTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoZm9jdXMuZ2V0Tm9kZSgpLCAkaXNUYWJsZUNlbGxOb2RlKTtcbiAgICBjb25zdCBbdGFibGVOb2RlRnJvbVNlbGVjdGlvbl0gPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgICBjb25zdCB0YWJsZUVsZW1lbnQgPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KHRhYmxlTm9kZUZyb21TZWxlY3Rpb24uZ2V0S2V5KCkpO1xuICAgIGlmICghJGlzVGFibGVDZWxsTm9kZShhbmNob3JDZWxsTm9kZSkgfHwgISRpc1RhYmxlQ2VsbE5vZGUoZm9jdXNDZWxsTm9kZSkgfHwgISRpc1RhYmxlTm9kZSh0YWJsZU5vZGVGcm9tU2VsZWN0aW9uKSB8fCB0YWJsZUVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0YWJsZU9ic2VydmVyLnVwZGF0ZVRhYmxlVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICBjb25zdCBncmlkID0gZ2V0VGFibGUodGFibGVFbGVtZW50KTtcbiAgICBjb25zdCBjb3Jkc0FuY2hvciA9IHRhYmxlTm9kZS5nZXRDb3Jkc0Zyb21DZWxsTm9kZShhbmNob3JDZWxsTm9kZSwgZ3JpZCk7XG4gICAgY29uc3QgYW5jaG9yQ2VsbCA9IHRhYmxlTm9kZS5nZXRET01DZWxsRnJvbUNvcmRzT3JUaHJvdyhjb3Jkc0FuY2hvci54LCBjb3Jkc0FuY2hvci55LCBncmlkKTtcbiAgICB0YWJsZU9ic2VydmVyLnNldEFuY2hvckNlbGxGb3JTZWxlY3Rpb24oYW5jaG9yQ2VsbCk7XG4gICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgIGNvbnN0IGNvcmRzID0gdGFibGVOb2RlLmdldENvcmRzRnJvbUNlbGxOb2RlKGZvY3VzQ2VsbE5vZGUsIGdyaWQpO1xuICAgICAgcmV0dXJuIGFkanVzdEZvY3VzTm9kZUluRGlyZWN0aW9uKHRhYmxlT2JzZXJ2ZXIsIHRhYmxlTm9kZUZyb21TZWxlY3Rpb24sIGNvcmRzLngsIGNvcmRzLnksIGRpcmVjdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvY3VzQ2VsbE5vZGUuc2VsZWN0RW5kKCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHN0b3BFdmVudChldmVudCkge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG59XG5mdW5jdGlvbiBpc1R5cGVhaGVhZE1lbnVJblZpZXcoZWRpdG9yKSB7XG4gIC8vIFRoZXJlIGlzIG5vIGluYnVpbHQgd2F5IHRvIGNoZWNrIGlmIHRoZSBjb21wb25lbnQgcGlja2VyIGlzIGluIHZpZXdcbiAgLy8gYnV0IHdlIGNhbiBjaGVjayBpZiB0aGUgcm9vdCBET00gZWxlbWVudCBoYXMgdGhlIGFyaWEtY29udHJvbHMgYXR0cmlidXRlIFwidHlwZWFoZWFkLW1lbnVcIi5cbiAgY29uc3Qgcm9vdCA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuICBpZiAoIXJvb3QpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHJvb3QuaGFzQXR0cmlidXRlKCdhcmlhLWNvbnRyb2xzJykgJiYgcm9vdC5nZXRBdHRyaWJ1dGUoJ2FyaWEtY29udHJvbHMnKSA9PT0gJ3R5cGVhaGVhZC1tZW51Jztcbn1cbmZ1bmN0aW9uIGlzRXhpdGluZ1RhYmxlQW5jaG9yKHR5cGUsIG9mZnNldCwgYW5jaG9yTm9kZSwgZGlyZWN0aW9uKSB7XG4gIHJldHVybiBpc0V4aXRpbmdUYWJsZUVsZW1lbnRBbmNob3IodHlwZSwgYW5jaG9yTm9kZSwgZGlyZWN0aW9uKSB8fCAkaXNFeGl0aW5nVGFibGVUZXh0QW5jaG9yKHR5cGUsIG9mZnNldCwgYW5jaG9yTm9kZSwgZGlyZWN0aW9uKTtcbn1cbmZ1bmN0aW9uIGlzRXhpdGluZ1RhYmxlRWxlbWVudEFuY2hvcih0eXBlLCBhbmNob3JOb2RlLCBkaXJlY3Rpb24pIHtcbiAgcmV0dXJuIHR5cGUgPT09ICdlbGVtZW50JyAmJiAoZGlyZWN0aW9uID09PSAnYmFja3dhcmQnID8gYW5jaG9yTm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKSA9PT0gbnVsbCA6IGFuY2hvck5vZGUuZ2V0TmV4dFNpYmxpbmcoKSA9PT0gbnVsbCk7XG59XG5mdW5jdGlvbiAkaXNFeGl0aW5nVGFibGVUZXh0QW5jaG9yKHR5cGUsIG9mZnNldCwgYW5jaG9yTm9kZSwgZGlyZWN0aW9uKSB7XG4gIGNvbnN0IHBhcmVudE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGFuY2hvck5vZGUsIG4gPT4gJGlzRWxlbWVudE5vZGUobikgJiYgIW4uaXNJbmxpbmUoKSk7XG4gIGlmICghcGFyZW50Tm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBoYXNWYWxpZE9mZnNldCA9IGRpcmVjdGlvbiA9PT0gJ2JhY2t3YXJkJyA/IG9mZnNldCA9PT0gMCA6IG9mZnNldCA9PT0gYW5jaG9yTm9kZS5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgcmV0dXJuIHR5cGUgPT09ICd0ZXh0JyAmJiBoYXNWYWxpZE9mZnNldCAmJiAoZGlyZWN0aW9uID09PSAnYmFja3dhcmQnID8gcGFyZW50Tm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKSA9PT0gbnVsbCA6IHBhcmVudE5vZGUuZ2V0TmV4dFNpYmxpbmcoKSA9PT0gbnVsbCk7XG59XG5mdW5jdGlvbiAkaGFuZGxlVGFibGVFeGl0KGV2ZW50LCBhbmNob3JOb2RlLCB0YWJsZU5vZGUsIGRpcmVjdGlvbikge1xuICBjb25zdCBhbmNob3JDZWxsTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoYW5jaG9yTm9kZSwgJGlzVGFibGVDZWxsTm9kZSk7XG4gIGlmICghJGlzVGFibGVDZWxsTm9kZShhbmNob3JDZWxsTm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgW3RhYmxlTWFwLCBjZWxsVmFsdWVdID0gJGNvbXB1dGVUYWJsZU1hcCh0YWJsZU5vZGUsIGFuY2hvckNlbGxOb2RlLCBhbmNob3JDZWxsTm9kZSk7XG4gIGlmICghaXNFeGl0aW5nQ2VsbCh0YWJsZU1hcCwgY2VsbFZhbHVlLCBkaXJlY3Rpb24pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHRvTm9kZSA9ICRnZXRFeGl0aW5nVG9Ob2RlKGFuY2hvck5vZGUsIGRpcmVjdGlvbiwgdGFibGVOb2RlKTtcbiAgaWYgKCF0b05vZGUgfHwgJGlzVGFibGVOb2RlKHRvTm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgaWYgKGRpcmVjdGlvbiA9PT0gJ2JhY2t3YXJkJykge1xuICAgIHRvTm9kZS5zZWxlY3RFbmQoKTtcbiAgfSBlbHNlIHtcbiAgICB0b05vZGUuc2VsZWN0U3RhcnQoKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGlzRXhpdGluZ0NlbGwodGFibGVNYXAsIGNlbGxWYWx1ZSwgZGlyZWN0aW9uKSB7XG4gIGNvbnN0IGZpcnN0Q2VsbCA9IHRhYmxlTWFwWzBdWzBdO1xuICBjb25zdCBsYXN0Q2VsbCA9IHRhYmxlTWFwW3RhYmxlTWFwLmxlbmd0aCAtIDFdW3RhYmxlTWFwWzBdLmxlbmd0aCAtIDFdO1xuICBjb25zdCB7XG4gICAgc3RhcnRDb2x1bW4sXG4gICAgc3RhcnRSb3dcbiAgfSA9IGNlbGxWYWx1ZTtcbiAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gJ2JhY2t3YXJkJyA/IHN0YXJ0Q29sdW1uID09PSBmaXJzdENlbGwuc3RhcnRDb2x1bW4gJiYgc3RhcnRSb3cgPT09IGZpcnN0Q2VsbC5zdGFydFJvdyA6IHN0YXJ0Q29sdW1uID09PSBsYXN0Q2VsbC5zdGFydENvbHVtbiAmJiBzdGFydFJvdyA9PT0gbGFzdENlbGwuc3RhcnRSb3c7XG59XG5mdW5jdGlvbiAkZ2V0RXhpdGluZ1RvTm9kZShhbmNob3JOb2RlLCBkaXJlY3Rpb24sIHRhYmxlTm9kZSkge1xuICBjb25zdCBwYXJlbnROb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChhbmNob3JOb2RlLCBuID0+ICRpc0VsZW1lbnROb2RlKG4pICYmICFuLmlzSW5saW5lKCkpO1xuICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGNvbnN0IGFuY2hvclNpYmxpbmcgPSBkaXJlY3Rpb24gPT09ICdiYWNrd2FyZCcgPyBwYXJlbnROb2RlLmdldFByZXZpb3VzU2libGluZygpIDogcGFyZW50Tm9kZS5nZXROZXh0U2libGluZygpO1xuICByZXR1cm4gYW5jaG9yU2libGluZyAmJiAkaXNUYWJsZU5vZGUoYW5jaG9yU2libGluZykgPyBhbmNob3JTaWJsaW5nIDogZGlyZWN0aW9uID09PSAnYmFja3dhcmQnID8gdGFibGVOb2RlLmdldFByZXZpb3VzU2libGluZygpIDogdGFibGVOb2RlLmdldE5leHRTaWJsaW5nKCk7XG59XG5mdW5jdGlvbiAkaW5zZXJ0UGFyYWdyYXBoQXRUYWJsZUVkZ2UoZWRnZVBvc2l0aW9uLCB0YWJsZU5vZGUsIGNoaWxkcmVuKSB7XG4gIGNvbnN0IHBhcmFncmFwaE5vZGUgPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICBpZiAoZWRnZVBvc2l0aW9uID09PSAnZmlyc3QnKSB7XG4gICAgdGFibGVOb2RlLmluc2VydEJlZm9yZShwYXJhZ3JhcGhOb2RlKTtcbiAgfSBlbHNlIHtcbiAgICB0YWJsZU5vZGUuaW5zZXJ0QWZ0ZXIocGFyYWdyYXBoTm9kZSk7XG4gIH1cbiAgcGFyYWdyYXBoTm9kZS5hcHBlbmQoLi4uKGNoaWxkcmVuIHx8IFtdKSk7XG4gIHBhcmFncmFwaE5vZGUuc2VsZWN0RW5kKCk7XG59XG5mdW5jdGlvbiAkZ2V0VGFibGVFZGdlQ3Vyc29yUG9zaXRpb24oZWRpdG9yLCBzZWxlY3Rpb24sIHRhYmxlTm9kZSkge1xuICBjb25zdCB0YWJsZU5vZGVQYXJlbnQgPSB0YWJsZU5vZGUuZ2V0UGFyZW50KCk7XG4gIGlmICghdGFibGVOb2RlUGFyZW50KSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCB0YWJsZU5vZGVQYXJlbnRET00gPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KHRhYmxlTm9kZVBhcmVudC5nZXRLZXkoKSk7XG4gIGlmICghdGFibGVOb2RlUGFyZW50RE9NKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIFRPRE86IEFkZCBzdXBwb3J0IGZvciBuZXN0ZWQgdGFibGVzXG4gIGNvbnN0IGRvbVNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCFkb21TZWxlY3Rpb24gfHwgZG9tU2VsZWN0aW9uLmFuY2hvck5vZGUgIT09IHRhYmxlTm9kZVBhcmVudERPTSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3QgYW5jaG9yQ2VsbE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpLCBuID0+ICRpc1RhYmxlQ2VsbE5vZGUobikpO1xuICBpZiAoIWFuY2hvckNlbGxOb2RlKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCBwYXJlbnRUYWJsZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoYW5jaG9yQ2VsbE5vZGUsIG4gPT4gJGlzVGFibGVOb2RlKG4pKTtcbiAgaWYgKCEkaXNUYWJsZU5vZGUocGFyZW50VGFibGUpIHx8ICFwYXJlbnRUYWJsZS5pcyh0YWJsZU5vZGUpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCBbdGFibGVNYXAsIGNlbGxWYWx1ZV0gPSAkY29tcHV0ZVRhYmxlTWFwKHRhYmxlTm9kZSwgYW5jaG9yQ2VsbE5vZGUsIGFuY2hvckNlbGxOb2RlKTtcbiAgY29uc3QgZmlyc3RDZWxsID0gdGFibGVNYXBbMF1bMF07XG4gIGNvbnN0IGxhc3RDZWxsID0gdGFibGVNYXBbdGFibGVNYXAubGVuZ3RoIC0gMV1bdGFibGVNYXBbMF0ubGVuZ3RoIC0gMV07XG4gIGNvbnN0IHtcbiAgICBzdGFydFJvdyxcbiAgICBzdGFydENvbHVtblxuICB9ID0gY2VsbFZhbHVlO1xuICBjb25zdCBpc0F0Rmlyc3RDZWxsID0gc3RhcnRSb3cgPT09IGZpcnN0Q2VsbC5zdGFydFJvdyAmJiBzdGFydENvbHVtbiA9PT0gZmlyc3RDZWxsLnN0YXJ0Q29sdW1uO1xuICBjb25zdCBpc0F0TGFzdENlbGwgPSBzdGFydFJvdyA9PT0gbGFzdENlbGwuc3RhcnRSb3cgJiYgc3RhcnRDb2x1bW4gPT09IGxhc3RDZWxsLnN0YXJ0Q29sdW1uO1xuICBpZiAoaXNBdEZpcnN0Q2VsbCkge1xuICAgIHJldHVybiAnZmlyc3QnO1xuICB9IGVsc2UgaWYgKGlzQXRMYXN0Q2VsbCkge1xuICAgIHJldHVybiAnbGFzdCc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbGdyb3VwKGRvbSwgY29uZmlnLCBjb2xDb3VudCwgY29sV2lkdGhzKSB7XG4gIGNvbnN0IGNvbEdyb3VwID0gZG9tLnF1ZXJ5U2VsZWN0b3IoJ2NvbGdyb3VwJyk7XG4gIGlmICghY29sR3JvdXApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgY29scyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbENvdW50OyBpKyspIHtcbiAgICBjb25zdCBjb2wgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjb2wnKTtcbiAgICBjb25zdCB3aWR0aCA9IGNvbFdpZHRocyAmJiBjb2xXaWR0aHNbaV07XG4gICAgaWYgKHdpZHRoKSB7XG4gICAgICBjb2wuc3R5bGUud2lkdGggPSBgJHt3aWR0aH1weGA7XG4gICAgfVxuICAgIGNvbHMucHVzaChjb2wpO1xuICB9XG4gIGNvbEdyb3VwLnJlcGxhY2VDaGlsZHJlbiguLi5jb2xzKTtcbn1cbmZ1bmN0aW9uIHNldFJvd1N0cmlwaW5nKGRvbSwgY29uZmlnLCByb3dTdHJpcGluZykge1xuICBpZiAocm93U3RyaXBpbmcpIHtcbiAgICBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGRvbSwgY29uZmlnLnRoZW1lLnRhYmxlUm93U3RyaXBpbmcpO1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGV4aWNhbC1yb3ctc3RyaXBpbmcnLCAndHJ1ZScpO1xuICB9IGVsc2Uge1xuICAgIHJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudChkb20sIGNvbmZpZy50aGVtZS50YWJsZVJvd1N0cmlwaW5nKTtcbiAgICBkb20ucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWxleGljYWwtcm93LXN0cmlwaW5nJyk7XG4gIH1cbn1cblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIFRhYmxlTm9kZSBleHRlbmRzIEVsZW1lbnROb2RlIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAndGFibGUnO1xuICB9XG4gIGdldENvbFdpZHRocygpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gc2VsZi5fX2NvbFdpZHRocztcbiAgfVxuICBzZXRDb2xXaWR0aHMoY29sV2lkdGhzKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICAvLyBOT1RFOiBOb2RlIHByb3BlcnRpZXMgc2hvdWxkIGJlIGltbXV0YWJsZS4gRnJlZXplIHRvIHByZXZlbnQgYWNjaWRlbnRhbCBtdXRhdGlvbi5cbiAgICBzZWxmLl9fY29sV2lkdGhzID0gT2JqZWN0LmZyZWV6ZShjb2xXaWR0aHMpIDtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgVGFibGVOb2RlKG5vZGUuX19rZXkpO1xuICB9XG4gIGFmdGVyQ2xvbmVGcm9tKHByZXZOb2RlKSB7XG4gICAgc3VwZXIuYWZ0ZXJDbG9uZUZyb20ocHJldk5vZGUpO1xuICAgIHRoaXMuX19jb2xXaWR0aHMgPSBwcmV2Tm9kZS5fX2NvbFdpZHRocztcbiAgICB0aGlzLl9fcm93U3RyaXBpbmcgPSBwcmV2Tm9kZS5fX3Jvd1N0cmlwaW5nO1xuICB9XG4gIHN0YXRpYyBpbXBvcnRET00oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRhYmxlOiBfbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydFRhYmxlRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDFcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIGNvbnN0IHRhYmxlTm9kZSA9ICRjcmVhdGVUYWJsZU5vZGUoKTtcbiAgICB0YWJsZU5vZGUuX19yb3dTdHJpcGluZyA9IHNlcmlhbGl6ZWROb2RlLnJvd1N0cmlwaW5nIHx8IGZhbHNlO1xuICAgIHRhYmxlTm9kZS5fX2NvbFdpZHRocyA9IHNlcmlhbGl6ZWROb2RlLmNvbFdpZHRocztcbiAgICByZXR1cm4gdGFibGVOb2RlO1xuICB9XG4gIGNvbnN0cnVjdG9yKGtleSkge1xuICAgIHN1cGVyKGtleSk7XG4gICAgdGhpcy5fX3Jvd1N0cmlwaW5nID0gZmFsc2U7XG4gIH1cbiAgZXhwb3J0SlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3VwZXIuZXhwb3J0SlNPTigpLFxuICAgICAgY29sV2lkdGhzOiB0aGlzLmdldENvbFdpZHRocygpLFxuICAgICAgcm93U3RyaXBpbmc6IHRoaXMuX19yb3dTdHJpcGluZyA/IHRoaXMuX19yb3dTdHJpcGluZyA6IHVuZGVmaW5lZCxcbiAgICAgIHR5cGU6ICd0YWJsZScsXG4gICAgICB2ZXJzaW9uOiAxXG4gICAgfTtcbiAgfVxuICBjcmVhdGVET00oY29uZmlnLCBlZGl0b3IpIHtcbiAgICBjb25zdCB0YWJsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0YWJsZScpO1xuICAgIGNvbnN0IGNvbEdyb3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY29sZ3JvdXAnKTtcbiAgICB0YWJsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY29sR3JvdXApO1xuICAgIHVwZGF0ZUNvbGdyb3VwKHRhYmxlRWxlbWVudCwgY29uZmlnLCB0aGlzLmdldENvbHVtbkNvdW50KCksIHRoaXMuZ2V0Q29sV2lkdGhzKCkpO1xuICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQodGFibGVFbGVtZW50LCBjb25maWcudGhlbWUudGFibGUpO1xuICAgIGlmICh0aGlzLl9fcm93U3RyaXBpbmcpIHtcbiAgICAgIHNldFJvd1N0cmlwaW5nKHRhYmxlRWxlbWVudCwgY29uZmlnLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhYmxlRWxlbWVudDtcbiAgfVxuICB1cGRhdGVET00ocHJldk5vZGUsIGRvbSwgY29uZmlnKSB7XG4gICAgaWYgKHByZXZOb2RlLl9fcm93U3RyaXBpbmcgIT09IHRoaXMuX19yb3dTdHJpcGluZykge1xuICAgICAgc2V0Um93U3RyaXBpbmcoZG9tLCBjb25maWcsIHRoaXMuX19yb3dTdHJpcGluZyk7XG4gICAgfVxuICAgIHVwZGF0ZUNvbGdyb3VwKGRvbSwgY29uZmlnLCB0aGlzLmdldENvbHVtbkNvdW50KCksIHRoaXMuZ2V0Q29sV2lkdGhzKCkpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBleHBvcnRET00oZWRpdG9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLmV4cG9ydERPTShlZGl0b3IpLFxuICAgICAgYWZ0ZXI6IHRhYmxlRWxlbWVudCA9PiB7XG4gICAgICAgIGlmICh0YWJsZUVsZW1lbnQpIHtcbiAgICAgICAgICBjb25zdCBuZXdFbGVtZW50ID0gdGFibGVFbGVtZW50LmNsb25lTm9kZSgpO1xuICAgICAgICAgIGNvbnN0IGNvbEdyb3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY29sZ3JvdXAnKTtcbiAgICAgICAgICBjb25zdCB0Qm9keSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3Rib2R5Jyk7XG4gICAgICAgICAgaWYgKGlzSFRNTEVsZW1lbnQodGFibGVFbGVtZW50KSkge1xuICAgICAgICAgICAgY29uc3QgY29scyA9IHRhYmxlRWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdjb2wnKTtcbiAgICAgICAgICAgIGNvbEdyb3VwLmFwcGVuZCguLi5jb2xzKTtcbiAgICAgICAgICAgIGNvbnN0IHJvd3MgPSB0YWJsZUVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgndHInKTtcbiAgICAgICAgICAgIHRCb2R5LmFwcGVuZCguLi5yb3dzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV3RWxlbWVudC5yZXBsYWNlQ2hpbGRyZW4oY29sR3JvdXAsIHRCb2R5KTtcbiAgICAgICAgICByZXR1cm4gbmV3RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgY2FuQmVFbXB0eSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaXNTaGFkb3dSb290KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldENvcmRzRnJvbUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUsIHRhYmxlKSB7XG4gICAgY29uc3Qge1xuICAgICAgcm93cyxcbiAgICAgIGRvbVJvd3NcbiAgICB9ID0gdGFibGU7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCByb3dzOyB5KyspIHtcbiAgICAgIGNvbnN0IHJvdyA9IGRvbVJvd3NbeV07XG4gICAgICBpZiAocm93ID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB4ID0gcm93LmZpbmRJbmRleChjZWxsID0+IHtcbiAgICAgICAgaWYgKCFjZWxsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBlbGVtXG4gICAgICAgIH0gPSBjZWxsO1xuICAgICAgICBjb25zdCBjZWxsTm9kZSA9ICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGVsZW0pO1xuICAgICAgICByZXR1cm4gY2VsbE5vZGUgPT09IHRhYmxlQ2VsbE5vZGU7XG4gICAgICB9KTtcbiAgICAgIGlmICh4ICE9PSAtMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHgsXG4gICAgICAgICAgeVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NlbGwgbm90IGZvdW5kIGluIHRhYmxlLicpO1xuICB9XG4gIGdldERPTUNlbGxGcm9tQ29yZHMoeCwgeSwgdGFibGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBkb21Sb3dzXG4gICAgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHJvdyA9IGRvbVJvd3NbeV07XG4gICAgaWYgKHJvdyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSB4IDwgcm93Lmxlbmd0aCA/IHggOiByb3cubGVuZ3RoIC0gMTtcbiAgICBjb25zdCBjZWxsID0gcm93W2luZGV4XTtcbiAgICBpZiAoY2VsbCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNlbGw7XG4gIH1cbiAgZ2V0RE9NQ2VsbEZyb21Db3Jkc09yVGhyb3coeCwgeSwgdGFibGUpIHtcbiAgICBjb25zdCBjZWxsID0gdGhpcy5nZXRET01DZWxsRnJvbUNvcmRzKHgsIHksIHRhYmxlKTtcbiAgICBpZiAoIWNlbGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2VsbCBub3QgZm91bmQgYXQgY29yZHMuJyk7XG4gICAgfVxuICAgIHJldHVybiBjZWxsO1xuICB9XG4gIGdldENlbGxOb2RlRnJvbUNvcmRzKHgsIHksIHRhYmxlKSB7XG4gICAgY29uc3QgY2VsbCA9IHRoaXMuZ2V0RE9NQ2VsbEZyb21Db3Jkcyh4LCB5LCB0YWJsZSk7XG4gICAgaWYgKGNlbGwgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShjZWxsLmVsZW0pO1xuICAgIGlmICgkaXNUYWJsZUNlbGxOb2RlKG5vZGUpKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2V0Q2VsbE5vZGVGcm9tQ29yZHNPclRocm93KHgsIHksIHRhYmxlKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0Q2VsbE5vZGVGcm9tQ29yZHMoeCwgeSwgdGFibGUpO1xuICAgIGlmICghbm9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb2RlIGF0IGNvcmRzIG5vdCBUYWJsZUNlbGxOb2RlLicpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBnZXRSb3dTdHJpcGluZygpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLmdldExhdGVzdCgpLl9fcm93U3RyaXBpbmcpO1xuICB9XG4gIHNldFJvd1N0cmlwaW5nKG5ld1Jvd1N0cmlwaW5nKSB7XG4gICAgdGhpcy5nZXRXcml0YWJsZSgpLl9fcm93U3RyaXBpbmcgPSBuZXdSb3dTdHJpcGluZztcbiAgfVxuICBjYW5TZWxlY3RCZWZvcmUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY2FuSW5kZW50KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBnZXRDb2x1bW5Db3VudCgpIHtcbiAgICBjb25zdCBmaXJzdFJvdyA9IHRoaXMuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIGlmICghZmlyc3RSb3cpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBsZXQgY29sdW1uQ291bnQgPSAwO1xuICAgIGZpcnN0Um93LmdldENoaWxkcmVuKCkuZm9yRWFjaChjZWxsID0+IHtcbiAgICAgIGlmICgkaXNUYWJsZUNlbGxOb2RlKGNlbGwpKSB7XG4gICAgICAgIGNvbHVtbkNvdW50ICs9IGNlbGwuZ2V0Q29sU3BhbigpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjb2x1bW5Db3VudDtcbiAgfVxufVxuZnVuY3Rpb24gJGdldEVsZW1lbnRGb3JUYWJsZU5vZGUoZWRpdG9yLCB0YWJsZU5vZGUpIHtcbiAgY29uc3QgdGFibGVFbGVtZW50ID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleSh0YWJsZU5vZGUuZ2V0S2V5KCkpO1xuICBpZiAodGFibGVFbGVtZW50ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RhYmxlIEVsZW1lbnQgTm90IEZvdW5kJyk7XG4gIH1cbiAgcmV0dXJuIGdldFRhYmxlKHRhYmxlRWxlbWVudCk7XG59XG5mdW5jdGlvbiAkY29udmVydFRhYmxlRWxlbWVudChkb21Ob2RlKSB7XG4gIGNvbnN0IHRhYmxlTm9kZSA9ICRjcmVhdGVUYWJsZU5vZGUoKTtcbiAgaWYgKGRvbU5vZGUuaGFzQXR0cmlidXRlKCdkYXRhLWxleGljYWwtcm93LXN0cmlwaW5nJykpIHtcbiAgICB0YWJsZU5vZGUuc2V0Um93U3RyaXBpbmcodHJ1ZSk7XG4gIH1cbiAgY29uc3QgY29sR3JvdXAgPSBkb21Ob2RlLnF1ZXJ5U2VsZWN0b3IoJzpzY29wZSA+IGNvbGdyb3VwJyk7XG4gIGlmIChjb2xHcm91cCkge1xuICAgIGxldCBjb2x1bW5zID0gW107XG4gICAgZm9yIChjb25zdCBjb2wgb2YgY29sR3JvdXAucXVlcnlTZWxlY3RvckFsbCgnOnNjb3BlID4gY29sJykpIHtcbiAgICAgIGNvbnN0IHdpZHRoID0gY29sLnN0eWxlLndpZHRoO1xuICAgICAgaWYgKCF3aWR0aCB8fCAhUElYRUxfVkFMVUVfUkVHX0VYUC50ZXN0KHdpZHRoKSkge1xuICAgICAgICBjb2x1bW5zID0gdW5kZWZpbmVkO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbHVtbnMucHVzaChwYXJzZUZsb2F0KHdpZHRoKSk7XG4gICAgfVxuICAgIGlmIChjb2x1bW5zKSB7XG4gICAgICB0YWJsZU5vZGUuc2V0Q29sV2lkdGhzKGNvbHVtbnMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIG5vZGU6IHRhYmxlTm9kZVxuICB9O1xufVxuZnVuY3Rpb24gJGNyZWF0ZVRhYmxlTm9kZSgpIHtcbiAgcmV0dXJuICRhcHBseU5vZGVSZXBsYWNlbWVudChuZXcgVGFibGVOb2RlKCkpO1xufVxuZnVuY3Rpb24gJGlzVGFibGVOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBUYWJsZU5vZGU7XG59XG5cbmV4cG9ydCB7ICRjb21wdXRlVGFibGVNYXAsICRjb21wdXRlVGFibGVNYXBTa2lwQ2VsbENoZWNrLCAkY3JlYXRlVGFibGVDZWxsTm9kZSwgJGNyZWF0ZVRhYmxlTm9kZSwgJGNyZWF0ZVRhYmxlTm9kZVdpdGhEaW1lbnNpb25zLCAkY3JlYXRlVGFibGVSb3dOb2RlLCAkY3JlYXRlVGFibGVTZWxlY3Rpb24sICRkZWxldGVUYWJsZUNvbHVtbiwgJGRlbGV0ZVRhYmxlQ29sdW1uX19FWFBFUklNRU5UQUwsICRkZWxldGVUYWJsZVJvd19fRVhQRVJJTUVOVEFMLCAkZmluZENlbGxOb2RlLCAkZmluZFRhYmxlTm9kZSwgJGdldEVsZW1lbnRGb3JUYWJsZU5vZGUsICRnZXROb2RlVHJpcGxldCwgJGdldFRhYmxlQ2VsbE5vZGVGcm9tTGV4aWNhbE5vZGUsICRnZXRUYWJsZUNlbGxOb2RlUmVjdCwgJGdldFRhYmxlQ29sdW1uSW5kZXhGcm9tVGFibGVDZWxsTm9kZSwgJGdldFRhYmxlTm9kZUZyb21MZXhpY2FsTm9kZU9yVGhyb3csICRnZXRUYWJsZVJvd0luZGV4RnJvbVRhYmxlQ2VsbE5vZGUsICRnZXRUYWJsZVJvd05vZGVGcm9tVGFibGVDZWxsTm9kZU9yVGhyb3csICRpbnNlcnRUYWJsZUNvbHVtbiwgJGluc2VydFRhYmxlQ29sdW1uX19FWFBFUklNRU5UQUwsICRpbnNlcnRUYWJsZVJvdywgJGluc2VydFRhYmxlUm93X19FWFBFUklNRU5UQUwsICRpc1RhYmxlQ2VsbE5vZGUsICRpc1RhYmxlTm9kZSwgJGlzVGFibGVSb3dOb2RlLCAkaXNUYWJsZVNlbGVjdGlvbiwgJHJlbW92ZVRhYmxlUm93QXRJbmRleCwgJHVubWVyZ2VDZWxsLCBJTlNFUlRfVEFCTEVfQ09NTUFORCwgVGFibGVDZWxsSGVhZGVyU3RhdGVzLCBUYWJsZUNlbGxOb2RlLCBUYWJsZU5vZGUsIFRhYmxlT2JzZXJ2ZXIsIFRhYmxlUm93Tm9kZSwgYXBwbHlUYWJsZUhhbmRsZXJzLCBnZXRET01DZWxsRnJvbVRhcmdldCwgZ2V0VGFibGVPYnNlcnZlckZyb21UYWJsZUVsZW1lbnQgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@lexical+table@0.20.0/node_modules/@lexical/table/LexicalTable.dev.mjs\n");

/***/ })

};
;
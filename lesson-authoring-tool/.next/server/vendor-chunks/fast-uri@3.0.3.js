"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fast-uri@3.0.3";
exports.ids = ["vendor-chunks/fast-uri@3.0.3"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/index.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = __webpack_require__(/*! ./lib/utils */ \"(ssr)/./node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/utils.js\")\nconst SCHEMES = __webpack_require__(/*! ./lib/schemes */ \"(ssr)/./node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/schemes.js\")\n\nfunction normalize (uri, options) {\n  if (typeof uri === 'string') {\n    uri = serialize(parse(uri, options), options)\n  } else if (typeof uri === 'object') {\n    uri = parse(serialize(uri, options), options)\n  }\n  return uri\n}\n\nfunction resolve (baseURI, relativeURI, options) {\n  const schemelessOptions = Object.assign({ scheme: 'null' }, options)\n  const resolved = resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true)\n  return serialize(resolved, { ...schemelessOptions, skipEscape: true })\n}\n\nfunction resolveComponents (base, relative, options, skipNormalization) {\n  const target = {}\n  if (!skipNormalization) {\n    base = parse(serialize(base, options), options) // normalize base components\n    relative = parse(serialize(relative, options), options) // normalize relative components\n  }\n  options = options || {}\n\n  if (!options.tolerant && relative.scheme) {\n    target.scheme = relative.scheme\n    // target.authority = relative.authority;\n    target.userinfo = relative.userinfo\n    target.host = relative.host\n    target.port = relative.port\n    target.path = removeDotSegments(relative.path || '')\n    target.query = relative.query\n  } else {\n    if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n      // target.authority = relative.authority;\n      target.userinfo = relative.userinfo\n      target.host = relative.host\n      target.port = relative.port\n      target.path = removeDotSegments(relative.path || '')\n      target.query = relative.query\n    } else {\n      if (!relative.path) {\n        target.path = base.path\n        if (relative.query !== undefined) {\n          target.query = relative.query\n        } else {\n          target.query = base.query\n        }\n      } else {\n        if (relative.path.charAt(0) === '/') {\n          target.path = removeDotSegments(relative.path)\n        } else {\n          if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n            target.path = '/' + relative.path\n          } else if (!base.path) {\n            target.path = relative.path\n          } else {\n            target.path = base.path.slice(0, base.path.lastIndexOf('/') + 1) + relative.path\n          }\n          target.path = removeDotSegments(target.path)\n        }\n        target.query = relative.query\n      }\n      // target.authority = base.authority;\n      target.userinfo = base.userinfo\n      target.host = base.host\n      target.port = base.port\n    }\n    target.scheme = base.scheme\n  }\n\n  target.fragment = relative.fragment\n\n  return target\n}\n\nfunction equal (uriA, uriB, options) {\n  if (typeof uriA === 'string') {\n    uriA = unescape(uriA)\n    uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true })\n  } else if (typeof uriA === 'object') {\n    uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true })\n  }\n\n  if (typeof uriB === 'string') {\n    uriB = unescape(uriB)\n    uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true })\n  } else if (typeof uriB === 'object') {\n    uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true })\n  }\n\n  return uriA.toLowerCase() === uriB.toLowerCase()\n}\n\nfunction serialize (cmpts, opts) {\n  const components = {\n    host: cmpts.host,\n    scheme: cmpts.scheme,\n    userinfo: cmpts.userinfo,\n    port: cmpts.port,\n    path: cmpts.path,\n    query: cmpts.query,\n    nid: cmpts.nid,\n    nss: cmpts.nss,\n    uuid: cmpts.uuid,\n    fragment: cmpts.fragment,\n    reference: cmpts.reference,\n    resourceName: cmpts.resourceName,\n    secure: cmpts.secure,\n    error: ''\n  }\n  const options = Object.assign({}, opts)\n  const uriTokens = []\n\n  // find scheme handler\n  const schemeHandler = SCHEMES[(options.scheme || components.scheme || '').toLowerCase()]\n\n  // perform scheme specific serialization\n  if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options)\n\n  if (components.path !== undefined) {\n    if (!options.skipEscape) {\n      components.path = escape(components.path)\n\n      if (components.scheme !== undefined) {\n        components.path = components.path.split('%3A').join(':')\n      }\n    } else {\n      components.path = unescape(components.path)\n    }\n  }\n\n  if (options.reference !== 'suffix' && components.scheme) {\n    uriTokens.push(components.scheme, ':')\n  }\n\n  const authority = recomposeAuthority(components, options)\n  if (authority !== undefined) {\n    if (options.reference !== 'suffix') {\n      uriTokens.push('//')\n    }\n\n    uriTokens.push(authority)\n\n    if (components.path && components.path.charAt(0) !== '/') {\n      uriTokens.push('/')\n    }\n  }\n  if (components.path !== undefined) {\n    let s = components.path\n\n    if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n      s = removeDotSegments(s)\n    }\n\n    if (authority === undefined) {\n      s = s.replace(/^\\/\\//u, '/%2F') // don't allow the path to start with \"//\"\n    }\n\n    uriTokens.push(s)\n  }\n\n  if (components.query !== undefined) {\n    uriTokens.push('?', components.query)\n  }\n\n  if (components.fragment !== undefined) {\n    uriTokens.push('#', components.fragment)\n  }\n  return uriTokens.join('')\n}\n\nconst hexLookUp = Array.from({ length: 127 }, (v, k) => /[^!\"$&'()*+,\\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)))\n\nfunction nonSimpleDomain (value) {\n  let code = 0\n  for (let i = 0, len = value.length; i < len; ++i) {\n    code = value.charCodeAt(i)\n    if (code > 126 || hexLookUp[code]) {\n      return true\n    }\n  }\n  return false\n}\n\nconst URI_PARSE = /^(?:([^#/:?]+):)?(?:\\/\\/((?:([^#/?@]*)@)?(\\[[^#/?\\]]+\\]|[^#/:?]*)(?::(\\d*))?))?([^#?]*)(?:\\?([^#]*))?(?:#((?:.|[\\n\\r])*))?/u\n\nfunction parse (uri, opts) {\n  const options = Object.assign({}, opts)\n  const parsed = {\n    scheme: undefined,\n    userinfo: undefined,\n    host: '',\n    port: undefined,\n    path: '',\n    query: undefined,\n    fragment: undefined\n  }\n  const gotEncoding = uri.indexOf('%') !== -1\n  let isIP = false\n  if (options.reference === 'suffix') uri = (options.scheme ? options.scheme + ':' : '') + '//' + uri\n\n  const matches = uri.match(URI_PARSE)\n\n  if (matches) {\n    // store each component\n    parsed.scheme = matches[1]\n    parsed.userinfo = matches[3]\n    parsed.host = matches[4]\n    parsed.port = parseInt(matches[5], 10)\n    parsed.path = matches[6] || ''\n    parsed.query = matches[7]\n    parsed.fragment = matches[8]\n\n    // fix port number\n    if (isNaN(parsed.port)) {\n      parsed.port = matches[5]\n    }\n    if (parsed.host) {\n      const ipv4result = normalizeIPv4(parsed.host)\n      if (ipv4result.isIPV4 === false) {\n        const ipv6result = normalizeIPv6(ipv4result.host, { isIPV4: false })\n        parsed.host = ipv6result.host.toLowerCase()\n        isIP = ipv6result.isIPV6\n      } else {\n        parsed.host = ipv4result.host\n        isIP = true\n      }\n    }\n    if (parsed.scheme === undefined && parsed.userinfo === undefined && parsed.host === undefined && parsed.port === undefined && !parsed.path && parsed.query === undefined) {\n      parsed.reference = 'same-document'\n    } else if (parsed.scheme === undefined) {\n      parsed.reference = 'relative'\n    } else if (parsed.fragment === undefined) {\n      parsed.reference = 'absolute'\n    } else {\n      parsed.reference = 'uri'\n    }\n\n    // check for reference errors\n    if (options.reference && options.reference !== 'suffix' && options.reference !== parsed.reference) {\n      parsed.error = parsed.error || 'URI is not a ' + options.reference + ' reference.'\n    }\n\n    // find scheme handler\n    const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || '').toLowerCase()]\n\n    // check if scheme can't handle IRIs\n    if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n      // if host component is a domain name\n      if (parsed.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost)) && isIP === false && nonSimpleDomain(parsed.host)) {\n        // convert Unicode IDN -> ASCII IDN\n        try {\n          parsed.host = URL.domainToASCII(parsed.host.toLowerCase())\n        } catch (e) {\n          parsed.error = parsed.error || \"Host's domain name can not be converted to ASCII: \" + e\n        }\n      }\n      // convert IRI -> URI\n    }\n\n    if (!schemeHandler || (schemeHandler && !schemeHandler.skipNormalize)) {\n      if (gotEncoding && parsed.scheme !== undefined) {\n        parsed.scheme = unescape(parsed.scheme)\n      }\n      if (gotEncoding && parsed.host !== undefined) {\n        parsed.host = unescape(parsed.host)\n      }\n      if (parsed.path !== undefined && parsed.path.length) {\n        parsed.path = escape(unescape(parsed.path))\n      }\n      if (parsed.fragment !== undefined && parsed.fragment.length) {\n        parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment))\n      }\n    }\n\n    // perform scheme specific parsing\n    if (schemeHandler && schemeHandler.parse) {\n      schemeHandler.parse(parsed, options)\n    }\n  } else {\n    parsed.error = parsed.error || 'URI can not be parsed.'\n  }\n  return parsed\n}\n\nconst fastUri = {\n  SCHEMES,\n  normalize,\n  resolve,\n  resolveComponents,\n  equal,\n  serialize,\n  parse\n}\n\nmodule.exports = fastUri\nmodule.exports[\"default\"] = fastUri\nmodule.exports.fastUri = fastUri\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZmFzdC11cmlAMy4wLjMvbm9kZV9tb2R1bGVzL2Zhc3QtdXJpL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsa0dBQWtHLEVBQUUsbUJBQU8sQ0FBQyxpR0FBYTtBQUNqSSxnQkFBZ0IsbUJBQU8sQ0FBQyxxR0FBZTs7QUFFdkM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLGdCQUFnQjtBQUM1RDtBQUNBLCtCQUErQix3Q0FBd0M7QUFDdkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSw4QkFBOEI7QUFDN0csSUFBSTtBQUNKLCtEQUErRCw4QkFBOEI7QUFDN0Y7O0FBRUE7QUFDQTtBQUNBLCtFQUErRSw4QkFBOEI7QUFDN0csSUFBSTtBQUNKLCtEQUErRCw4QkFBOEI7QUFDN0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQixhQUFhLDZCQUE2QixRQUFROztBQUVqRjtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxlQUFlO0FBQzNFO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXNCO0FBQ3RCLHNCQUFzQiIsInNvdXJjZXMiOlsiL1VzZXJzL2thcmVsbGUvdnNjcHJvamVjdHMvdGVjaC1mbGVldC90YWluby1sYW5ndWFnZS1hcHAvbGVzc29uLWF1dGhvcmluZy9ub2RlX21vZHVsZXMvLnBucG0vZmFzdC11cmlAMy4wLjMvbm9kZV9tb2R1bGVzL2Zhc3QtdXJpL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IG5vcm1hbGl6ZUlQdjYsIG5vcm1hbGl6ZUlQdjQsIHJlbW92ZURvdFNlZ21lbnRzLCByZWNvbXBvc2VBdXRob3JpdHksIG5vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nIH0gPSByZXF1aXJlKCcuL2xpYi91dGlscycpXG5jb25zdCBTQ0hFTUVTID0gcmVxdWlyZSgnLi9saWIvc2NoZW1lcycpXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZSAodXJpLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgdXJpID09PSAnc3RyaW5nJykge1xuICAgIHVyaSA9IHNlcmlhbGl6ZShwYXJzZSh1cmksIG9wdGlvbnMpLCBvcHRpb25zKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB1cmkgPT09ICdvYmplY3QnKSB7XG4gICAgdXJpID0gcGFyc2Uoc2VyaWFsaXplKHVyaSwgb3B0aW9ucyksIG9wdGlvbnMpXG4gIH1cbiAgcmV0dXJuIHVyaVxufVxuXG5mdW5jdGlvbiByZXNvbHZlIChiYXNlVVJJLCByZWxhdGl2ZVVSSSwgb3B0aW9ucykge1xuICBjb25zdCBzY2hlbWVsZXNzT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBzY2hlbWU6ICdudWxsJyB9LCBvcHRpb25zKVxuICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVDb21wb25lbnRzKHBhcnNlKGJhc2VVUkksIHNjaGVtZWxlc3NPcHRpb25zKSwgcGFyc2UocmVsYXRpdmVVUkksIHNjaGVtZWxlc3NPcHRpb25zKSwgc2NoZW1lbGVzc09wdGlvbnMsIHRydWUpXG4gIHJldHVybiBzZXJpYWxpemUocmVzb2x2ZWQsIHsgLi4uc2NoZW1lbGVzc09wdGlvbnMsIHNraXBFc2NhcGU6IHRydWUgfSlcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNvbXBvbmVudHMgKGJhc2UsIHJlbGF0aXZlLCBvcHRpb25zLCBza2lwTm9ybWFsaXphdGlvbikge1xuICBjb25zdCB0YXJnZXQgPSB7fVxuICBpZiAoIXNraXBOb3JtYWxpemF0aW9uKSB7XG4gICAgYmFzZSA9IHBhcnNlKHNlcmlhbGl6ZShiYXNlLCBvcHRpb25zKSwgb3B0aW9ucykgLy8gbm9ybWFsaXplIGJhc2UgY29tcG9uZW50c1xuICAgIHJlbGF0aXZlID0gcGFyc2Uoc2VyaWFsaXplKHJlbGF0aXZlLCBvcHRpb25zKSwgb3B0aW9ucykgLy8gbm9ybWFsaXplIHJlbGF0aXZlIGNvbXBvbmVudHNcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gIGlmICghb3B0aW9ucy50b2xlcmFudCAmJiByZWxhdGl2ZS5zY2hlbWUpIHtcbiAgICB0YXJnZXQuc2NoZW1lID0gcmVsYXRpdmUuc2NoZW1lXG4gICAgLy8gdGFyZ2V0LmF1dGhvcml0eSA9IHJlbGF0aXZlLmF1dGhvcml0eTtcbiAgICB0YXJnZXQudXNlcmluZm8gPSByZWxhdGl2ZS51c2VyaW5mb1xuICAgIHRhcmdldC5ob3N0ID0gcmVsYXRpdmUuaG9zdFxuICAgIHRhcmdldC5wb3J0ID0gcmVsYXRpdmUucG9ydFxuICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCB8fCAnJylcbiAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeVxuICB9IGVsc2Uge1xuICAgIGlmIChyZWxhdGl2ZS51c2VyaW5mbyAhPT0gdW5kZWZpbmVkIHx8IHJlbGF0aXZlLmhvc3QgIT09IHVuZGVmaW5lZCB8fCByZWxhdGl2ZS5wb3J0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHRhcmdldC5hdXRob3JpdHkgPSByZWxhdGl2ZS5hdXRob3JpdHk7XG4gICAgICB0YXJnZXQudXNlcmluZm8gPSByZWxhdGl2ZS51c2VyaW5mb1xuICAgICAgdGFyZ2V0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0XG4gICAgICB0YXJnZXQucG9ydCA9IHJlbGF0aXZlLnBvcnRcbiAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCB8fCAnJylcbiAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghcmVsYXRpdmUucGF0aCkge1xuICAgICAgICB0YXJnZXQucGF0aCA9IGJhc2UucGF0aFxuICAgICAgICBpZiAocmVsYXRpdmUucXVlcnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gYmFzZS5xdWVyeVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmVsYXRpdmUucGF0aC5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoKGJhc2UudXNlcmluZm8gIT09IHVuZGVmaW5lZCB8fCBiYXNlLmhvc3QgIT09IHVuZGVmaW5lZCB8fCBiYXNlLnBvcnQgIT09IHVuZGVmaW5lZCkgJiYgIWJhc2UucGF0aCkge1xuICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSAnLycgKyByZWxhdGl2ZS5wYXRoXG4gICAgICAgICAgfSBlbHNlIGlmICghYmFzZS5wYXRoKSB7XG4gICAgICAgICAgICB0YXJnZXQucGF0aCA9IHJlbGF0aXZlLnBhdGhcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSBiYXNlLnBhdGguc2xpY2UoMCwgYmFzZS5wYXRoLmxhc3RJbmRleE9mKCcvJykgKyAxKSArIHJlbGF0aXZlLnBhdGhcbiAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyh0YXJnZXQucGF0aClcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeVxuICAgICAgfVxuICAgICAgLy8gdGFyZ2V0LmF1dGhvcml0eSA9IGJhc2UuYXV0aG9yaXR5O1xuICAgICAgdGFyZ2V0LnVzZXJpbmZvID0gYmFzZS51c2VyaW5mb1xuICAgICAgdGFyZ2V0Lmhvc3QgPSBiYXNlLmhvc3RcbiAgICAgIHRhcmdldC5wb3J0ID0gYmFzZS5wb3J0XG4gICAgfVxuICAgIHRhcmdldC5zY2hlbWUgPSBiYXNlLnNjaGVtZVxuICB9XG5cbiAgdGFyZ2V0LmZyYWdtZW50ID0gcmVsYXRpdmUuZnJhZ21lbnRcblxuICByZXR1cm4gdGFyZ2V0XG59XG5cbmZ1bmN0aW9uIGVxdWFsICh1cmlBLCB1cmlCLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgdXJpQSA9PT0gJ3N0cmluZycpIHtcbiAgICB1cmlBID0gdW5lc2NhcGUodXJpQSlcbiAgICB1cmlBID0gc2VyaWFsaXplKG5vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKHBhcnNlKHVyaUEsIG9wdGlvbnMpLCB0cnVlKSwgeyAuLi5vcHRpb25zLCBza2lwRXNjYXBlOiB0cnVlIH0pXG4gIH0gZWxzZSBpZiAodHlwZW9mIHVyaUEgPT09ICdvYmplY3QnKSB7XG4gICAgdXJpQSA9IHNlcmlhbGl6ZShub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyh1cmlBLCB0cnVlKSwgeyAuLi5vcHRpb25zLCBza2lwRXNjYXBlOiB0cnVlIH0pXG4gIH1cblxuICBpZiAodHlwZW9mIHVyaUIgPT09ICdzdHJpbmcnKSB7XG4gICAgdXJpQiA9IHVuZXNjYXBlKHVyaUIpXG4gICAgdXJpQiA9IHNlcmlhbGl6ZShub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhwYXJzZSh1cmlCLCBvcHRpb25zKSwgdHJ1ZSksIHsgLi4ub3B0aW9ucywgc2tpcEVzY2FwZTogdHJ1ZSB9KVxuICB9IGVsc2UgaWYgKHR5cGVvZiB1cmlCID09PSAnb2JqZWN0Jykge1xuICAgIHVyaUIgPSBzZXJpYWxpemUobm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcodXJpQiwgdHJ1ZSksIHsgLi4ub3B0aW9ucywgc2tpcEVzY2FwZTogdHJ1ZSB9KVxuICB9XG5cbiAgcmV0dXJuIHVyaUEudG9Mb3dlckNhc2UoKSA9PT0gdXJpQi50b0xvd2VyQ2FzZSgpXG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZSAoY21wdHMsIG9wdHMpIHtcbiAgY29uc3QgY29tcG9uZW50cyA9IHtcbiAgICBob3N0OiBjbXB0cy5ob3N0LFxuICAgIHNjaGVtZTogY21wdHMuc2NoZW1lLFxuICAgIHVzZXJpbmZvOiBjbXB0cy51c2VyaW5mbyxcbiAgICBwb3J0OiBjbXB0cy5wb3J0LFxuICAgIHBhdGg6IGNtcHRzLnBhdGgsXG4gICAgcXVlcnk6IGNtcHRzLnF1ZXJ5LFxuICAgIG5pZDogY21wdHMubmlkLFxuICAgIG5zczogY21wdHMubnNzLFxuICAgIHV1aWQ6IGNtcHRzLnV1aWQsXG4gICAgZnJhZ21lbnQ6IGNtcHRzLmZyYWdtZW50LFxuICAgIHJlZmVyZW5jZTogY21wdHMucmVmZXJlbmNlLFxuICAgIHJlc291cmNlTmFtZTogY21wdHMucmVzb3VyY2VOYW1lLFxuICAgIHNlY3VyZTogY21wdHMuc2VjdXJlLFxuICAgIGVycm9yOiAnJ1xuICB9XG4gIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRzKVxuICBjb25zdCB1cmlUb2tlbnMgPSBbXVxuXG4gIC8vIGZpbmQgc2NoZW1lIGhhbmRsZXJcbiAgY29uc3Qgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbKG9wdGlvbnMuc2NoZW1lIHx8IGNvbXBvbmVudHMuc2NoZW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpXVxuXG4gIC8vIHBlcmZvcm0gc2NoZW1lIHNwZWNpZmljIHNlcmlhbGl6YXRpb25cbiAgaWYgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5zZXJpYWxpemUpIHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKGNvbXBvbmVudHMsIG9wdGlvbnMpXG5cbiAgaWYgKGNvbXBvbmVudHMucGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKCFvcHRpb25zLnNraXBFc2NhcGUpIHtcbiAgICAgIGNvbXBvbmVudHMucGF0aCA9IGVzY2FwZShjb21wb25lbnRzLnBhdGgpXG5cbiAgICAgIGlmIChjb21wb25lbnRzLnNjaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbXBvbmVudHMucGF0aCA9IGNvbXBvbmVudHMucGF0aC5zcGxpdCgnJTNBJykuam9pbignOicpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBvbmVudHMucGF0aCA9IHVuZXNjYXBlKGNvbXBvbmVudHMucGF0aClcbiAgICB9XG4gIH1cblxuICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgIT09ICdzdWZmaXgnICYmIGNvbXBvbmVudHMuc2NoZW1lKSB7XG4gICAgdXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy5zY2hlbWUsICc6JylcbiAgfVxuXG4gIGNvbnN0IGF1dGhvcml0eSA9IHJlY29tcG9zZUF1dGhvcml0eShjb21wb25lbnRzLCBvcHRpb25zKVxuICBpZiAoYXV0aG9yaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgIT09ICdzdWZmaXgnKSB7XG4gICAgICB1cmlUb2tlbnMucHVzaCgnLy8nKVxuICAgIH1cblxuICAgIHVyaVRva2Vucy5wdXNoKGF1dGhvcml0eSlcblxuICAgIGlmIChjb21wb25lbnRzLnBhdGggJiYgY29tcG9uZW50cy5wYXRoLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgICB1cmlUb2tlbnMucHVzaCgnLycpXG4gICAgfVxuICB9XG4gIGlmIChjb21wb25lbnRzLnBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgIGxldCBzID0gY29tcG9uZW50cy5wYXRoXG5cbiAgICBpZiAoIW9wdGlvbnMuYWJzb2x1dGVQYXRoICYmICghc2NoZW1lSGFuZGxlciB8fCAhc2NoZW1lSGFuZGxlci5hYnNvbHV0ZVBhdGgpKSB7XG4gICAgICBzID0gcmVtb3ZlRG90U2VnbWVudHMocylcbiAgICB9XG5cbiAgICBpZiAoYXV0aG9yaXR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHMgPSBzLnJlcGxhY2UoL15cXC9cXC8vdSwgJy8lMkYnKSAvLyBkb24ndCBhbGxvdyB0aGUgcGF0aCB0byBzdGFydCB3aXRoIFwiLy9cIlxuICAgIH1cblxuICAgIHVyaVRva2Vucy5wdXNoKHMpXG4gIH1cblxuICBpZiAoY29tcG9uZW50cy5xdWVyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdXJpVG9rZW5zLnB1c2goJz8nLCBjb21wb25lbnRzLnF1ZXJ5KVxuICB9XG5cbiAgaWYgKGNvbXBvbmVudHMuZnJhZ21lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgIHVyaVRva2Vucy5wdXNoKCcjJywgY29tcG9uZW50cy5mcmFnbWVudClcbiAgfVxuICByZXR1cm4gdXJpVG9rZW5zLmpvaW4oJycpXG59XG5cbmNvbnN0IGhleExvb2tVcCA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDEyNyB9LCAodiwgaykgPT4gL1teIVwiJCYnKCkqKyxcXC0uOz1fYGEtent9fl0vdS50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoaykpKVxuXG5mdW5jdGlvbiBub25TaW1wbGVEb21haW4gKHZhbHVlKSB7XG4gIGxldCBjb2RlID0gMFxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gdmFsdWUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChpKVxuICAgIGlmIChjb2RlID4gMTI2IHx8IGhleExvb2tVcFtjb2RlXSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmNvbnN0IFVSSV9QQVJTRSA9IC9eKD86KFteIy86P10rKTopPyg/OlxcL1xcLygoPzooW14jLz9AXSopQCk/KFxcW1teIy8/XFxdXStcXF18W14jLzo/XSopKD86OihcXGQqKSk/KSk/KFteIz9dKikoPzpcXD8oW14jXSopKT8oPzojKCg/Oi58W1xcblxccl0pKikpPy91XG5cbmZ1bmN0aW9uIHBhcnNlICh1cmksIG9wdHMpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdHMpXG4gIGNvbnN0IHBhcnNlZCA9IHtcbiAgICBzY2hlbWU6IHVuZGVmaW5lZCxcbiAgICB1c2VyaW5mbzogdW5kZWZpbmVkLFxuICAgIGhvc3Q6ICcnLFxuICAgIHBvcnQ6IHVuZGVmaW5lZCxcbiAgICBwYXRoOiAnJyxcbiAgICBxdWVyeTogdW5kZWZpbmVkLFxuICAgIGZyYWdtZW50OiB1bmRlZmluZWRcbiAgfVxuICBjb25zdCBnb3RFbmNvZGluZyA9IHVyaS5pbmRleE9mKCclJykgIT09IC0xXG4gIGxldCBpc0lQID0gZmFsc2VcbiAgaWYgKG9wdGlvbnMucmVmZXJlbmNlID09PSAnc3VmZml4JykgdXJpID0gKG9wdGlvbnMuc2NoZW1lID8gb3B0aW9ucy5zY2hlbWUgKyAnOicgOiAnJykgKyAnLy8nICsgdXJpXG5cbiAgY29uc3QgbWF0Y2hlcyA9IHVyaS5tYXRjaChVUklfUEFSU0UpXG5cbiAgaWYgKG1hdGNoZXMpIHtcbiAgICAvLyBzdG9yZSBlYWNoIGNvbXBvbmVudFxuICAgIHBhcnNlZC5zY2hlbWUgPSBtYXRjaGVzWzFdXG4gICAgcGFyc2VkLnVzZXJpbmZvID0gbWF0Y2hlc1szXVxuICAgIHBhcnNlZC5ob3N0ID0gbWF0Y2hlc1s0XVxuICAgIHBhcnNlZC5wb3J0ID0gcGFyc2VJbnQobWF0Y2hlc1s1XSwgMTApXG4gICAgcGFyc2VkLnBhdGggPSBtYXRjaGVzWzZdIHx8ICcnXG4gICAgcGFyc2VkLnF1ZXJ5ID0gbWF0Y2hlc1s3XVxuICAgIHBhcnNlZC5mcmFnbWVudCA9IG1hdGNoZXNbOF1cblxuICAgIC8vIGZpeCBwb3J0IG51bWJlclxuICAgIGlmIChpc05hTihwYXJzZWQucG9ydCkpIHtcbiAgICAgIHBhcnNlZC5wb3J0ID0gbWF0Y2hlc1s1XVxuICAgIH1cbiAgICBpZiAocGFyc2VkLmhvc3QpIHtcbiAgICAgIGNvbnN0IGlwdjRyZXN1bHQgPSBub3JtYWxpemVJUHY0KHBhcnNlZC5ob3N0KVxuICAgICAgaWYgKGlwdjRyZXN1bHQuaXNJUFY0ID09PSBmYWxzZSkge1xuICAgICAgICBjb25zdCBpcHY2cmVzdWx0ID0gbm9ybWFsaXplSVB2NihpcHY0cmVzdWx0Lmhvc3QsIHsgaXNJUFY0OiBmYWxzZSB9KVxuICAgICAgICBwYXJzZWQuaG9zdCA9IGlwdjZyZXN1bHQuaG9zdC50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGlzSVAgPSBpcHY2cmVzdWx0LmlzSVBWNlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkLmhvc3QgPSBpcHY0cmVzdWx0Lmhvc3RcbiAgICAgICAgaXNJUCA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhcnNlZC5zY2hlbWUgPT09IHVuZGVmaW5lZCAmJiBwYXJzZWQudXNlcmluZm8gPT09IHVuZGVmaW5lZCAmJiBwYXJzZWQuaG9zdCA9PT0gdW5kZWZpbmVkICYmIHBhcnNlZC5wb3J0ID09PSB1bmRlZmluZWQgJiYgIXBhcnNlZC5wYXRoICYmIHBhcnNlZC5xdWVyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJzZWQucmVmZXJlbmNlID0gJ3NhbWUtZG9jdW1lbnQnXG4gICAgfSBlbHNlIGlmIChwYXJzZWQuc2NoZW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHBhcnNlZC5yZWZlcmVuY2UgPSAncmVsYXRpdmUnXG4gICAgfSBlbHNlIGlmIChwYXJzZWQuZnJhZ21lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcGFyc2VkLnJlZmVyZW5jZSA9ICdhYnNvbHV0ZSdcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2VkLnJlZmVyZW5jZSA9ICd1cmknXG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZm9yIHJlZmVyZW5jZSBlcnJvcnNcbiAgICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgJiYgb3B0aW9ucy5yZWZlcmVuY2UgIT09ICdzdWZmaXgnICYmIG9wdGlvbnMucmVmZXJlbmNlICE9PSBwYXJzZWQucmVmZXJlbmNlKSB7XG4gICAgICBwYXJzZWQuZXJyb3IgPSBwYXJzZWQuZXJyb3IgfHwgJ1VSSSBpcyBub3QgYSAnICsgb3B0aW9ucy5yZWZlcmVuY2UgKyAnIHJlZmVyZW5jZS4nXG4gICAgfVxuXG4gICAgLy8gZmluZCBzY2hlbWUgaGFuZGxlclxuICAgIGNvbnN0IHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTWyhvcHRpb25zLnNjaGVtZSB8fCBwYXJzZWQuc2NoZW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpXVxuXG4gICAgLy8gY2hlY2sgaWYgc2NoZW1lIGNhbid0IGhhbmRsZSBJUklzXG4gICAgaWYgKCFvcHRpb25zLnVuaWNvZGVTdXBwb3J0ICYmICghc2NoZW1lSGFuZGxlciB8fCAhc2NoZW1lSGFuZGxlci51bmljb2RlU3VwcG9ydCkpIHtcbiAgICAgIC8vIGlmIGhvc3QgY29tcG9uZW50IGlzIGEgZG9tYWluIG5hbWVcbiAgICAgIGlmIChwYXJzZWQuaG9zdCAmJiAob3B0aW9ucy5kb21haW5Ib3N0IHx8IChzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIuZG9tYWluSG9zdCkpICYmIGlzSVAgPT09IGZhbHNlICYmIG5vblNpbXBsZURvbWFpbihwYXJzZWQuaG9zdCkpIHtcbiAgICAgICAgLy8gY29udmVydCBVbmljb2RlIElETiAtPiBBU0NJSSBJRE5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwYXJzZWQuaG9zdCA9IFVSTC5kb21haW5Ub0FTQ0lJKHBhcnNlZC5ob3N0LnRvTG93ZXJDYXNlKCkpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBwYXJzZWQuZXJyb3IgPSBwYXJzZWQuZXJyb3IgfHwgXCJIb3N0J3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gQVNDSUk6IFwiICsgZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBjb252ZXJ0IElSSSAtPiBVUklcbiAgICB9XG5cbiAgICBpZiAoIXNjaGVtZUhhbmRsZXIgfHwgKHNjaGVtZUhhbmRsZXIgJiYgIXNjaGVtZUhhbmRsZXIuc2tpcE5vcm1hbGl6ZSkpIHtcbiAgICAgIGlmIChnb3RFbmNvZGluZyAmJiBwYXJzZWQuc2NoZW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGFyc2VkLnNjaGVtZSA9IHVuZXNjYXBlKHBhcnNlZC5zY2hlbWUpXG4gICAgICB9XG4gICAgICBpZiAoZ290RW5jb2RpbmcgJiYgcGFyc2VkLmhvc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXJzZWQuaG9zdCA9IHVuZXNjYXBlKHBhcnNlZC5ob3N0KVxuICAgICAgfVxuICAgICAgaWYgKHBhcnNlZC5wYXRoICE9PSB1bmRlZmluZWQgJiYgcGFyc2VkLnBhdGgubGVuZ3RoKSB7XG4gICAgICAgIHBhcnNlZC5wYXRoID0gZXNjYXBlKHVuZXNjYXBlKHBhcnNlZC5wYXRoKSlcbiAgICAgIH1cbiAgICAgIGlmIChwYXJzZWQuZnJhZ21lbnQgIT09IHVuZGVmaW5lZCAmJiBwYXJzZWQuZnJhZ21lbnQubGVuZ3RoKSB7XG4gICAgICAgIHBhcnNlZC5mcmFnbWVudCA9IGVuY29kZVVSSShkZWNvZGVVUklDb21wb25lbnQocGFyc2VkLmZyYWdtZW50KSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwZXJmb3JtIHNjaGVtZSBzcGVjaWZpYyBwYXJzaW5nXG4gICAgaWYgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5wYXJzZSkge1xuICAgICAgc2NoZW1lSGFuZGxlci5wYXJzZShwYXJzZWQsIG9wdGlvbnMpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhcnNlZC5lcnJvciA9IHBhcnNlZC5lcnJvciB8fCAnVVJJIGNhbiBub3QgYmUgcGFyc2VkLidcbiAgfVxuICByZXR1cm4gcGFyc2VkXG59XG5cbmNvbnN0IGZhc3RVcmkgPSB7XG4gIFNDSEVNRVMsXG4gIG5vcm1hbGl6ZSxcbiAgcmVzb2x2ZSxcbiAgcmVzb2x2ZUNvbXBvbmVudHMsXG4gIGVxdWFsLFxuICBzZXJpYWxpemUsXG4gIHBhcnNlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmFzdFVyaVxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGZhc3RVcmlcbm1vZHVsZS5leHBvcnRzLmZhc3RVcmkgPSBmYXN0VXJpXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/schemes.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/schemes.js ***!
  \********************************************************************************/
/***/ ((module) => {

eval("\n\nconst UUID_REG = /^[\\da-f]{8}\\b-[\\da-f]{4}\\b-[\\da-f]{4}\\b-[\\da-f]{4}\\b-[\\da-f]{12}$/iu\nconst URN_REG = /([\\da-z][\\d\\-a-z]{0,31}):((?:[\\w!$'()*+,\\-.:;=@]|%[\\da-f]{2})+)/iu\n\nfunction isSecure (wsComponents) {\n  return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === 'wss'\n}\n\nfunction httpParse (components) {\n  if (!components.host) {\n    components.error = components.error || 'HTTP URIs must have a host.'\n  }\n\n  return components\n}\n\nfunction httpSerialize (components) {\n  const secure = String(components.scheme).toLowerCase() === 'https'\n\n  // normalize the default port\n  if (components.port === (secure ? 443 : 80) || components.port === '') {\n    components.port = undefined\n  }\n\n  // normalize the empty path\n  if (!components.path) {\n    components.path = '/'\n  }\n\n  // NOTE: We do not parse query strings for HTTP URIs\n  // as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n  // and not the HTTP spec.\n\n  return components\n}\n\nfunction wsParse (wsComponents) {\n// indicate if the secure flag is set\n  wsComponents.secure = isSecure(wsComponents)\n\n  // construct resouce name\n  wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '')\n  wsComponents.path = undefined\n  wsComponents.query = undefined\n\n  return wsComponents\n}\n\nfunction wsSerialize (wsComponents) {\n// normalize the default port\n  if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === '') {\n    wsComponents.port = undefined\n  }\n\n  // ensure scheme matches secure flag\n  if (typeof wsComponents.secure === 'boolean') {\n    wsComponents.scheme = (wsComponents.secure ? 'wss' : 'ws')\n    wsComponents.secure = undefined\n  }\n\n  // reconstruct path from resource name\n  if (wsComponents.resourceName) {\n    const [path, query] = wsComponents.resourceName.split('?')\n    wsComponents.path = (path && path !== '/' ? path : undefined)\n    wsComponents.query = query\n    wsComponents.resourceName = undefined\n  }\n\n  // forbid fragment component\n  wsComponents.fragment = undefined\n\n  return wsComponents\n}\n\nfunction urnParse (urnComponents, options) {\n  if (!urnComponents.path) {\n    urnComponents.error = 'URN can not be parsed'\n    return urnComponents\n  }\n  const matches = urnComponents.path.match(URN_REG)\n  if (matches) {\n    const scheme = options.scheme || urnComponents.scheme || 'urn'\n    urnComponents.nid = matches[1].toLowerCase()\n    urnComponents.nss = matches[2]\n    const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`\n    const schemeHandler = SCHEMES[urnScheme]\n    urnComponents.path = undefined\n\n    if (schemeHandler) {\n      urnComponents = schemeHandler.parse(urnComponents, options)\n    }\n  } else {\n    urnComponents.error = urnComponents.error || 'URN can not be parsed.'\n  }\n\n  return urnComponents\n}\n\nfunction urnSerialize (urnComponents, options) {\n  const scheme = options.scheme || urnComponents.scheme || 'urn'\n  const nid = urnComponents.nid.toLowerCase()\n  const urnScheme = `${scheme}:${options.nid || nid}`\n  const schemeHandler = SCHEMES[urnScheme]\n\n  if (schemeHandler) {\n    urnComponents = schemeHandler.serialize(urnComponents, options)\n  }\n\n  const uriComponents = urnComponents\n  const nss = urnComponents.nss\n  uriComponents.path = `${nid || options.nid}:${nss}`\n\n  options.skipEscape = true\n  return uriComponents\n}\n\nfunction urnuuidParse (urnComponents, options) {\n  const uuidComponents = urnComponents\n  uuidComponents.uuid = uuidComponents.nss\n  uuidComponents.nss = undefined\n\n  if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {\n    uuidComponents.error = uuidComponents.error || 'UUID is not valid.'\n  }\n\n  return uuidComponents\n}\n\nfunction urnuuidSerialize (uuidComponents) {\n  const urnComponents = uuidComponents\n  // normalize UUID\n  urnComponents.nss = (uuidComponents.uuid || '').toLowerCase()\n  return urnComponents\n}\n\nconst http = {\n  scheme: 'http',\n  domainHost: true,\n  parse: httpParse,\n  serialize: httpSerialize\n}\n\nconst https = {\n  scheme: 'https',\n  domainHost: http.domainHost,\n  parse: httpParse,\n  serialize: httpSerialize\n}\n\nconst ws = {\n  scheme: 'ws',\n  domainHost: true,\n  parse: wsParse,\n  serialize: wsSerialize\n}\n\nconst wss = {\n  scheme: 'wss',\n  domainHost: ws.domainHost,\n  parse: ws.parse,\n  serialize: ws.serialize\n}\n\nconst urn = {\n  scheme: 'urn',\n  parse: urnParse,\n  serialize: urnSerialize,\n  skipNormalize: true\n}\n\nconst urnuuid = {\n  scheme: 'urn:uuid',\n  parse: urnuuidParse,\n  serialize: urnuuidSerialize,\n  skipNormalize: true\n}\n\nconst SCHEMES = {\n  http,\n  https,\n  ws,\n  wss,\n  urn,\n  'urn:uuid': urnuuid\n}\n\nmodule.exports = SCHEMES\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZmFzdC11cmlAMy4wLjMvbm9kZV9tb2R1bGVzL2Zhc3QtdXJpL2xpYi9zY2hlbWVzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLDJCQUEyQixFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUUsV0FBVyxFQUFFLFdBQVcsR0FBRztBQUNsRixtQ0FBbUMsS0FBSyxzQkFBc0IsYUFBYSxFQUFFOztBQUU3RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTyxHQUFHLGlDQUFpQztBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU8sR0FBRyxtQkFBbUI7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsbUJBQW1CLEdBQUcsSUFBSTs7QUFFcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMva2FyZWxsZS92c2Nwcm9qZWN0cy90ZWNoLWZsZWV0L3RhaW5vLWxhbmd1YWdlLWFwcC9sZXNzb24tYXV0aG9yaW5nL25vZGVfbW9kdWxlcy8ucG5wbS9mYXN0LXVyaUAzLjAuMy9ub2RlX21vZHVsZXMvZmFzdC11cmkvbGliL3NjaGVtZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFVVSURfUkVHID0gL15bXFxkYS1mXXs4fVxcYi1bXFxkYS1mXXs0fVxcYi1bXFxkYS1mXXs0fVxcYi1bXFxkYS1mXXs0fVxcYi1bXFxkYS1mXXsxMn0kL2l1XG5jb25zdCBVUk5fUkVHID0gLyhbXFxkYS16XVtcXGRcXC1hLXpdezAsMzF9KTooKD86W1xcdyEkJygpKissXFwtLjo7PUBdfCVbXFxkYS1mXXsyfSkrKS9pdVxuXG5mdW5jdGlvbiBpc1NlY3VyZSAod3NDb21wb25lbnRzKSB7XG4gIHJldHVybiB0eXBlb2Ygd3NDb21wb25lbnRzLnNlY3VyZSA9PT0gJ2Jvb2xlYW4nID8gd3NDb21wb25lbnRzLnNlY3VyZSA6IFN0cmluZyh3c0NvbXBvbmVudHMuc2NoZW1lKS50b0xvd2VyQ2FzZSgpID09PSAnd3NzJ1xufVxuXG5mdW5jdGlvbiBodHRwUGFyc2UgKGNvbXBvbmVudHMpIHtcbiAgaWYgKCFjb21wb25lbnRzLmhvc3QpIHtcbiAgICBjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCAnSFRUUCBVUklzIG11c3QgaGF2ZSBhIGhvc3QuJ1xuICB9XG5cbiAgcmV0dXJuIGNvbXBvbmVudHNcbn1cblxuZnVuY3Rpb24gaHR0cFNlcmlhbGl6ZSAoY29tcG9uZW50cykge1xuICBjb25zdCBzZWN1cmUgPSBTdHJpbmcoY29tcG9uZW50cy5zY2hlbWUpLnRvTG93ZXJDYXNlKCkgPT09ICdodHRwcydcblxuICAvLyBub3JtYWxpemUgdGhlIGRlZmF1bHQgcG9ydFxuICBpZiAoY29tcG9uZW50cy5wb3J0ID09PSAoc2VjdXJlID8gNDQzIDogODApIHx8IGNvbXBvbmVudHMucG9ydCA9PT0gJycpIHtcbiAgICBjb21wb25lbnRzLnBvcnQgPSB1bmRlZmluZWRcbiAgfVxuXG4gIC8vIG5vcm1hbGl6ZSB0aGUgZW1wdHkgcGF0aFxuICBpZiAoIWNvbXBvbmVudHMucGF0aCkge1xuICAgIGNvbXBvbmVudHMucGF0aCA9ICcvJ1xuICB9XG5cbiAgLy8gTk9URTogV2UgZG8gbm90IHBhcnNlIHF1ZXJ5IHN0cmluZ3MgZm9yIEhUVFAgVVJJc1xuICAvLyBhcyBXV1cgRm9ybSBVcmwgRW5jb2RlZCBxdWVyeSBzdHJpbmdzIGFyZSBwYXJ0IG9mIHRoZSBIVE1MNCsgc3BlYyxcbiAgLy8gYW5kIG5vdCB0aGUgSFRUUCBzcGVjLlxuXG4gIHJldHVybiBjb21wb25lbnRzXG59XG5cbmZ1bmN0aW9uIHdzUGFyc2UgKHdzQ29tcG9uZW50cykge1xuLy8gaW5kaWNhdGUgaWYgdGhlIHNlY3VyZSBmbGFnIGlzIHNldFxuICB3c0NvbXBvbmVudHMuc2VjdXJlID0gaXNTZWN1cmUod3NDb21wb25lbnRzKVxuXG4gIC8vIGNvbnN0cnVjdCByZXNvdWNlIG5hbWVcbiAgd3NDb21wb25lbnRzLnJlc291cmNlTmFtZSA9ICh3c0NvbXBvbmVudHMucGF0aCB8fCAnLycpICsgKHdzQ29tcG9uZW50cy5xdWVyeSA/ICc/JyArIHdzQ29tcG9uZW50cy5xdWVyeSA6ICcnKVxuICB3c0NvbXBvbmVudHMucGF0aCA9IHVuZGVmaW5lZFxuICB3c0NvbXBvbmVudHMucXVlcnkgPSB1bmRlZmluZWRcblxuICByZXR1cm4gd3NDb21wb25lbnRzXG59XG5cbmZ1bmN0aW9uIHdzU2VyaWFsaXplICh3c0NvbXBvbmVudHMpIHtcbi8vIG5vcm1hbGl6ZSB0aGUgZGVmYXVsdCBwb3J0XG4gIGlmICh3c0NvbXBvbmVudHMucG9ydCA9PT0gKGlzU2VjdXJlKHdzQ29tcG9uZW50cykgPyA0NDMgOiA4MCkgfHwgd3NDb21wb25lbnRzLnBvcnQgPT09ICcnKSB7XG4gICAgd3NDb21wb25lbnRzLnBvcnQgPSB1bmRlZmluZWRcbiAgfVxuXG4gIC8vIGVuc3VyZSBzY2hlbWUgbWF0Y2hlcyBzZWN1cmUgZmxhZ1xuICBpZiAodHlwZW9mIHdzQ29tcG9uZW50cy5zZWN1cmUgPT09ICdib29sZWFuJykge1xuICAgIHdzQ29tcG9uZW50cy5zY2hlbWUgPSAod3NDb21wb25lbnRzLnNlY3VyZSA/ICd3c3MnIDogJ3dzJylcbiAgICB3c0NvbXBvbmVudHMuc2VjdXJlID0gdW5kZWZpbmVkXG4gIH1cblxuICAvLyByZWNvbnN0cnVjdCBwYXRoIGZyb20gcmVzb3VyY2UgbmFtZVxuICBpZiAod3NDb21wb25lbnRzLnJlc291cmNlTmFtZSkge1xuICAgIGNvbnN0IFtwYXRoLCBxdWVyeV0gPSB3c0NvbXBvbmVudHMucmVzb3VyY2VOYW1lLnNwbGl0KCc/JylcbiAgICB3c0NvbXBvbmVudHMucGF0aCA9IChwYXRoICYmIHBhdGggIT09ICcvJyA/IHBhdGggOiB1bmRlZmluZWQpXG4gICAgd3NDb21wb25lbnRzLnF1ZXJ5ID0gcXVlcnlcbiAgICB3c0NvbXBvbmVudHMucmVzb3VyY2VOYW1lID0gdW5kZWZpbmVkXG4gIH1cblxuICAvLyBmb3JiaWQgZnJhZ21lbnQgY29tcG9uZW50XG4gIHdzQ29tcG9uZW50cy5mcmFnbWVudCA9IHVuZGVmaW5lZFxuXG4gIHJldHVybiB3c0NvbXBvbmVudHNcbn1cblxuZnVuY3Rpb24gdXJuUGFyc2UgKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgaWYgKCF1cm5Db21wb25lbnRzLnBhdGgpIHtcbiAgICB1cm5Db21wb25lbnRzLmVycm9yID0gJ1VSTiBjYW4gbm90IGJlIHBhcnNlZCdcbiAgICByZXR1cm4gdXJuQ29tcG9uZW50c1xuICB9XG4gIGNvbnN0IG1hdGNoZXMgPSB1cm5Db21wb25lbnRzLnBhdGgubWF0Y2goVVJOX1JFRylcbiAgaWYgKG1hdGNoZXMpIHtcbiAgICBjb25zdCBzY2hlbWUgPSBvcHRpb25zLnNjaGVtZSB8fCB1cm5Db21wb25lbnRzLnNjaGVtZSB8fCAndXJuJ1xuICAgIHVybkNvbXBvbmVudHMubmlkID0gbWF0Y2hlc1sxXS50b0xvd2VyQ2FzZSgpXG4gICAgdXJuQ29tcG9uZW50cy5uc3MgPSBtYXRjaGVzWzJdXG4gICAgY29uc3QgdXJuU2NoZW1lID0gYCR7c2NoZW1lfToke29wdGlvbnMubmlkIHx8IHVybkNvbXBvbmVudHMubmlkfWBcbiAgICBjb25zdCBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1t1cm5TY2hlbWVdXG4gICAgdXJuQ29tcG9uZW50cy5wYXRoID0gdW5kZWZpbmVkXG5cbiAgICBpZiAoc2NoZW1lSGFuZGxlcikge1xuICAgICAgdXJuQ29tcG9uZW50cyA9IHNjaGVtZUhhbmRsZXIucGFyc2UodXJuQ29tcG9uZW50cywgb3B0aW9ucylcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdXJuQ29tcG9uZW50cy5lcnJvciA9IHVybkNvbXBvbmVudHMuZXJyb3IgfHwgJ1VSTiBjYW4gbm90IGJlIHBhcnNlZC4nXG4gIH1cblxuICByZXR1cm4gdXJuQ29tcG9uZW50c1xufVxuXG5mdW5jdGlvbiB1cm5TZXJpYWxpemUgKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc2NoZW1lID0gb3B0aW9ucy5zY2hlbWUgfHwgdXJuQ29tcG9uZW50cy5zY2hlbWUgfHwgJ3VybidcbiAgY29uc3QgbmlkID0gdXJuQ29tcG9uZW50cy5uaWQudG9Mb3dlckNhc2UoKVxuICBjb25zdCB1cm5TY2hlbWUgPSBgJHtzY2hlbWV9OiR7b3B0aW9ucy5uaWQgfHwgbmlkfWBcbiAgY29uc3Qgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbdXJuU2NoZW1lXVxuXG4gIGlmIChzY2hlbWVIYW5kbGVyKSB7XG4gICAgdXJuQ29tcG9uZW50cyA9IHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpXG4gIH1cblxuICBjb25zdCB1cmlDb21wb25lbnRzID0gdXJuQ29tcG9uZW50c1xuICBjb25zdCBuc3MgPSB1cm5Db21wb25lbnRzLm5zc1xuICB1cmlDb21wb25lbnRzLnBhdGggPSBgJHtuaWQgfHwgb3B0aW9ucy5uaWR9OiR7bnNzfWBcblxuICBvcHRpb25zLnNraXBFc2NhcGUgPSB0cnVlXG4gIHJldHVybiB1cmlDb21wb25lbnRzXG59XG5cbmZ1bmN0aW9uIHVybnV1aWRQYXJzZSAodXJuQ29tcG9uZW50cywgb3B0aW9ucykge1xuICBjb25zdCB1dWlkQ29tcG9uZW50cyA9IHVybkNvbXBvbmVudHNcbiAgdXVpZENvbXBvbmVudHMudXVpZCA9IHV1aWRDb21wb25lbnRzLm5zc1xuICB1dWlkQ29tcG9uZW50cy5uc3MgPSB1bmRlZmluZWRcblxuICBpZiAoIW9wdGlvbnMudG9sZXJhbnQgJiYgKCF1dWlkQ29tcG9uZW50cy51dWlkIHx8ICFVVUlEX1JFRy50ZXN0KHV1aWRDb21wb25lbnRzLnV1aWQpKSkge1xuICAgIHV1aWRDb21wb25lbnRzLmVycm9yID0gdXVpZENvbXBvbmVudHMuZXJyb3IgfHwgJ1VVSUQgaXMgbm90IHZhbGlkLidcbiAgfVxuXG4gIHJldHVybiB1dWlkQ29tcG9uZW50c1xufVxuXG5mdW5jdGlvbiB1cm51dWlkU2VyaWFsaXplICh1dWlkQ29tcG9uZW50cykge1xuICBjb25zdCB1cm5Db21wb25lbnRzID0gdXVpZENvbXBvbmVudHNcbiAgLy8gbm9ybWFsaXplIFVVSURcbiAgdXJuQ29tcG9uZW50cy5uc3MgPSAodXVpZENvbXBvbmVudHMudXVpZCB8fCAnJykudG9Mb3dlckNhc2UoKVxuICByZXR1cm4gdXJuQ29tcG9uZW50c1xufVxuXG5jb25zdCBodHRwID0ge1xuICBzY2hlbWU6ICdodHRwJyxcbiAgZG9tYWluSG9zdDogdHJ1ZSxcbiAgcGFyc2U6IGh0dHBQYXJzZSxcbiAgc2VyaWFsaXplOiBodHRwU2VyaWFsaXplXG59XG5cbmNvbnN0IGh0dHBzID0ge1xuICBzY2hlbWU6ICdodHRwcycsXG4gIGRvbWFpbkhvc3Q6IGh0dHAuZG9tYWluSG9zdCxcbiAgcGFyc2U6IGh0dHBQYXJzZSxcbiAgc2VyaWFsaXplOiBodHRwU2VyaWFsaXplXG59XG5cbmNvbnN0IHdzID0ge1xuICBzY2hlbWU6ICd3cycsXG4gIGRvbWFpbkhvc3Q6IHRydWUsXG4gIHBhcnNlOiB3c1BhcnNlLFxuICBzZXJpYWxpemU6IHdzU2VyaWFsaXplXG59XG5cbmNvbnN0IHdzcyA9IHtcbiAgc2NoZW1lOiAnd3NzJyxcbiAgZG9tYWluSG9zdDogd3MuZG9tYWluSG9zdCxcbiAgcGFyc2U6IHdzLnBhcnNlLFxuICBzZXJpYWxpemU6IHdzLnNlcmlhbGl6ZVxufVxuXG5jb25zdCB1cm4gPSB7XG4gIHNjaGVtZTogJ3VybicsXG4gIHBhcnNlOiB1cm5QYXJzZSxcbiAgc2VyaWFsaXplOiB1cm5TZXJpYWxpemUsXG4gIHNraXBOb3JtYWxpemU6IHRydWVcbn1cblxuY29uc3QgdXJudXVpZCA9IHtcbiAgc2NoZW1lOiAndXJuOnV1aWQnLFxuICBwYXJzZTogdXJudXVpZFBhcnNlLFxuICBzZXJpYWxpemU6IHVybnV1aWRTZXJpYWxpemUsXG4gIHNraXBOb3JtYWxpemU6IHRydWVcbn1cblxuY29uc3QgU0NIRU1FUyA9IHtcbiAgaHR0cCxcbiAgaHR0cHMsXG4gIHdzLFxuICB3c3MsXG4gIHVybixcbiAgJ3Vybjp1dWlkJzogdXJudXVpZFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNDSEVNRVNcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/schemes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/scopedChars.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/scopedChars.js ***!
  \************************************************************************************/
/***/ ((module) => {

eval("\n\nconst HEX = {\n  0: 0,\n  1: 1,\n  2: 2,\n  3: 3,\n  4: 4,\n  5: 5,\n  6: 6,\n  7: 7,\n  8: 8,\n  9: 9,\n  a: 10,\n  A: 10,\n  b: 11,\n  B: 11,\n  c: 12,\n  C: 12,\n  d: 13,\n  D: 13,\n  e: 14,\n  E: 14,\n  f: 15,\n  F: 15\n}\n\nmodule.exports = {\n  HEX\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZmFzdC11cmlAMy4wLjMvbm9kZV9tb2R1bGVzL2Zhc3QtdXJpL2xpYi9zY29wZWRDaGFycy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMva2FyZWxsZS92c2Nwcm9qZWN0cy90ZWNoLWZsZWV0L3RhaW5vLWxhbmd1YWdlLWFwcC9sZXNzb24tYXV0aG9yaW5nL25vZGVfbW9kdWxlcy8ucG5wbS9mYXN0LXVyaUAzLjAuMy9ub2RlX21vZHVsZXMvZmFzdC11cmkvbGliL3Njb3BlZENoYXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBIRVggPSB7XG4gIDA6IDAsXG4gIDE6IDEsXG4gIDI6IDIsXG4gIDM6IDMsXG4gIDQ6IDQsXG4gIDU6IDUsXG4gIDY6IDYsXG4gIDc6IDcsXG4gIDg6IDgsXG4gIDk6IDksXG4gIGE6IDEwLFxuICBBOiAxMCxcbiAgYjogMTEsXG4gIEI6IDExLFxuICBjOiAxMixcbiAgQzogMTIsXG4gIGQ6IDEzLFxuICBEOiAxMyxcbiAgZTogMTQsXG4gIEU6IDE0LFxuICBmOiAxNSxcbiAgRjogMTVcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEhFWFxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/scopedChars.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/utils.js":
/*!******************************************************************************!*\
  !*** ./node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/utils.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { HEX } = __webpack_require__(/*! ./scopedChars */ \"(ssr)/./node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/scopedChars.js\")\n\nfunction normalizeIPv4 (host) {\n  if (findToken(host, '.') < 3) { return { host, isIPV4: false } }\n  const matches = host.match(/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/u) || []\n  const [address] = matches\n  if (address) {\n    return { host: stripLeadingZeros(address, '.'), isIPV4: true }\n  } else {\n    return { host, isIPV4: false }\n  }\n}\n\n/**\n * @param {string[]} input\n * @param {boolean} [keepZero=false]\n * @returns {string|undefined}\n */\nfunction stringArrayToHexStripped (input, keepZero = false) {\n  let acc = ''\n  let strip = true\n  for (const c of input) {\n    if (HEX[c] === undefined) return undefined\n    if (c !== '0' && strip === true) strip = false\n    if (!strip) acc += c\n  }\n  if (keepZero && acc.length === 0) acc = '0'\n  return acc\n}\n\nfunction getIPV6 (input) {\n  let tokenCount = 0\n  const output = { error: false, address: '', zone: '' }\n  const address = []\n  const buffer = []\n  let isZone = false\n  let endipv6Encountered = false\n  let endIpv6 = false\n\n  function consume () {\n    if (buffer.length) {\n      if (isZone === false) {\n        const hex = stringArrayToHexStripped(buffer)\n        if (hex !== undefined) {\n          address.push(hex)\n        } else {\n          output.error = true\n          return false\n        }\n      }\n      buffer.length = 0\n    }\n    return true\n  }\n\n  for (let i = 0; i < input.length; i++) {\n    const cursor = input[i]\n    if (cursor === '[' || cursor === ']') { continue }\n    if (cursor === ':') {\n      if (endipv6Encountered === true) {\n        endIpv6 = true\n      }\n      if (!consume()) { break }\n      tokenCount++\n      address.push(':')\n      if (tokenCount > 7) {\n        // not valid\n        output.error = true\n        break\n      }\n      if (i - 1 >= 0 && input[i - 1] === ':') {\n        endipv6Encountered = true\n      }\n      continue\n    } else if (cursor === '%') {\n      if (!consume()) { break }\n      // switch to zone detection\n      isZone = true\n    } else {\n      buffer.push(cursor)\n      continue\n    }\n  }\n  if (buffer.length) {\n    if (isZone) {\n      output.zone = buffer.join('')\n    } else if (endIpv6) {\n      address.push(buffer.join(''))\n    } else {\n      address.push(stringArrayToHexStripped(buffer))\n    }\n  }\n  output.address = address.join('')\n  return output\n}\n\nfunction normalizeIPv6 (host, opts = {}) {\n  if (findToken(host, ':') < 2) { return { host, isIPV6: false } }\n  const ipv6 = getIPV6(host)\n\n  if (!ipv6.error) {\n    let newHost = ipv6.address\n    let escapedHost = ipv6.address\n    if (ipv6.zone) {\n      newHost += '%' + ipv6.zone\n      escapedHost += '%25' + ipv6.zone\n    }\n    return { host: newHost, escapedHost, isIPV6: true }\n  } else {\n    return { host, isIPV6: false }\n  }\n}\n\nfunction stripLeadingZeros (str, token) {\n  let out = ''\n  let skip = true\n  const l = str.length\n  for (let i = 0; i < l; i++) {\n    const c = str[i]\n    if (c === '0' && skip) {\n      if ((i + 1 <= l && str[i + 1] === token) || i + 1 === l) {\n        out += c\n        skip = false\n      }\n    } else {\n      if (c === token) {\n        skip = true\n      } else {\n        skip = false\n      }\n      out += c\n    }\n  }\n  return out\n}\n\nfunction findToken (str, token) {\n  let ind = 0\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === token) ind++\n  }\n  return ind\n}\n\nconst RDS1 = /^\\.\\.?\\//u\nconst RDS2 = /^\\/\\.(?:\\/|$)/u\nconst RDS3 = /^\\/\\.\\.(?:\\/|$)/u\nconst RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/u\n\nfunction removeDotSegments (input) {\n  const output = []\n\n  while (input.length) {\n    if (input.match(RDS1)) {\n      input = input.replace(RDS1, '')\n    } else if (input.match(RDS2)) {\n      input = input.replace(RDS2, '/')\n    } else if (input.match(RDS3)) {\n      input = input.replace(RDS3, '/')\n      output.pop()\n    } else if (input === '.' || input === '..') {\n      input = ''\n    } else {\n      const im = input.match(RDS5)\n      if (im) {\n        const s = im[0]\n        input = input.slice(s.length)\n        output.push(s)\n      } else {\n        throw new Error('Unexpected dot segment condition')\n      }\n    }\n  }\n  return output.join('')\n}\n\nfunction normalizeComponentEncoding (components, esc) {\n  const func = esc !== true ? escape : unescape\n  if (components.scheme !== undefined) {\n    components.scheme = func(components.scheme)\n  }\n  if (components.userinfo !== undefined) {\n    components.userinfo = func(components.userinfo)\n  }\n  if (components.host !== undefined) {\n    components.host = func(components.host)\n  }\n  if (components.path !== undefined) {\n    components.path = func(components.path)\n  }\n  if (components.query !== undefined) {\n    components.query = func(components.query)\n  }\n  if (components.fragment !== undefined) {\n    components.fragment = func(components.fragment)\n  }\n  return components\n}\n\nfunction recomposeAuthority (components, options) {\n  const uriTokens = []\n\n  if (components.userinfo !== undefined) {\n    uriTokens.push(components.userinfo)\n    uriTokens.push('@')\n  }\n\n  if (components.host !== undefined) {\n    let host = unescape(components.host)\n    const ipV4res = normalizeIPv4(host)\n\n    if (ipV4res.isIPV4) {\n      host = ipV4res.host\n    } else {\n      const ipV6res = normalizeIPv6(ipV4res.host, { isIPV4: false })\n      if (ipV6res.isIPV6 === true) {\n        host = `[${ipV6res.escapedHost}]`\n      } else {\n        host = components.host\n      }\n    }\n    uriTokens.push(host)\n  }\n\n  if (typeof components.port === 'number' || typeof components.port === 'string') {\n    uriTokens.push(':')\n    uriTokens.push(String(components.port))\n  }\n\n  return uriTokens.length ? uriTokens.join('') : undefined\n};\n\nmodule.exports = {\n  recomposeAuthority,\n  normalizeComponentEncoding,\n  removeDotSegments,\n  normalizeIPv4,\n  normalizeIPv6,\n  stringArrayToHexStripped\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZmFzdC11cmlAMy4wLjMvbm9kZV9tb2R1bGVzL2Zhc3QtdXJpL2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLE1BQU0sRUFBRSxtQkFBTyxDQUFDLHlHQUFlOztBQUV2QztBQUNBLGtDQUFrQyxTQUFTO0FBQzNDLDBGQUEwRixFQUFFO0FBQzVGO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsSUFBSTtBQUNKLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QztBQUN2QyxrQ0FBa0MsU0FBUztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixJQUFJO0FBQ0osYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sb0RBQW9ELGVBQWU7QUFDbkU7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2thcmVsbGUvdnNjcHJvamVjdHMvdGVjaC1mbGVldC90YWluby1sYW5ndWFnZS1hcHAvbGVzc29uLWF1dGhvcmluZy9ub2RlX21vZHVsZXMvLnBucG0vZmFzdC11cmlAMy4wLjMvbm9kZV9tb2R1bGVzL2Zhc3QtdXJpL2xpYi91dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBIRVggfSA9IHJlcXVpcmUoJy4vc2NvcGVkQ2hhcnMnKVxuXG5mdW5jdGlvbiBub3JtYWxpemVJUHY0IChob3N0KSB7XG4gIGlmIChmaW5kVG9rZW4oaG9zdCwgJy4nKSA8IDMpIHsgcmV0dXJuIHsgaG9zdCwgaXNJUFY0OiBmYWxzZSB9IH1cbiAgY29uc3QgbWF0Y2hlcyA9IGhvc3QubWF0Y2goL14oPzooPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSkkL3UpIHx8IFtdXG4gIGNvbnN0IFthZGRyZXNzXSA9IG1hdGNoZXNcbiAgaWYgKGFkZHJlc3MpIHtcbiAgICByZXR1cm4geyBob3N0OiBzdHJpcExlYWRpbmdaZXJvcyhhZGRyZXNzLCAnLicpLCBpc0lQVjQ6IHRydWUgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IGhvc3QsIGlzSVBWNDogZmFsc2UgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gaW5wdXRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2tlZXBaZXJvPWZhbHNlXVxuICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ0FycmF5VG9IZXhTdHJpcHBlZCAoaW5wdXQsIGtlZXBaZXJvID0gZmFsc2UpIHtcbiAgbGV0IGFjYyA9ICcnXG4gIGxldCBzdHJpcCA9IHRydWVcbiAgZm9yIChjb25zdCBjIG9mIGlucHV0KSB7XG4gICAgaWYgKEhFWFtjXSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgaWYgKGMgIT09ICcwJyAmJiBzdHJpcCA9PT0gdHJ1ZSkgc3RyaXAgPSBmYWxzZVxuICAgIGlmICghc3RyaXApIGFjYyArPSBjXG4gIH1cbiAgaWYgKGtlZXBaZXJvICYmIGFjYy5sZW5ndGggPT09IDApIGFjYyA9ICcwJ1xuICByZXR1cm4gYWNjXG59XG5cbmZ1bmN0aW9uIGdldElQVjYgKGlucHV0KSB7XG4gIGxldCB0b2tlbkNvdW50ID0gMFxuICBjb25zdCBvdXRwdXQgPSB7IGVycm9yOiBmYWxzZSwgYWRkcmVzczogJycsIHpvbmU6ICcnIH1cbiAgY29uc3QgYWRkcmVzcyA9IFtdXG4gIGNvbnN0IGJ1ZmZlciA9IFtdXG4gIGxldCBpc1pvbmUgPSBmYWxzZVxuICBsZXQgZW5kaXB2NkVuY291bnRlcmVkID0gZmFsc2VcbiAgbGV0IGVuZElwdjYgPSBmYWxzZVxuXG4gIGZ1bmN0aW9uIGNvbnN1bWUgKCkge1xuICAgIGlmIChidWZmZXIubGVuZ3RoKSB7XG4gICAgICBpZiAoaXNab25lID09PSBmYWxzZSkge1xuICAgICAgICBjb25zdCBoZXggPSBzdHJpbmdBcnJheVRvSGV4U3RyaXBwZWQoYnVmZmVyKVxuICAgICAgICBpZiAoaGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhZGRyZXNzLnB1c2goaGV4KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dHB1dC5lcnJvciA9IHRydWVcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnVmZmVyLmxlbmd0aCA9IDBcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjdXJzb3IgPSBpbnB1dFtpXVxuICAgIGlmIChjdXJzb3IgPT09ICdbJyB8fCBjdXJzb3IgPT09ICddJykgeyBjb250aW51ZSB9XG4gICAgaWYgKGN1cnNvciA9PT0gJzonKSB7XG4gICAgICBpZiAoZW5kaXB2NkVuY291bnRlcmVkID09PSB0cnVlKSB7XG4gICAgICAgIGVuZElwdjYgPSB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoIWNvbnN1bWUoKSkgeyBicmVhayB9XG4gICAgICB0b2tlbkNvdW50KytcbiAgICAgIGFkZHJlc3MucHVzaCgnOicpXG4gICAgICBpZiAodG9rZW5Db3VudCA+IDcpIHtcbiAgICAgICAgLy8gbm90IHZhbGlkXG4gICAgICAgIG91dHB1dC5lcnJvciA9IHRydWVcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGlmIChpIC0gMSA+PSAwICYmIGlucHV0W2kgLSAxXSA9PT0gJzonKSB7XG4gICAgICAgIGVuZGlwdjZFbmNvdW50ZXJlZCA9IHRydWVcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlXG4gICAgfSBlbHNlIGlmIChjdXJzb3IgPT09ICclJykge1xuICAgICAgaWYgKCFjb25zdW1lKCkpIHsgYnJlYWsgfVxuICAgICAgLy8gc3dpdGNoIHRvIHpvbmUgZGV0ZWN0aW9uXG4gICAgICBpc1pvbmUgPSB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZmZlci5wdXNoKGN1cnNvcilcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICB9XG4gIGlmIChidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGlzWm9uZSkge1xuICAgICAgb3V0cHV0LnpvbmUgPSBidWZmZXIuam9pbignJylcbiAgICB9IGVsc2UgaWYgKGVuZElwdjYpIHtcbiAgICAgIGFkZHJlc3MucHVzaChidWZmZXIuam9pbignJykpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZHJlc3MucHVzaChzdHJpbmdBcnJheVRvSGV4U3RyaXBwZWQoYnVmZmVyKSlcbiAgICB9XG4gIH1cbiAgb3V0cHV0LmFkZHJlc3MgPSBhZGRyZXNzLmpvaW4oJycpXG4gIHJldHVybiBvdXRwdXRcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplSVB2NiAoaG9zdCwgb3B0cyA9IHt9KSB7XG4gIGlmIChmaW5kVG9rZW4oaG9zdCwgJzonKSA8IDIpIHsgcmV0dXJuIHsgaG9zdCwgaXNJUFY2OiBmYWxzZSB9IH1cbiAgY29uc3QgaXB2NiA9IGdldElQVjYoaG9zdClcblxuICBpZiAoIWlwdjYuZXJyb3IpIHtcbiAgICBsZXQgbmV3SG9zdCA9IGlwdjYuYWRkcmVzc1xuICAgIGxldCBlc2NhcGVkSG9zdCA9IGlwdjYuYWRkcmVzc1xuICAgIGlmIChpcHY2LnpvbmUpIHtcbiAgICAgIG5ld0hvc3QgKz0gJyUnICsgaXB2Ni56b25lXG4gICAgICBlc2NhcGVkSG9zdCArPSAnJTI1JyArIGlwdjYuem9uZVxuICAgIH1cbiAgICByZXR1cm4geyBob3N0OiBuZXdIb3N0LCBlc2NhcGVkSG9zdCwgaXNJUFY2OiB0cnVlIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geyBob3N0LCBpc0lQVjY6IGZhbHNlIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdHJpcExlYWRpbmdaZXJvcyAoc3RyLCB0b2tlbikge1xuICBsZXQgb3V0ID0gJydcbiAgbGV0IHNraXAgPSB0cnVlXG4gIGNvbnN0IGwgPSBzdHIubGVuZ3RoXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3QgYyA9IHN0cltpXVxuICAgIGlmIChjID09PSAnMCcgJiYgc2tpcCkge1xuICAgICAgaWYgKChpICsgMSA8PSBsICYmIHN0cltpICsgMV0gPT09IHRva2VuKSB8fCBpICsgMSA9PT0gbCkge1xuICAgICAgICBvdXQgKz0gY1xuICAgICAgICBza2lwID0gZmFsc2VcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGMgPT09IHRva2VuKSB7XG4gICAgICAgIHNraXAgPSB0cnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBza2lwID0gZmFsc2VcbiAgICAgIH1cbiAgICAgIG91dCArPSBjXG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gZmluZFRva2VuIChzdHIsIHRva2VuKSB7XG4gIGxldCBpbmQgPSAwXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0cltpXSA9PT0gdG9rZW4pIGluZCsrXG4gIH1cbiAgcmV0dXJuIGluZFxufVxuXG5jb25zdCBSRFMxID0gL15cXC5cXC4/XFwvL3VcbmNvbnN0IFJEUzIgPSAvXlxcL1xcLig/OlxcL3wkKS91XG5jb25zdCBSRFMzID0gL15cXC9cXC5cXC4oPzpcXC98JCkvdVxuY29uc3QgUkRTNSA9IC9eXFwvPyg/Oi58XFxuKSo/KD89XFwvfCQpL3VcblxuZnVuY3Rpb24gcmVtb3ZlRG90U2VnbWVudHMgKGlucHV0KSB7XG4gIGNvbnN0IG91dHB1dCA9IFtdXG5cbiAgd2hpbGUgKGlucHV0Lmxlbmd0aCkge1xuICAgIGlmIChpbnB1dC5tYXRjaChSRFMxKSkge1xuICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKFJEUzEsICcnKVxuICAgIH0gZWxzZSBpZiAoaW5wdXQubWF0Y2goUkRTMikpIHtcbiAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMyLCAnLycpXG4gICAgfSBlbHNlIGlmIChpbnB1dC5tYXRjaChSRFMzKSkge1xuICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKFJEUzMsICcvJylcbiAgICAgIG91dHB1dC5wb3AoKVxuICAgIH0gZWxzZSBpZiAoaW5wdXQgPT09ICcuJyB8fCBpbnB1dCA9PT0gJy4uJykge1xuICAgICAgaW5wdXQgPSAnJ1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpbSA9IGlucHV0Lm1hdGNoKFJEUzUpXG4gICAgICBpZiAoaW0pIHtcbiAgICAgICAgY29uc3QgcyA9IGltWzBdXG4gICAgICAgIGlucHV0ID0gaW5wdXQuc2xpY2Uocy5sZW5ndGgpXG4gICAgICAgIG91dHB1dC5wdXNoKHMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgZG90IHNlZ21lbnQgY29uZGl0aW9uJylcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyAoY29tcG9uZW50cywgZXNjKSB7XG4gIGNvbnN0IGZ1bmMgPSBlc2MgIT09IHRydWUgPyBlc2NhcGUgOiB1bmVzY2FwZVxuICBpZiAoY29tcG9uZW50cy5zY2hlbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbXBvbmVudHMuc2NoZW1lID0gZnVuYyhjb21wb25lbnRzLnNjaGVtZSlcbiAgfVxuICBpZiAoY29tcG9uZW50cy51c2VyaW5mbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29tcG9uZW50cy51c2VyaW5mbyA9IGZ1bmMoY29tcG9uZW50cy51c2VyaW5mbylcbiAgfVxuICBpZiAoY29tcG9uZW50cy5ob3N0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb21wb25lbnRzLmhvc3QgPSBmdW5jKGNvbXBvbmVudHMuaG9zdClcbiAgfVxuICBpZiAoY29tcG9uZW50cy5wYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb21wb25lbnRzLnBhdGggPSBmdW5jKGNvbXBvbmVudHMucGF0aClcbiAgfVxuICBpZiAoY29tcG9uZW50cy5xdWVyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29tcG9uZW50cy5xdWVyeSA9IGZ1bmMoY29tcG9uZW50cy5xdWVyeSlcbiAgfVxuICBpZiAoY29tcG9uZW50cy5mcmFnbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29tcG9uZW50cy5mcmFnbWVudCA9IGZ1bmMoY29tcG9uZW50cy5mcmFnbWVudClcbiAgfVxuICByZXR1cm4gY29tcG9uZW50c1xufVxuXG5mdW5jdGlvbiByZWNvbXBvc2VBdXRob3JpdHkgKGNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgY29uc3QgdXJpVG9rZW5zID0gW11cblxuICBpZiAoY29tcG9uZW50cy51c2VyaW5mbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy51c2VyaW5mbylcbiAgICB1cmlUb2tlbnMucHVzaCgnQCcpXG4gIH1cblxuICBpZiAoY29tcG9uZW50cy5ob3N0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBsZXQgaG9zdCA9IHVuZXNjYXBlKGNvbXBvbmVudHMuaG9zdClcbiAgICBjb25zdCBpcFY0cmVzID0gbm9ybWFsaXplSVB2NChob3N0KVxuXG4gICAgaWYgKGlwVjRyZXMuaXNJUFY0KSB7XG4gICAgICBob3N0ID0gaXBWNHJlcy5ob3N0XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGlwVjZyZXMgPSBub3JtYWxpemVJUHY2KGlwVjRyZXMuaG9zdCwgeyBpc0lQVjQ6IGZhbHNlIH0pXG4gICAgICBpZiAoaXBWNnJlcy5pc0lQVjYgPT09IHRydWUpIHtcbiAgICAgICAgaG9zdCA9IGBbJHtpcFY2cmVzLmVzY2FwZWRIb3N0fV1gXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBob3N0ID0gY29tcG9uZW50cy5ob3N0XG4gICAgICB9XG4gICAgfVxuICAgIHVyaVRva2Vucy5wdXNoKGhvc3QpXG4gIH1cblxuICBpZiAodHlwZW9mIGNvbXBvbmVudHMucG9ydCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGNvbXBvbmVudHMucG9ydCA9PT0gJ3N0cmluZycpIHtcbiAgICB1cmlUb2tlbnMucHVzaCgnOicpXG4gICAgdXJpVG9rZW5zLnB1c2goU3RyaW5nKGNvbXBvbmVudHMucG9ydCkpXG4gIH1cblxuICByZXR1cm4gdXJpVG9rZW5zLmxlbmd0aCA/IHVyaVRva2Vucy5qb2luKCcnKSA6IHVuZGVmaW5lZFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJlY29tcG9zZUF1dGhvcml0eSxcbiAgbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcsXG4gIHJlbW92ZURvdFNlZ21lbnRzLFxuICBub3JtYWxpemVJUHY0LFxuICBub3JtYWxpemVJUHY2LFxuICBzdHJpbmdBcnJheVRvSGV4U3RyaXBwZWRcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/index.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = __webpack_require__(/*! ./lib/utils */ \"(rsc)/./node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/utils.js\")\nconst SCHEMES = __webpack_require__(/*! ./lib/schemes */ \"(rsc)/./node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/schemes.js\")\n\nfunction normalize (uri, options) {\n  if (typeof uri === 'string') {\n    uri = serialize(parse(uri, options), options)\n  } else if (typeof uri === 'object') {\n    uri = parse(serialize(uri, options), options)\n  }\n  return uri\n}\n\nfunction resolve (baseURI, relativeURI, options) {\n  const schemelessOptions = Object.assign({ scheme: 'null' }, options)\n  const resolved = resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true)\n  return serialize(resolved, { ...schemelessOptions, skipEscape: true })\n}\n\nfunction resolveComponents (base, relative, options, skipNormalization) {\n  const target = {}\n  if (!skipNormalization) {\n    base = parse(serialize(base, options), options) // normalize base components\n    relative = parse(serialize(relative, options), options) // normalize relative components\n  }\n  options = options || {}\n\n  if (!options.tolerant && relative.scheme) {\n    target.scheme = relative.scheme\n    // target.authority = relative.authority;\n    target.userinfo = relative.userinfo\n    target.host = relative.host\n    target.port = relative.port\n    target.path = removeDotSegments(relative.path || '')\n    target.query = relative.query\n  } else {\n    if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n      // target.authority = relative.authority;\n      target.userinfo = relative.userinfo\n      target.host = relative.host\n      target.port = relative.port\n      target.path = removeDotSegments(relative.path || '')\n      target.query = relative.query\n    } else {\n      if (!relative.path) {\n        target.path = base.path\n        if (relative.query !== undefined) {\n          target.query = relative.query\n        } else {\n          target.query = base.query\n        }\n      } else {\n        if (relative.path.charAt(0) === '/') {\n          target.path = removeDotSegments(relative.path)\n        } else {\n          if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n            target.path = '/' + relative.path\n          } else if (!base.path) {\n            target.path = relative.path\n          } else {\n            target.path = base.path.slice(0, base.path.lastIndexOf('/') + 1) + relative.path\n          }\n          target.path = removeDotSegments(target.path)\n        }\n        target.query = relative.query\n      }\n      // target.authority = base.authority;\n      target.userinfo = base.userinfo\n      target.host = base.host\n      target.port = base.port\n    }\n    target.scheme = base.scheme\n  }\n\n  target.fragment = relative.fragment\n\n  return target\n}\n\nfunction equal (uriA, uriB, options) {\n  if (typeof uriA === 'string') {\n    uriA = unescape(uriA)\n    uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true })\n  } else if (typeof uriA === 'object') {\n    uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true })\n  }\n\n  if (typeof uriB === 'string') {\n    uriB = unescape(uriB)\n    uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true })\n  } else if (typeof uriB === 'object') {\n    uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true })\n  }\n\n  return uriA.toLowerCase() === uriB.toLowerCase()\n}\n\nfunction serialize (cmpts, opts) {\n  const components = {\n    host: cmpts.host,\n    scheme: cmpts.scheme,\n    userinfo: cmpts.userinfo,\n    port: cmpts.port,\n    path: cmpts.path,\n    query: cmpts.query,\n    nid: cmpts.nid,\n    nss: cmpts.nss,\n    uuid: cmpts.uuid,\n    fragment: cmpts.fragment,\n    reference: cmpts.reference,\n    resourceName: cmpts.resourceName,\n    secure: cmpts.secure,\n    error: ''\n  }\n  const options = Object.assign({}, opts)\n  const uriTokens = []\n\n  // find scheme handler\n  const schemeHandler = SCHEMES[(options.scheme || components.scheme || '').toLowerCase()]\n\n  // perform scheme specific serialization\n  if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options)\n\n  if (components.path !== undefined) {\n    if (!options.skipEscape) {\n      components.path = escape(components.path)\n\n      if (components.scheme !== undefined) {\n        components.path = components.path.split('%3A').join(':')\n      }\n    } else {\n      components.path = unescape(components.path)\n    }\n  }\n\n  if (options.reference !== 'suffix' && components.scheme) {\n    uriTokens.push(components.scheme, ':')\n  }\n\n  const authority = recomposeAuthority(components, options)\n  if (authority !== undefined) {\n    if (options.reference !== 'suffix') {\n      uriTokens.push('//')\n    }\n\n    uriTokens.push(authority)\n\n    if (components.path && components.path.charAt(0) !== '/') {\n      uriTokens.push('/')\n    }\n  }\n  if (components.path !== undefined) {\n    let s = components.path\n\n    if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n      s = removeDotSegments(s)\n    }\n\n    if (authority === undefined) {\n      s = s.replace(/^\\/\\//u, '/%2F') // don't allow the path to start with \"//\"\n    }\n\n    uriTokens.push(s)\n  }\n\n  if (components.query !== undefined) {\n    uriTokens.push('?', components.query)\n  }\n\n  if (components.fragment !== undefined) {\n    uriTokens.push('#', components.fragment)\n  }\n  return uriTokens.join('')\n}\n\nconst hexLookUp = Array.from({ length: 127 }, (v, k) => /[^!\"$&'()*+,\\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)))\n\nfunction nonSimpleDomain (value) {\n  let code = 0\n  for (let i = 0, len = value.length; i < len; ++i) {\n    code = value.charCodeAt(i)\n    if (code > 126 || hexLookUp[code]) {\n      return true\n    }\n  }\n  return false\n}\n\nconst URI_PARSE = /^(?:([^#/:?]+):)?(?:\\/\\/((?:([^#/?@]*)@)?(\\[[^#/?\\]]+\\]|[^#/:?]*)(?::(\\d*))?))?([^#?]*)(?:\\?([^#]*))?(?:#((?:.|[\\n\\r])*))?/u\n\nfunction parse (uri, opts) {\n  const options = Object.assign({}, opts)\n  const parsed = {\n    scheme: undefined,\n    userinfo: undefined,\n    host: '',\n    port: undefined,\n    path: '',\n    query: undefined,\n    fragment: undefined\n  }\n  const gotEncoding = uri.indexOf('%') !== -1\n  let isIP = false\n  if (options.reference === 'suffix') uri = (options.scheme ? options.scheme + ':' : '') + '//' + uri\n\n  const matches = uri.match(URI_PARSE)\n\n  if (matches) {\n    // store each component\n    parsed.scheme = matches[1]\n    parsed.userinfo = matches[3]\n    parsed.host = matches[4]\n    parsed.port = parseInt(matches[5], 10)\n    parsed.path = matches[6] || ''\n    parsed.query = matches[7]\n    parsed.fragment = matches[8]\n\n    // fix port number\n    if (isNaN(parsed.port)) {\n      parsed.port = matches[5]\n    }\n    if (parsed.host) {\n      const ipv4result = normalizeIPv4(parsed.host)\n      if (ipv4result.isIPV4 === false) {\n        const ipv6result = normalizeIPv6(ipv4result.host, { isIPV4: false })\n        parsed.host = ipv6result.host.toLowerCase()\n        isIP = ipv6result.isIPV6\n      } else {\n        parsed.host = ipv4result.host\n        isIP = true\n      }\n    }\n    if (parsed.scheme === undefined && parsed.userinfo === undefined && parsed.host === undefined && parsed.port === undefined && !parsed.path && parsed.query === undefined) {\n      parsed.reference = 'same-document'\n    } else if (parsed.scheme === undefined) {\n      parsed.reference = 'relative'\n    } else if (parsed.fragment === undefined) {\n      parsed.reference = 'absolute'\n    } else {\n      parsed.reference = 'uri'\n    }\n\n    // check for reference errors\n    if (options.reference && options.reference !== 'suffix' && options.reference !== parsed.reference) {\n      parsed.error = parsed.error || 'URI is not a ' + options.reference + ' reference.'\n    }\n\n    // find scheme handler\n    const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || '').toLowerCase()]\n\n    // check if scheme can't handle IRIs\n    if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n      // if host component is a domain name\n      if (parsed.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost)) && isIP === false && nonSimpleDomain(parsed.host)) {\n        // convert Unicode IDN -> ASCII IDN\n        try {\n          parsed.host = URL.domainToASCII(parsed.host.toLowerCase())\n        } catch (e) {\n          parsed.error = parsed.error || \"Host's domain name can not be converted to ASCII: \" + e\n        }\n      }\n      // convert IRI -> URI\n    }\n\n    if (!schemeHandler || (schemeHandler && !schemeHandler.skipNormalize)) {\n      if (gotEncoding && parsed.scheme !== undefined) {\n        parsed.scheme = unescape(parsed.scheme)\n      }\n      if (gotEncoding && parsed.host !== undefined) {\n        parsed.host = unescape(parsed.host)\n      }\n      if (parsed.path !== undefined && parsed.path.length) {\n        parsed.path = escape(unescape(parsed.path))\n      }\n      if (parsed.fragment !== undefined && parsed.fragment.length) {\n        parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment))\n      }\n    }\n\n    // perform scheme specific parsing\n    if (schemeHandler && schemeHandler.parse) {\n      schemeHandler.parse(parsed, options)\n    }\n  } else {\n    parsed.error = parsed.error || 'URI can not be parsed.'\n  }\n  return parsed\n}\n\nconst fastUri = {\n  SCHEMES,\n  normalize,\n  resolve,\n  resolveComponents,\n  equal,\n  serialize,\n  parse\n}\n\nmodule.exports = fastUri\nmodule.exports[\"default\"] = fastUri\nmodule.exports.fastUri = fastUri\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vZmFzdC11cmlAMy4wLjMvbm9kZV9tb2R1bGVzL2Zhc3QtdXJpL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsa0dBQWtHLEVBQUUsbUJBQU8sQ0FBQyxpR0FBYTtBQUNqSSxnQkFBZ0IsbUJBQU8sQ0FBQyxxR0FBZTs7QUFFdkM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLGdCQUFnQjtBQUM1RDtBQUNBLCtCQUErQix3Q0FBd0M7QUFDdkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSw4QkFBOEI7QUFDN0csSUFBSTtBQUNKLCtEQUErRCw4QkFBOEI7QUFDN0Y7O0FBRUE7QUFDQTtBQUNBLCtFQUErRSw4QkFBOEI7QUFDN0csSUFBSTtBQUNKLCtEQUErRCw4QkFBOEI7QUFDN0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQixhQUFhLDZCQUE2QixRQUFROztBQUVqRjtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxlQUFlO0FBQzNFO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXNCO0FBQ3RCLHNCQUFzQiIsInNvdXJjZXMiOlsiL1VzZXJzL2thcmVsbGUvdnNjcHJvamVjdHMvdGVjaC1mbGVldC90YWluby1sYW5ndWFnZS1hcHAvbGVzc29uLWF1dGhvcmluZy9ub2RlX21vZHVsZXMvLnBucG0vZmFzdC11cmlAMy4wLjMvbm9kZV9tb2R1bGVzL2Zhc3QtdXJpL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IG5vcm1hbGl6ZUlQdjYsIG5vcm1hbGl6ZUlQdjQsIHJlbW92ZURvdFNlZ21lbnRzLCByZWNvbXBvc2VBdXRob3JpdHksIG5vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nIH0gPSByZXF1aXJlKCcuL2xpYi91dGlscycpXG5jb25zdCBTQ0hFTUVTID0gcmVxdWlyZSgnLi9saWIvc2NoZW1lcycpXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZSAodXJpLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgdXJpID09PSAnc3RyaW5nJykge1xuICAgIHVyaSA9IHNlcmlhbGl6ZShwYXJzZSh1cmksIG9wdGlvbnMpLCBvcHRpb25zKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB1cmkgPT09ICdvYmplY3QnKSB7XG4gICAgdXJpID0gcGFyc2Uoc2VyaWFsaXplKHVyaSwgb3B0aW9ucyksIG9wdGlvbnMpXG4gIH1cbiAgcmV0dXJuIHVyaVxufVxuXG5mdW5jdGlvbiByZXNvbHZlIChiYXNlVVJJLCByZWxhdGl2ZVVSSSwgb3B0aW9ucykge1xuICBjb25zdCBzY2hlbWVsZXNzT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBzY2hlbWU6ICdudWxsJyB9LCBvcHRpb25zKVxuICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVDb21wb25lbnRzKHBhcnNlKGJhc2VVUkksIHNjaGVtZWxlc3NPcHRpb25zKSwgcGFyc2UocmVsYXRpdmVVUkksIHNjaGVtZWxlc3NPcHRpb25zKSwgc2NoZW1lbGVzc09wdGlvbnMsIHRydWUpXG4gIHJldHVybiBzZXJpYWxpemUocmVzb2x2ZWQsIHsgLi4uc2NoZW1lbGVzc09wdGlvbnMsIHNraXBFc2NhcGU6IHRydWUgfSlcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNvbXBvbmVudHMgKGJhc2UsIHJlbGF0aXZlLCBvcHRpb25zLCBza2lwTm9ybWFsaXphdGlvbikge1xuICBjb25zdCB0YXJnZXQgPSB7fVxuICBpZiAoIXNraXBOb3JtYWxpemF0aW9uKSB7XG4gICAgYmFzZSA9IHBhcnNlKHNlcmlhbGl6ZShiYXNlLCBvcHRpb25zKSwgb3B0aW9ucykgLy8gbm9ybWFsaXplIGJhc2UgY29tcG9uZW50c1xuICAgIHJlbGF0aXZlID0gcGFyc2Uoc2VyaWFsaXplKHJlbGF0aXZlLCBvcHRpb25zKSwgb3B0aW9ucykgLy8gbm9ybWFsaXplIHJlbGF0aXZlIGNvbXBvbmVudHNcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gIGlmICghb3B0aW9ucy50b2xlcmFudCAmJiByZWxhdGl2ZS5zY2hlbWUpIHtcbiAgICB0YXJnZXQuc2NoZW1lID0gcmVsYXRpdmUuc2NoZW1lXG4gICAgLy8gdGFyZ2V0LmF1dGhvcml0eSA9IHJlbGF0aXZlLmF1dGhvcml0eTtcbiAgICB0YXJnZXQudXNlcmluZm8gPSByZWxhdGl2ZS51c2VyaW5mb1xuICAgIHRhcmdldC5ob3N0ID0gcmVsYXRpdmUuaG9zdFxuICAgIHRhcmdldC5wb3J0ID0gcmVsYXRpdmUucG9ydFxuICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCB8fCAnJylcbiAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeVxuICB9IGVsc2Uge1xuICAgIGlmIChyZWxhdGl2ZS51c2VyaW5mbyAhPT0gdW5kZWZpbmVkIHx8IHJlbGF0aXZlLmhvc3QgIT09IHVuZGVmaW5lZCB8fCByZWxhdGl2ZS5wb3J0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHRhcmdldC5hdXRob3JpdHkgPSByZWxhdGl2ZS5hdXRob3JpdHk7XG4gICAgICB0YXJnZXQudXNlcmluZm8gPSByZWxhdGl2ZS51c2VyaW5mb1xuICAgICAgdGFyZ2V0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0XG4gICAgICB0YXJnZXQucG9ydCA9IHJlbGF0aXZlLnBvcnRcbiAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCB8fCAnJylcbiAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghcmVsYXRpdmUucGF0aCkge1xuICAgICAgICB0YXJnZXQucGF0aCA9IGJhc2UucGF0aFxuICAgICAgICBpZiAocmVsYXRpdmUucXVlcnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gYmFzZS5xdWVyeVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmVsYXRpdmUucGF0aC5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoKGJhc2UudXNlcmluZm8gIT09IHVuZGVmaW5lZCB8fCBiYXNlLmhvc3QgIT09IHVuZGVmaW5lZCB8fCBiYXNlLnBvcnQgIT09IHVuZGVmaW5lZCkgJiYgIWJhc2UucGF0aCkge1xuICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSAnLycgKyByZWxhdGl2ZS5wYXRoXG4gICAgICAgICAgfSBlbHNlIGlmICghYmFzZS5wYXRoKSB7XG4gICAgICAgICAgICB0YXJnZXQucGF0aCA9IHJlbGF0aXZlLnBhdGhcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSBiYXNlLnBhdGguc2xpY2UoMCwgYmFzZS5wYXRoLmxhc3RJbmRleE9mKCcvJykgKyAxKSArIHJlbGF0aXZlLnBhdGhcbiAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyh0YXJnZXQucGF0aClcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeVxuICAgICAgfVxuICAgICAgLy8gdGFyZ2V0LmF1dGhvcml0eSA9IGJhc2UuYXV0aG9yaXR5O1xuICAgICAgdGFyZ2V0LnVzZXJpbmZvID0gYmFzZS51c2VyaW5mb1xuICAgICAgdGFyZ2V0Lmhvc3QgPSBiYXNlLmhvc3RcbiAgICAgIHRhcmdldC5wb3J0ID0gYmFzZS5wb3J0XG4gICAgfVxuICAgIHRhcmdldC5zY2hlbWUgPSBiYXNlLnNjaGVtZVxuICB9XG5cbiAgdGFyZ2V0LmZyYWdtZW50ID0gcmVsYXRpdmUuZnJhZ21lbnRcblxuICByZXR1cm4gdGFyZ2V0XG59XG5cbmZ1bmN0aW9uIGVxdWFsICh1cmlBLCB1cmlCLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgdXJpQSA9PT0gJ3N0cmluZycpIHtcbiAgICB1cmlBID0gdW5lc2NhcGUodXJpQSlcbiAgICB1cmlBID0gc2VyaWFsaXplKG5vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKHBhcnNlKHVyaUEsIG9wdGlvbnMpLCB0cnVlKSwgeyAuLi5vcHRpb25zLCBza2lwRXNjYXBlOiB0cnVlIH0pXG4gIH0gZWxzZSBpZiAodHlwZW9mIHVyaUEgPT09ICdvYmplY3QnKSB7XG4gICAgdXJpQSA9IHNlcmlhbGl6ZShub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyh1cmlBLCB0cnVlKSwgeyAuLi5vcHRpb25zLCBza2lwRXNjYXBlOiB0cnVlIH0pXG4gIH1cblxuICBpZiAodHlwZW9mIHVyaUIgPT09ICdzdHJpbmcnKSB7XG4gICAgdXJpQiA9IHVuZXNjYXBlKHVyaUIpXG4gICAgdXJpQiA9IHNlcmlhbGl6ZShub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhwYXJzZSh1cmlCLCBvcHRpb25zKSwgdHJ1ZSksIHsgLi4ub3B0aW9ucywgc2tpcEVzY2FwZTogdHJ1ZSB9KVxuICB9IGVsc2UgaWYgKHR5cGVvZiB1cmlCID09PSAnb2JqZWN0Jykge1xuICAgIHVyaUIgPSBzZXJpYWxpemUobm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcodXJpQiwgdHJ1ZSksIHsgLi4ub3B0aW9ucywgc2tpcEVzY2FwZTogdHJ1ZSB9KVxuICB9XG5cbiAgcmV0dXJuIHVyaUEudG9Mb3dlckNhc2UoKSA9PT0gdXJpQi50b0xvd2VyQ2FzZSgpXG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZSAoY21wdHMsIG9wdHMpIHtcbiAgY29uc3QgY29tcG9uZW50cyA9IHtcbiAgICBob3N0OiBjbXB0cy5ob3N0LFxuICAgIHNjaGVtZTogY21wdHMuc2NoZW1lLFxuICAgIHVzZXJpbmZvOiBjbXB0cy51c2VyaW5mbyxcbiAgICBwb3J0OiBjbXB0cy5wb3J0LFxuICAgIHBhdGg6IGNtcHRzLnBhdGgsXG4gICAgcXVlcnk6IGNtcHRzLnF1ZXJ5LFxuICAgIG5pZDogY21wdHMubmlkLFxuICAgIG5zczogY21wdHMubnNzLFxuICAgIHV1aWQ6IGNtcHRzLnV1aWQsXG4gICAgZnJhZ21lbnQ6IGNtcHRzLmZyYWdtZW50LFxuICAgIHJlZmVyZW5jZTogY21wdHMucmVmZXJlbmNlLFxuICAgIHJlc291cmNlTmFtZTogY21wdHMucmVzb3VyY2VOYW1lLFxuICAgIHNlY3VyZTogY21wdHMuc2VjdXJlLFxuICAgIGVycm9yOiAnJ1xuICB9XG4gIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRzKVxuICBjb25zdCB1cmlUb2tlbnMgPSBbXVxuXG4gIC8vIGZpbmQgc2NoZW1lIGhhbmRsZXJcbiAgY29uc3Qgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbKG9wdGlvbnMuc2NoZW1lIHx8IGNvbXBvbmVudHMuc2NoZW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpXVxuXG4gIC8vIHBlcmZvcm0gc2NoZW1lIHNwZWNpZmljIHNlcmlhbGl6YXRpb25cbiAgaWYgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5zZXJpYWxpemUpIHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKGNvbXBvbmVudHMsIG9wdGlvbnMpXG5cbiAgaWYgKGNvbXBvbmVudHMucGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKCFvcHRpb25zLnNraXBFc2NhcGUpIHtcbiAgICAgIGNvbXBvbmVudHMucGF0aCA9IGVzY2FwZShjb21wb25lbnRzLnBhdGgpXG5cbiAgICAgIGlmIChjb21wb25lbnRzLnNjaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbXBvbmVudHMucGF0aCA9IGNvbXBvbmVudHMucGF0aC5zcGxpdCgnJTNBJykuam9pbignOicpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBvbmVudHMucGF0aCA9IHVuZXNjYXBlKGNvbXBvbmVudHMucGF0aClcbiAgICB9XG4gIH1cblxuICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgIT09ICdzdWZmaXgnICYmIGNvbXBvbmVudHMuc2NoZW1lKSB7XG4gICAgdXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy5zY2hlbWUsICc6JylcbiAgfVxuXG4gIGNvbnN0IGF1dGhvcml0eSA9IHJlY29tcG9zZUF1dGhvcml0eShjb21wb25lbnRzLCBvcHRpb25zKVxuICBpZiAoYXV0aG9yaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgIT09ICdzdWZmaXgnKSB7XG4gICAgICB1cmlUb2tlbnMucHVzaCgnLy8nKVxuICAgIH1cblxuICAgIHVyaVRva2Vucy5wdXNoKGF1dGhvcml0eSlcblxuICAgIGlmIChjb21wb25lbnRzLnBhdGggJiYgY29tcG9uZW50cy5wYXRoLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgICB1cmlUb2tlbnMucHVzaCgnLycpXG4gICAgfVxuICB9XG4gIGlmIChjb21wb25lbnRzLnBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgIGxldCBzID0gY29tcG9uZW50cy5wYXRoXG5cbiAgICBpZiAoIW9wdGlvbnMuYWJzb2x1dGVQYXRoICYmICghc2NoZW1lSGFuZGxlciB8fCAhc2NoZW1lSGFuZGxlci5hYnNvbHV0ZVBhdGgpKSB7XG4gICAgICBzID0gcmVtb3ZlRG90U2VnbWVudHMocylcbiAgICB9XG5cbiAgICBpZiAoYXV0aG9yaXR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHMgPSBzLnJlcGxhY2UoL15cXC9cXC8vdSwgJy8lMkYnKSAvLyBkb24ndCBhbGxvdyB0aGUgcGF0aCB0byBzdGFydCB3aXRoIFwiLy9cIlxuICAgIH1cblxuICAgIHVyaVRva2Vucy5wdXNoKHMpXG4gIH1cblxuICBpZiAoY29tcG9uZW50cy5xdWVyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdXJpVG9rZW5zLnB1c2goJz8nLCBjb21wb25lbnRzLnF1ZXJ5KVxuICB9XG5cbiAgaWYgKGNvbXBvbmVudHMuZnJhZ21lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgIHVyaVRva2Vucy5wdXNoKCcjJywgY29tcG9uZW50cy5mcmFnbWVudClcbiAgfVxuICByZXR1cm4gdXJpVG9rZW5zLmpvaW4oJycpXG59XG5cbmNvbnN0IGhleExvb2tVcCA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDEyNyB9LCAodiwgaykgPT4gL1teIVwiJCYnKCkqKyxcXC0uOz1fYGEtent9fl0vdS50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoaykpKVxuXG5mdW5jdGlvbiBub25TaW1wbGVEb21haW4gKHZhbHVlKSB7XG4gIGxldCBjb2RlID0gMFxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gdmFsdWUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChpKVxuICAgIGlmIChjb2RlID4gMTI2IHx8IGhleExvb2tVcFtjb2RlXSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmNvbnN0IFVSSV9QQVJTRSA9IC9eKD86KFteIy86P10rKTopPyg/OlxcL1xcLygoPzooW14jLz9AXSopQCk/KFxcW1teIy8/XFxdXStcXF18W14jLzo/XSopKD86OihcXGQqKSk/KSk/KFteIz9dKikoPzpcXD8oW14jXSopKT8oPzojKCg/Oi58W1xcblxccl0pKikpPy91XG5cbmZ1bmN0aW9uIHBhcnNlICh1cmksIG9wdHMpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdHMpXG4gIGNvbnN0IHBhcnNlZCA9IHtcbiAgICBzY2hlbWU6IHVuZGVmaW5lZCxcbiAgICB1c2VyaW5mbzogdW5kZWZpbmVkLFxuICAgIGhvc3Q6ICcnLFxuICAgIHBvcnQ6IHVuZGVmaW5lZCxcbiAgICBwYXRoOiAnJyxcbiAgICBxdWVyeTogdW5kZWZpbmVkLFxuICAgIGZyYWdtZW50OiB1bmRlZmluZWRcbiAgfVxuICBjb25zdCBnb3RFbmNvZGluZyA9IHVyaS5pbmRleE9mKCclJykgIT09IC0xXG4gIGxldCBpc0lQID0gZmFsc2VcbiAgaWYgKG9wdGlvbnMucmVmZXJlbmNlID09PSAnc3VmZml4JykgdXJpID0gKG9wdGlvbnMuc2NoZW1lID8gb3B0aW9ucy5zY2hlbWUgKyAnOicgOiAnJykgKyAnLy8nICsgdXJpXG5cbiAgY29uc3QgbWF0Y2hlcyA9IHVyaS5tYXRjaChVUklfUEFSU0UpXG5cbiAgaWYgKG1hdGNoZXMpIHtcbiAgICAvLyBzdG9yZSBlYWNoIGNvbXBvbmVudFxuICAgIHBhcnNlZC5zY2hlbWUgPSBtYXRjaGVzWzFdXG4gICAgcGFyc2VkLnVzZXJpbmZvID0gbWF0Y2hlc1szXVxuICAgIHBhcnNlZC5ob3N0ID0gbWF0Y2hlc1s0XVxuICAgIHBhcnNlZC5wb3J0ID0gcGFyc2VJbnQobWF0Y2hlc1s1XSwgMTApXG4gICAgcGFyc2VkLnBhdGggPSBtYXRjaGVzWzZdIHx8ICcnXG4gICAgcGFyc2VkLnF1ZXJ5ID0gbWF0Y2hlc1s3XVxuICAgIHBhcnNlZC5mcmFnbWVudCA9IG1hdGNoZXNbOF1cblxuICAgIC8vIGZpeCBwb3J0IG51bWJlclxuICAgIGlmIChpc05hTihwYXJzZWQucG9ydCkpIHtcbiAgICAgIHBhcnNlZC5wb3J0ID0gbWF0Y2hlc1s1XVxuICAgIH1cbiAgICBpZiAocGFyc2VkLmhvc3QpIHtcbiAgICAgIGNvbnN0IGlwdjRyZXN1bHQgPSBub3JtYWxpemVJUHY0KHBhcnNlZC5ob3N0KVxuICAgICAgaWYgKGlwdjRyZXN1bHQuaXNJUFY0ID09PSBmYWxzZSkge1xuICAgICAgICBjb25zdCBpcHY2cmVzdWx0ID0gbm9ybWFsaXplSVB2NihpcHY0cmVzdWx0Lmhvc3QsIHsgaXNJUFY0OiBmYWxzZSB9KVxuICAgICAgICBwYXJzZWQuaG9zdCA9IGlwdjZyZXN1bHQuaG9zdC50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGlzSVAgPSBpcHY2cmVzdWx0LmlzSVBWNlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkLmhvc3QgPSBpcHY0cmVzdWx0Lmhvc3RcbiAgICAgICAgaXNJUCA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhcnNlZC5zY2hlbWUgPT09IHVuZGVmaW5lZCAmJiBwYXJzZWQudXNlcmluZm8gPT09IHVuZGVmaW5lZCAmJiBwYXJzZWQuaG9zdCA9PT0gdW5kZWZpbmVkICYmIHBhcnNlZC5wb3J0ID09PSB1bmRlZmluZWQgJiYgIXBhcnNlZC5wYXRoICYmIHBhcnNlZC5xdWVyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJzZWQucmVmZXJlbmNlID0gJ3NhbWUtZG9jdW1lbnQnXG4gICAgfSBlbHNlIGlmIChwYXJzZWQuc2NoZW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHBhcnNlZC5yZWZlcmVuY2UgPSAncmVsYXRpdmUnXG4gICAgfSBlbHNlIGlmIChwYXJzZWQuZnJhZ21lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcGFyc2VkLnJlZmVyZW5jZSA9ICdhYnNvbHV0ZSdcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2VkLnJlZmVyZW5jZSA9ICd1cmknXG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZm9yIHJlZmVyZW5jZSBlcnJvcnNcbiAgICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgJiYgb3B0aW9ucy5yZWZlcmVuY2UgIT09ICdzdWZmaXgnICYmIG9wdGlvbnMucmVmZXJlbmNlICE9PSBwYXJzZWQucmVmZXJlbmNlKSB7XG4gICAgICBwYXJzZWQuZXJyb3IgPSBwYXJzZWQuZXJyb3IgfHwgJ1VSSSBpcyBub3QgYSAnICsgb3B0aW9ucy5yZWZlcmVuY2UgKyAnIHJlZmVyZW5jZS4nXG4gICAgfVxuXG4gICAgLy8gZmluZCBzY2hlbWUgaGFuZGxlclxuICAgIGNvbnN0IHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTWyhvcHRpb25zLnNjaGVtZSB8fCBwYXJzZWQuc2NoZW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpXVxuXG4gICAgLy8gY2hlY2sgaWYgc2NoZW1lIGNhbid0IGhhbmRsZSBJUklzXG4gICAgaWYgKCFvcHRpb25zLnVuaWNvZGVTdXBwb3J0ICYmICghc2NoZW1lSGFuZGxlciB8fCAhc2NoZW1lSGFuZGxlci51bmljb2RlU3VwcG9ydCkpIHtcbiAgICAgIC8vIGlmIGhvc3QgY29tcG9uZW50IGlzIGEgZG9tYWluIG5hbWVcbiAgICAgIGlmIChwYXJzZWQuaG9zdCAmJiAob3B0aW9ucy5kb21haW5Ib3N0IHx8IChzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIuZG9tYWluSG9zdCkpICYmIGlzSVAgPT09IGZhbHNlICYmIG5vblNpbXBsZURvbWFpbihwYXJzZWQuaG9zdCkpIHtcbiAgICAgICAgLy8gY29udmVydCBVbmljb2RlIElETiAtPiBBU0NJSSBJRE5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwYXJzZWQuaG9zdCA9IFVSTC5kb21haW5Ub0FTQ0lJKHBhcnNlZC5ob3N0LnRvTG93ZXJDYXNlKCkpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBwYXJzZWQuZXJyb3IgPSBwYXJzZWQuZXJyb3IgfHwgXCJIb3N0J3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gQVNDSUk6IFwiICsgZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBjb252ZXJ0IElSSSAtPiBVUklcbiAgICB9XG5cbiAgICBpZiAoIXNjaGVtZUhhbmRsZXIgfHwgKHNjaGVtZUhhbmRsZXIgJiYgIXNjaGVtZUhhbmRsZXIuc2tpcE5vcm1hbGl6ZSkpIHtcbiAgICAgIGlmIChnb3RFbmNvZGluZyAmJiBwYXJzZWQuc2NoZW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGFyc2VkLnNjaGVtZSA9IHVuZXNjYXBlKHBhcnNlZC5zY2hlbWUpXG4gICAgICB9XG4gICAgICBpZiAoZ290RW5jb2RpbmcgJiYgcGFyc2VkLmhvc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXJzZWQuaG9zdCA9IHVuZXNjYXBlKHBhcnNlZC5ob3N0KVxuICAgICAgfVxuICAgICAgaWYgKHBhcnNlZC5wYXRoICE9PSB1bmRlZmluZWQgJiYgcGFyc2VkLnBhdGgubGVuZ3RoKSB7XG4gICAgICAgIHBhcnNlZC5wYXRoID0gZXNjYXBlKHVuZXNjYXBlKHBhcnNlZC5wYXRoKSlcbiAgICAgIH1cbiAgICAgIGlmIChwYXJzZWQuZnJhZ21lbnQgIT09IHVuZGVmaW5lZCAmJiBwYXJzZWQuZnJhZ21lbnQubGVuZ3RoKSB7XG4gICAgICAgIHBhcnNlZC5mcmFnbWVudCA9IGVuY29kZVVSSShkZWNvZGVVUklDb21wb25lbnQocGFyc2VkLmZyYWdtZW50KSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwZXJmb3JtIHNjaGVtZSBzcGVjaWZpYyBwYXJzaW5nXG4gICAgaWYgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5wYXJzZSkge1xuICAgICAgc2NoZW1lSGFuZGxlci5wYXJzZShwYXJzZWQsIG9wdGlvbnMpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhcnNlZC5lcnJvciA9IHBhcnNlZC5lcnJvciB8fCAnVVJJIGNhbiBub3QgYmUgcGFyc2VkLidcbiAgfVxuICByZXR1cm4gcGFyc2VkXG59XG5cbmNvbnN0IGZhc3RVcmkgPSB7XG4gIFNDSEVNRVMsXG4gIG5vcm1hbGl6ZSxcbiAgcmVzb2x2ZSxcbiAgcmVzb2x2ZUNvbXBvbmVudHMsXG4gIGVxdWFsLFxuICBzZXJpYWxpemUsXG4gIHBhcnNlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmFzdFVyaVxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGZhc3RVcmlcbm1vZHVsZS5leHBvcnRzLmZhc3RVcmkgPSBmYXN0VXJpXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/schemes.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/schemes.js ***!
  \********************************************************************************/
/***/ ((module) => {

eval("\n\nconst UUID_REG = /^[\\da-f]{8}\\b-[\\da-f]{4}\\b-[\\da-f]{4}\\b-[\\da-f]{4}\\b-[\\da-f]{12}$/iu\nconst URN_REG = /([\\da-z][\\d\\-a-z]{0,31}):((?:[\\w!$'()*+,\\-.:;=@]|%[\\da-f]{2})+)/iu\n\nfunction isSecure (wsComponents) {\n  return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === 'wss'\n}\n\nfunction httpParse (components) {\n  if (!components.host) {\n    components.error = components.error || 'HTTP URIs must have a host.'\n  }\n\n  return components\n}\n\nfunction httpSerialize (components) {\n  const secure = String(components.scheme).toLowerCase() === 'https'\n\n  // normalize the default port\n  if (components.port === (secure ? 443 : 80) || components.port === '') {\n    components.port = undefined\n  }\n\n  // normalize the empty path\n  if (!components.path) {\n    components.path = '/'\n  }\n\n  // NOTE: We do not parse query strings for HTTP URIs\n  // as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n  // and not the HTTP spec.\n\n  return components\n}\n\nfunction wsParse (wsComponents) {\n// indicate if the secure flag is set\n  wsComponents.secure = isSecure(wsComponents)\n\n  // construct resouce name\n  wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '')\n  wsComponents.path = undefined\n  wsComponents.query = undefined\n\n  return wsComponents\n}\n\nfunction wsSerialize (wsComponents) {\n// normalize the default port\n  if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === '') {\n    wsComponents.port = undefined\n  }\n\n  // ensure scheme matches secure flag\n  if (typeof wsComponents.secure === 'boolean') {\n    wsComponents.scheme = (wsComponents.secure ? 'wss' : 'ws')\n    wsComponents.secure = undefined\n  }\n\n  // reconstruct path from resource name\n  if (wsComponents.resourceName) {\n    const [path, query] = wsComponents.resourceName.split('?')\n    wsComponents.path = (path && path !== '/' ? path : undefined)\n    wsComponents.query = query\n    wsComponents.resourceName = undefined\n  }\n\n  // forbid fragment component\n  wsComponents.fragment = undefined\n\n  return wsComponents\n}\n\nfunction urnParse (urnComponents, options) {\n  if (!urnComponents.path) {\n    urnComponents.error = 'URN can not be parsed'\n    return urnComponents\n  }\n  const matches = urnComponents.path.match(URN_REG)\n  if (matches) {\n    const scheme = options.scheme || urnComponents.scheme || 'urn'\n    urnComponents.nid = matches[1].toLowerCase()\n    urnComponents.nss = matches[2]\n    const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`\n    const schemeHandler = SCHEMES[urnScheme]\n    urnComponents.path = undefined\n\n    if (schemeHandler) {\n      urnComponents = schemeHandler.parse(urnComponents, options)\n    }\n  } else {\n    urnComponents.error = urnComponents.error || 'URN can not be parsed.'\n  }\n\n  return urnComponents\n}\n\nfunction urnSerialize (urnComponents, options) {\n  const scheme = options.scheme || urnComponents.scheme || 'urn'\n  const nid = urnComponents.nid.toLowerCase()\n  const urnScheme = `${scheme}:${options.nid || nid}`\n  const schemeHandler = SCHEMES[urnScheme]\n\n  if (schemeHandler) {\n    urnComponents = schemeHandler.serialize(urnComponents, options)\n  }\n\n  const uriComponents = urnComponents\n  const nss = urnComponents.nss\n  uriComponents.path = `${nid || options.nid}:${nss}`\n\n  options.skipEscape = true\n  return uriComponents\n}\n\nfunction urnuuidParse (urnComponents, options) {\n  const uuidComponents = urnComponents\n  uuidComponents.uuid = uuidComponents.nss\n  uuidComponents.nss = undefined\n\n  if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {\n    uuidComponents.error = uuidComponents.error || 'UUID is not valid.'\n  }\n\n  return uuidComponents\n}\n\nfunction urnuuidSerialize (uuidComponents) {\n  const urnComponents = uuidComponents\n  // normalize UUID\n  urnComponents.nss = (uuidComponents.uuid || '').toLowerCase()\n  return urnComponents\n}\n\nconst http = {\n  scheme: 'http',\n  domainHost: true,\n  parse: httpParse,\n  serialize: httpSerialize\n}\n\nconst https = {\n  scheme: 'https',\n  domainHost: http.domainHost,\n  parse: httpParse,\n  serialize: httpSerialize\n}\n\nconst ws = {\n  scheme: 'ws',\n  domainHost: true,\n  parse: wsParse,\n  serialize: wsSerialize\n}\n\nconst wss = {\n  scheme: 'wss',\n  domainHost: ws.domainHost,\n  parse: ws.parse,\n  serialize: ws.serialize\n}\n\nconst urn = {\n  scheme: 'urn',\n  parse: urnParse,\n  serialize: urnSerialize,\n  skipNormalize: true\n}\n\nconst urnuuid = {\n  scheme: 'urn:uuid',\n  parse: urnuuidParse,\n  serialize: urnuuidSerialize,\n  skipNormalize: true\n}\n\nconst SCHEMES = {\n  http,\n  https,\n  ws,\n  wss,\n  urn,\n  'urn:uuid': urnuuid\n}\n\nmodule.exports = SCHEMES\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vZmFzdC11cmlAMy4wLjMvbm9kZV9tb2R1bGVzL2Zhc3QtdXJpL2xpYi9zY2hlbWVzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLDJCQUEyQixFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUUsV0FBVyxFQUFFLFdBQVcsR0FBRztBQUNsRixtQ0FBbUMsS0FBSyxzQkFBc0IsYUFBYSxFQUFFOztBQUU3RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTyxHQUFHLGlDQUFpQztBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU8sR0FBRyxtQkFBbUI7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsbUJBQW1CLEdBQUcsSUFBSTs7QUFFcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMva2FyZWxsZS92c2Nwcm9qZWN0cy90ZWNoLWZsZWV0L3RhaW5vLWxhbmd1YWdlLWFwcC9sZXNzb24tYXV0aG9yaW5nL25vZGVfbW9kdWxlcy8ucG5wbS9mYXN0LXVyaUAzLjAuMy9ub2RlX21vZHVsZXMvZmFzdC11cmkvbGliL3NjaGVtZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFVVSURfUkVHID0gL15bXFxkYS1mXXs4fVxcYi1bXFxkYS1mXXs0fVxcYi1bXFxkYS1mXXs0fVxcYi1bXFxkYS1mXXs0fVxcYi1bXFxkYS1mXXsxMn0kL2l1XG5jb25zdCBVUk5fUkVHID0gLyhbXFxkYS16XVtcXGRcXC1hLXpdezAsMzF9KTooKD86W1xcdyEkJygpKissXFwtLjo7PUBdfCVbXFxkYS1mXXsyfSkrKS9pdVxuXG5mdW5jdGlvbiBpc1NlY3VyZSAod3NDb21wb25lbnRzKSB7XG4gIHJldHVybiB0eXBlb2Ygd3NDb21wb25lbnRzLnNlY3VyZSA9PT0gJ2Jvb2xlYW4nID8gd3NDb21wb25lbnRzLnNlY3VyZSA6IFN0cmluZyh3c0NvbXBvbmVudHMuc2NoZW1lKS50b0xvd2VyQ2FzZSgpID09PSAnd3NzJ1xufVxuXG5mdW5jdGlvbiBodHRwUGFyc2UgKGNvbXBvbmVudHMpIHtcbiAgaWYgKCFjb21wb25lbnRzLmhvc3QpIHtcbiAgICBjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCAnSFRUUCBVUklzIG11c3QgaGF2ZSBhIGhvc3QuJ1xuICB9XG5cbiAgcmV0dXJuIGNvbXBvbmVudHNcbn1cblxuZnVuY3Rpb24gaHR0cFNlcmlhbGl6ZSAoY29tcG9uZW50cykge1xuICBjb25zdCBzZWN1cmUgPSBTdHJpbmcoY29tcG9uZW50cy5zY2hlbWUpLnRvTG93ZXJDYXNlKCkgPT09ICdodHRwcydcblxuICAvLyBub3JtYWxpemUgdGhlIGRlZmF1bHQgcG9ydFxuICBpZiAoY29tcG9uZW50cy5wb3J0ID09PSAoc2VjdXJlID8gNDQzIDogODApIHx8IGNvbXBvbmVudHMucG9ydCA9PT0gJycpIHtcbiAgICBjb21wb25lbnRzLnBvcnQgPSB1bmRlZmluZWRcbiAgfVxuXG4gIC8vIG5vcm1hbGl6ZSB0aGUgZW1wdHkgcGF0aFxuICBpZiAoIWNvbXBvbmVudHMucGF0aCkge1xuICAgIGNvbXBvbmVudHMucGF0aCA9ICcvJ1xuICB9XG5cbiAgLy8gTk9URTogV2UgZG8gbm90IHBhcnNlIHF1ZXJ5IHN0cmluZ3MgZm9yIEhUVFAgVVJJc1xuICAvLyBhcyBXV1cgRm9ybSBVcmwgRW5jb2RlZCBxdWVyeSBzdHJpbmdzIGFyZSBwYXJ0IG9mIHRoZSBIVE1MNCsgc3BlYyxcbiAgLy8gYW5kIG5vdCB0aGUgSFRUUCBzcGVjLlxuXG4gIHJldHVybiBjb21wb25lbnRzXG59XG5cbmZ1bmN0aW9uIHdzUGFyc2UgKHdzQ29tcG9uZW50cykge1xuLy8gaW5kaWNhdGUgaWYgdGhlIHNlY3VyZSBmbGFnIGlzIHNldFxuICB3c0NvbXBvbmVudHMuc2VjdXJlID0gaXNTZWN1cmUod3NDb21wb25lbnRzKVxuXG4gIC8vIGNvbnN0cnVjdCByZXNvdWNlIG5hbWVcbiAgd3NDb21wb25lbnRzLnJlc291cmNlTmFtZSA9ICh3c0NvbXBvbmVudHMucGF0aCB8fCAnLycpICsgKHdzQ29tcG9uZW50cy5xdWVyeSA/ICc/JyArIHdzQ29tcG9uZW50cy5xdWVyeSA6ICcnKVxuICB3c0NvbXBvbmVudHMucGF0aCA9IHVuZGVmaW5lZFxuICB3c0NvbXBvbmVudHMucXVlcnkgPSB1bmRlZmluZWRcblxuICByZXR1cm4gd3NDb21wb25lbnRzXG59XG5cbmZ1bmN0aW9uIHdzU2VyaWFsaXplICh3c0NvbXBvbmVudHMpIHtcbi8vIG5vcm1hbGl6ZSB0aGUgZGVmYXVsdCBwb3J0XG4gIGlmICh3c0NvbXBvbmVudHMucG9ydCA9PT0gKGlzU2VjdXJlKHdzQ29tcG9uZW50cykgPyA0NDMgOiA4MCkgfHwgd3NDb21wb25lbnRzLnBvcnQgPT09ICcnKSB7XG4gICAgd3NDb21wb25lbnRzLnBvcnQgPSB1bmRlZmluZWRcbiAgfVxuXG4gIC8vIGVuc3VyZSBzY2hlbWUgbWF0Y2hlcyBzZWN1cmUgZmxhZ1xuICBpZiAodHlwZW9mIHdzQ29tcG9uZW50cy5zZWN1cmUgPT09ICdib29sZWFuJykge1xuICAgIHdzQ29tcG9uZW50cy5zY2hlbWUgPSAod3NDb21wb25lbnRzLnNlY3VyZSA/ICd3c3MnIDogJ3dzJylcbiAgICB3c0NvbXBvbmVudHMuc2VjdXJlID0gdW5kZWZpbmVkXG4gIH1cblxuICAvLyByZWNvbnN0cnVjdCBwYXRoIGZyb20gcmVzb3VyY2UgbmFtZVxuICBpZiAod3NDb21wb25lbnRzLnJlc291cmNlTmFtZSkge1xuICAgIGNvbnN0IFtwYXRoLCBxdWVyeV0gPSB3c0NvbXBvbmVudHMucmVzb3VyY2VOYW1lLnNwbGl0KCc/JylcbiAgICB3c0NvbXBvbmVudHMucGF0aCA9IChwYXRoICYmIHBhdGggIT09ICcvJyA/IHBhdGggOiB1bmRlZmluZWQpXG4gICAgd3NDb21wb25lbnRzLnF1ZXJ5ID0gcXVlcnlcbiAgICB3c0NvbXBvbmVudHMucmVzb3VyY2VOYW1lID0gdW5kZWZpbmVkXG4gIH1cblxuICAvLyBmb3JiaWQgZnJhZ21lbnQgY29tcG9uZW50XG4gIHdzQ29tcG9uZW50cy5mcmFnbWVudCA9IHVuZGVmaW5lZFxuXG4gIHJldHVybiB3c0NvbXBvbmVudHNcbn1cblxuZnVuY3Rpb24gdXJuUGFyc2UgKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgaWYgKCF1cm5Db21wb25lbnRzLnBhdGgpIHtcbiAgICB1cm5Db21wb25lbnRzLmVycm9yID0gJ1VSTiBjYW4gbm90IGJlIHBhcnNlZCdcbiAgICByZXR1cm4gdXJuQ29tcG9uZW50c1xuICB9XG4gIGNvbnN0IG1hdGNoZXMgPSB1cm5Db21wb25lbnRzLnBhdGgubWF0Y2goVVJOX1JFRylcbiAgaWYgKG1hdGNoZXMpIHtcbiAgICBjb25zdCBzY2hlbWUgPSBvcHRpb25zLnNjaGVtZSB8fCB1cm5Db21wb25lbnRzLnNjaGVtZSB8fCAndXJuJ1xuICAgIHVybkNvbXBvbmVudHMubmlkID0gbWF0Y2hlc1sxXS50b0xvd2VyQ2FzZSgpXG4gICAgdXJuQ29tcG9uZW50cy5uc3MgPSBtYXRjaGVzWzJdXG4gICAgY29uc3QgdXJuU2NoZW1lID0gYCR7c2NoZW1lfToke29wdGlvbnMubmlkIHx8IHVybkNvbXBvbmVudHMubmlkfWBcbiAgICBjb25zdCBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1t1cm5TY2hlbWVdXG4gICAgdXJuQ29tcG9uZW50cy5wYXRoID0gdW5kZWZpbmVkXG5cbiAgICBpZiAoc2NoZW1lSGFuZGxlcikge1xuICAgICAgdXJuQ29tcG9uZW50cyA9IHNjaGVtZUhhbmRsZXIucGFyc2UodXJuQ29tcG9uZW50cywgb3B0aW9ucylcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdXJuQ29tcG9uZW50cy5lcnJvciA9IHVybkNvbXBvbmVudHMuZXJyb3IgfHwgJ1VSTiBjYW4gbm90IGJlIHBhcnNlZC4nXG4gIH1cblxuICByZXR1cm4gdXJuQ29tcG9uZW50c1xufVxuXG5mdW5jdGlvbiB1cm5TZXJpYWxpemUgKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc2NoZW1lID0gb3B0aW9ucy5zY2hlbWUgfHwgdXJuQ29tcG9uZW50cy5zY2hlbWUgfHwgJ3VybidcbiAgY29uc3QgbmlkID0gdXJuQ29tcG9uZW50cy5uaWQudG9Mb3dlckNhc2UoKVxuICBjb25zdCB1cm5TY2hlbWUgPSBgJHtzY2hlbWV9OiR7b3B0aW9ucy5uaWQgfHwgbmlkfWBcbiAgY29uc3Qgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbdXJuU2NoZW1lXVxuXG4gIGlmIChzY2hlbWVIYW5kbGVyKSB7XG4gICAgdXJuQ29tcG9uZW50cyA9IHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpXG4gIH1cblxuICBjb25zdCB1cmlDb21wb25lbnRzID0gdXJuQ29tcG9uZW50c1xuICBjb25zdCBuc3MgPSB1cm5Db21wb25lbnRzLm5zc1xuICB1cmlDb21wb25lbnRzLnBhdGggPSBgJHtuaWQgfHwgb3B0aW9ucy5uaWR9OiR7bnNzfWBcblxuICBvcHRpb25zLnNraXBFc2NhcGUgPSB0cnVlXG4gIHJldHVybiB1cmlDb21wb25lbnRzXG59XG5cbmZ1bmN0aW9uIHVybnV1aWRQYXJzZSAodXJuQ29tcG9uZW50cywgb3B0aW9ucykge1xuICBjb25zdCB1dWlkQ29tcG9uZW50cyA9IHVybkNvbXBvbmVudHNcbiAgdXVpZENvbXBvbmVudHMudXVpZCA9IHV1aWRDb21wb25lbnRzLm5zc1xuICB1dWlkQ29tcG9uZW50cy5uc3MgPSB1bmRlZmluZWRcblxuICBpZiAoIW9wdGlvbnMudG9sZXJhbnQgJiYgKCF1dWlkQ29tcG9uZW50cy51dWlkIHx8ICFVVUlEX1JFRy50ZXN0KHV1aWRDb21wb25lbnRzLnV1aWQpKSkge1xuICAgIHV1aWRDb21wb25lbnRzLmVycm9yID0gdXVpZENvbXBvbmVudHMuZXJyb3IgfHwgJ1VVSUQgaXMgbm90IHZhbGlkLidcbiAgfVxuXG4gIHJldHVybiB1dWlkQ29tcG9uZW50c1xufVxuXG5mdW5jdGlvbiB1cm51dWlkU2VyaWFsaXplICh1dWlkQ29tcG9uZW50cykge1xuICBjb25zdCB1cm5Db21wb25lbnRzID0gdXVpZENvbXBvbmVudHNcbiAgLy8gbm9ybWFsaXplIFVVSURcbiAgdXJuQ29tcG9uZW50cy5uc3MgPSAodXVpZENvbXBvbmVudHMudXVpZCB8fCAnJykudG9Mb3dlckNhc2UoKVxuICByZXR1cm4gdXJuQ29tcG9uZW50c1xufVxuXG5jb25zdCBodHRwID0ge1xuICBzY2hlbWU6ICdodHRwJyxcbiAgZG9tYWluSG9zdDogdHJ1ZSxcbiAgcGFyc2U6IGh0dHBQYXJzZSxcbiAgc2VyaWFsaXplOiBodHRwU2VyaWFsaXplXG59XG5cbmNvbnN0IGh0dHBzID0ge1xuICBzY2hlbWU6ICdodHRwcycsXG4gIGRvbWFpbkhvc3Q6IGh0dHAuZG9tYWluSG9zdCxcbiAgcGFyc2U6IGh0dHBQYXJzZSxcbiAgc2VyaWFsaXplOiBodHRwU2VyaWFsaXplXG59XG5cbmNvbnN0IHdzID0ge1xuICBzY2hlbWU6ICd3cycsXG4gIGRvbWFpbkhvc3Q6IHRydWUsXG4gIHBhcnNlOiB3c1BhcnNlLFxuICBzZXJpYWxpemU6IHdzU2VyaWFsaXplXG59XG5cbmNvbnN0IHdzcyA9IHtcbiAgc2NoZW1lOiAnd3NzJyxcbiAgZG9tYWluSG9zdDogd3MuZG9tYWluSG9zdCxcbiAgcGFyc2U6IHdzLnBhcnNlLFxuICBzZXJpYWxpemU6IHdzLnNlcmlhbGl6ZVxufVxuXG5jb25zdCB1cm4gPSB7XG4gIHNjaGVtZTogJ3VybicsXG4gIHBhcnNlOiB1cm5QYXJzZSxcbiAgc2VyaWFsaXplOiB1cm5TZXJpYWxpemUsXG4gIHNraXBOb3JtYWxpemU6IHRydWVcbn1cblxuY29uc3QgdXJudXVpZCA9IHtcbiAgc2NoZW1lOiAndXJuOnV1aWQnLFxuICBwYXJzZTogdXJudXVpZFBhcnNlLFxuICBzZXJpYWxpemU6IHVybnV1aWRTZXJpYWxpemUsXG4gIHNraXBOb3JtYWxpemU6IHRydWVcbn1cblxuY29uc3QgU0NIRU1FUyA9IHtcbiAgaHR0cCxcbiAgaHR0cHMsXG4gIHdzLFxuICB3c3MsXG4gIHVybixcbiAgJ3Vybjp1dWlkJzogdXJudXVpZFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNDSEVNRVNcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/schemes.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/scopedChars.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/scopedChars.js ***!
  \************************************************************************************/
/***/ ((module) => {

eval("\n\nconst HEX = {\n  0: 0,\n  1: 1,\n  2: 2,\n  3: 3,\n  4: 4,\n  5: 5,\n  6: 6,\n  7: 7,\n  8: 8,\n  9: 9,\n  a: 10,\n  A: 10,\n  b: 11,\n  B: 11,\n  c: 12,\n  C: 12,\n  d: 13,\n  D: 13,\n  e: 14,\n  E: 14,\n  f: 15,\n  F: 15\n}\n\nmodule.exports = {\n  HEX\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vZmFzdC11cmlAMy4wLjMvbm9kZV9tb2R1bGVzL2Zhc3QtdXJpL2xpYi9zY29wZWRDaGFycy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMva2FyZWxsZS92c2Nwcm9qZWN0cy90ZWNoLWZsZWV0L3RhaW5vLWxhbmd1YWdlLWFwcC9sZXNzb24tYXV0aG9yaW5nL25vZGVfbW9kdWxlcy8ucG5wbS9mYXN0LXVyaUAzLjAuMy9ub2RlX21vZHVsZXMvZmFzdC11cmkvbGliL3Njb3BlZENoYXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBIRVggPSB7XG4gIDA6IDAsXG4gIDE6IDEsXG4gIDI6IDIsXG4gIDM6IDMsXG4gIDQ6IDQsXG4gIDU6IDUsXG4gIDY6IDYsXG4gIDc6IDcsXG4gIDg6IDgsXG4gIDk6IDksXG4gIGE6IDEwLFxuICBBOiAxMCxcbiAgYjogMTEsXG4gIEI6IDExLFxuICBjOiAxMixcbiAgQzogMTIsXG4gIGQ6IDEzLFxuICBEOiAxMyxcbiAgZTogMTQsXG4gIEU6IDE0LFxuICBmOiAxNSxcbiAgRjogMTVcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEhFWFxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/scopedChars.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/utils.js":
/*!******************************************************************************!*\
  !*** ./node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/utils.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { HEX } = __webpack_require__(/*! ./scopedChars */ \"(rsc)/./node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/scopedChars.js\")\n\nfunction normalizeIPv4 (host) {\n  if (findToken(host, '.') < 3) { return { host, isIPV4: false } }\n  const matches = host.match(/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/u) || []\n  const [address] = matches\n  if (address) {\n    return { host: stripLeadingZeros(address, '.'), isIPV4: true }\n  } else {\n    return { host, isIPV4: false }\n  }\n}\n\n/**\n * @param {string[]} input\n * @param {boolean} [keepZero=false]\n * @returns {string|undefined}\n */\nfunction stringArrayToHexStripped (input, keepZero = false) {\n  let acc = ''\n  let strip = true\n  for (const c of input) {\n    if (HEX[c] === undefined) return undefined\n    if (c !== '0' && strip === true) strip = false\n    if (!strip) acc += c\n  }\n  if (keepZero && acc.length === 0) acc = '0'\n  return acc\n}\n\nfunction getIPV6 (input) {\n  let tokenCount = 0\n  const output = { error: false, address: '', zone: '' }\n  const address = []\n  const buffer = []\n  let isZone = false\n  let endipv6Encountered = false\n  let endIpv6 = false\n\n  function consume () {\n    if (buffer.length) {\n      if (isZone === false) {\n        const hex = stringArrayToHexStripped(buffer)\n        if (hex !== undefined) {\n          address.push(hex)\n        } else {\n          output.error = true\n          return false\n        }\n      }\n      buffer.length = 0\n    }\n    return true\n  }\n\n  for (let i = 0; i < input.length; i++) {\n    const cursor = input[i]\n    if (cursor === '[' || cursor === ']') { continue }\n    if (cursor === ':') {\n      if (endipv6Encountered === true) {\n        endIpv6 = true\n      }\n      if (!consume()) { break }\n      tokenCount++\n      address.push(':')\n      if (tokenCount > 7) {\n        // not valid\n        output.error = true\n        break\n      }\n      if (i - 1 >= 0 && input[i - 1] === ':') {\n        endipv6Encountered = true\n      }\n      continue\n    } else if (cursor === '%') {\n      if (!consume()) { break }\n      // switch to zone detection\n      isZone = true\n    } else {\n      buffer.push(cursor)\n      continue\n    }\n  }\n  if (buffer.length) {\n    if (isZone) {\n      output.zone = buffer.join('')\n    } else if (endIpv6) {\n      address.push(buffer.join(''))\n    } else {\n      address.push(stringArrayToHexStripped(buffer))\n    }\n  }\n  output.address = address.join('')\n  return output\n}\n\nfunction normalizeIPv6 (host, opts = {}) {\n  if (findToken(host, ':') < 2) { return { host, isIPV6: false } }\n  const ipv6 = getIPV6(host)\n\n  if (!ipv6.error) {\n    let newHost = ipv6.address\n    let escapedHost = ipv6.address\n    if (ipv6.zone) {\n      newHost += '%' + ipv6.zone\n      escapedHost += '%25' + ipv6.zone\n    }\n    return { host: newHost, escapedHost, isIPV6: true }\n  } else {\n    return { host, isIPV6: false }\n  }\n}\n\nfunction stripLeadingZeros (str, token) {\n  let out = ''\n  let skip = true\n  const l = str.length\n  for (let i = 0; i < l; i++) {\n    const c = str[i]\n    if (c === '0' && skip) {\n      if ((i + 1 <= l && str[i + 1] === token) || i + 1 === l) {\n        out += c\n        skip = false\n      }\n    } else {\n      if (c === token) {\n        skip = true\n      } else {\n        skip = false\n      }\n      out += c\n    }\n  }\n  return out\n}\n\nfunction findToken (str, token) {\n  let ind = 0\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === token) ind++\n  }\n  return ind\n}\n\nconst RDS1 = /^\\.\\.?\\//u\nconst RDS2 = /^\\/\\.(?:\\/|$)/u\nconst RDS3 = /^\\/\\.\\.(?:\\/|$)/u\nconst RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/u\n\nfunction removeDotSegments (input) {\n  const output = []\n\n  while (input.length) {\n    if (input.match(RDS1)) {\n      input = input.replace(RDS1, '')\n    } else if (input.match(RDS2)) {\n      input = input.replace(RDS2, '/')\n    } else if (input.match(RDS3)) {\n      input = input.replace(RDS3, '/')\n      output.pop()\n    } else if (input === '.' || input === '..') {\n      input = ''\n    } else {\n      const im = input.match(RDS5)\n      if (im) {\n        const s = im[0]\n        input = input.slice(s.length)\n        output.push(s)\n      } else {\n        throw new Error('Unexpected dot segment condition')\n      }\n    }\n  }\n  return output.join('')\n}\n\nfunction normalizeComponentEncoding (components, esc) {\n  const func = esc !== true ? escape : unescape\n  if (components.scheme !== undefined) {\n    components.scheme = func(components.scheme)\n  }\n  if (components.userinfo !== undefined) {\n    components.userinfo = func(components.userinfo)\n  }\n  if (components.host !== undefined) {\n    components.host = func(components.host)\n  }\n  if (components.path !== undefined) {\n    components.path = func(components.path)\n  }\n  if (components.query !== undefined) {\n    components.query = func(components.query)\n  }\n  if (components.fragment !== undefined) {\n    components.fragment = func(components.fragment)\n  }\n  return components\n}\n\nfunction recomposeAuthority (components, options) {\n  const uriTokens = []\n\n  if (components.userinfo !== undefined) {\n    uriTokens.push(components.userinfo)\n    uriTokens.push('@')\n  }\n\n  if (components.host !== undefined) {\n    let host = unescape(components.host)\n    const ipV4res = normalizeIPv4(host)\n\n    if (ipV4res.isIPV4) {\n      host = ipV4res.host\n    } else {\n      const ipV6res = normalizeIPv6(ipV4res.host, { isIPV4: false })\n      if (ipV6res.isIPV6 === true) {\n        host = `[${ipV6res.escapedHost}]`\n      } else {\n        host = components.host\n      }\n    }\n    uriTokens.push(host)\n  }\n\n  if (typeof components.port === 'number' || typeof components.port === 'string') {\n    uriTokens.push(':')\n    uriTokens.push(String(components.port))\n  }\n\n  return uriTokens.length ? uriTokens.join('') : undefined\n};\n\nmodule.exports = {\n  recomposeAuthority,\n  normalizeComponentEncoding,\n  removeDotSegments,\n  normalizeIPv4,\n  normalizeIPv6,\n  stringArrayToHexStripped\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vZmFzdC11cmlAMy4wLjMvbm9kZV9tb2R1bGVzL2Zhc3QtdXJpL2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLE1BQU0sRUFBRSxtQkFBTyxDQUFDLHlHQUFlOztBQUV2QztBQUNBLGtDQUFrQyxTQUFTO0FBQzNDLDBGQUEwRixFQUFFO0FBQzVGO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsSUFBSTtBQUNKLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QztBQUN2QyxrQ0FBa0MsU0FBUztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixJQUFJO0FBQ0osYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sb0RBQW9ELGVBQWU7QUFDbkU7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2thcmVsbGUvdnNjcHJvamVjdHMvdGVjaC1mbGVldC90YWluby1sYW5ndWFnZS1hcHAvbGVzc29uLWF1dGhvcmluZy9ub2RlX21vZHVsZXMvLnBucG0vZmFzdC11cmlAMy4wLjMvbm9kZV9tb2R1bGVzL2Zhc3QtdXJpL2xpYi91dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBIRVggfSA9IHJlcXVpcmUoJy4vc2NvcGVkQ2hhcnMnKVxuXG5mdW5jdGlvbiBub3JtYWxpemVJUHY0IChob3N0KSB7XG4gIGlmIChmaW5kVG9rZW4oaG9zdCwgJy4nKSA8IDMpIHsgcmV0dXJuIHsgaG9zdCwgaXNJUFY0OiBmYWxzZSB9IH1cbiAgY29uc3QgbWF0Y2hlcyA9IGhvc3QubWF0Y2goL14oPzooPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSkkL3UpIHx8IFtdXG4gIGNvbnN0IFthZGRyZXNzXSA9IG1hdGNoZXNcbiAgaWYgKGFkZHJlc3MpIHtcbiAgICByZXR1cm4geyBob3N0OiBzdHJpcExlYWRpbmdaZXJvcyhhZGRyZXNzLCAnLicpLCBpc0lQVjQ6IHRydWUgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IGhvc3QsIGlzSVBWNDogZmFsc2UgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gaW5wdXRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2tlZXBaZXJvPWZhbHNlXVxuICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ0FycmF5VG9IZXhTdHJpcHBlZCAoaW5wdXQsIGtlZXBaZXJvID0gZmFsc2UpIHtcbiAgbGV0IGFjYyA9ICcnXG4gIGxldCBzdHJpcCA9IHRydWVcbiAgZm9yIChjb25zdCBjIG9mIGlucHV0KSB7XG4gICAgaWYgKEhFWFtjXSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgaWYgKGMgIT09ICcwJyAmJiBzdHJpcCA9PT0gdHJ1ZSkgc3RyaXAgPSBmYWxzZVxuICAgIGlmICghc3RyaXApIGFjYyArPSBjXG4gIH1cbiAgaWYgKGtlZXBaZXJvICYmIGFjYy5sZW5ndGggPT09IDApIGFjYyA9ICcwJ1xuICByZXR1cm4gYWNjXG59XG5cbmZ1bmN0aW9uIGdldElQVjYgKGlucHV0KSB7XG4gIGxldCB0b2tlbkNvdW50ID0gMFxuICBjb25zdCBvdXRwdXQgPSB7IGVycm9yOiBmYWxzZSwgYWRkcmVzczogJycsIHpvbmU6ICcnIH1cbiAgY29uc3QgYWRkcmVzcyA9IFtdXG4gIGNvbnN0IGJ1ZmZlciA9IFtdXG4gIGxldCBpc1pvbmUgPSBmYWxzZVxuICBsZXQgZW5kaXB2NkVuY291bnRlcmVkID0gZmFsc2VcbiAgbGV0IGVuZElwdjYgPSBmYWxzZVxuXG4gIGZ1bmN0aW9uIGNvbnN1bWUgKCkge1xuICAgIGlmIChidWZmZXIubGVuZ3RoKSB7XG4gICAgICBpZiAoaXNab25lID09PSBmYWxzZSkge1xuICAgICAgICBjb25zdCBoZXggPSBzdHJpbmdBcnJheVRvSGV4U3RyaXBwZWQoYnVmZmVyKVxuICAgICAgICBpZiAoaGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhZGRyZXNzLnB1c2goaGV4KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dHB1dC5lcnJvciA9IHRydWVcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnVmZmVyLmxlbmd0aCA9IDBcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjdXJzb3IgPSBpbnB1dFtpXVxuICAgIGlmIChjdXJzb3IgPT09ICdbJyB8fCBjdXJzb3IgPT09ICddJykgeyBjb250aW51ZSB9XG4gICAgaWYgKGN1cnNvciA9PT0gJzonKSB7XG4gICAgICBpZiAoZW5kaXB2NkVuY291bnRlcmVkID09PSB0cnVlKSB7XG4gICAgICAgIGVuZElwdjYgPSB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoIWNvbnN1bWUoKSkgeyBicmVhayB9XG4gICAgICB0b2tlbkNvdW50KytcbiAgICAgIGFkZHJlc3MucHVzaCgnOicpXG4gICAgICBpZiAodG9rZW5Db3VudCA+IDcpIHtcbiAgICAgICAgLy8gbm90IHZhbGlkXG4gICAgICAgIG91dHB1dC5lcnJvciA9IHRydWVcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGlmIChpIC0gMSA+PSAwICYmIGlucHV0W2kgLSAxXSA9PT0gJzonKSB7XG4gICAgICAgIGVuZGlwdjZFbmNvdW50ZXJlZCA9IHRydWVcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlXG4gICAgfSBlbHNlIGlmIChjdXJzb3IgPT09ICclJykge1xuICAgICAgaWYgKCFjb25zdW1lKCkpIHsgYnJlYWsgfVxuICAgICAgLy8gc3dpdGNoIHRvIHpvbmUgZGV0ZWN0aW9uXG4gICAgICBpc1pvbmUgPSB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZmZlci5wdXNoKGN1cnNvcilcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICB9XG4gIGlmIChidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGlzWm9uZSkge1xuICAgICAgb3V0cHV0LnpvbmUgPSBidWZmZXIuam9pbignJylcbiAgICB9IGVsc2UgaWYgKGVuZElwdjYpIHtcbiAgICAgIGFkZHJlc3MucHVzaChidWZmZXIuam9pbignJykpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZHJlc3MucHVzaChzdHJpbmdBcnJheVRvSGV4U3RyaXBwZWQoYnVmZmVyKSlcbiAgICB9XG4gIH1cbiAgb3V0cHV0LmFkZHJlc3MgPSBhZGRyZXNzLmpvaW4oJycpXG4gIHJldHVybiBvdXRwdXRcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplSVB2NiAoaG9zdCwgb3B0cyA9IHt9KSB7XG4gIGlmIChmaW5kVG9rZW4oaG9zdCwgJzonKSA8IDIpIHsgcmV0dXJuIHsgaG9zdCwgaXNJUFY2OiBmYWxzZSB9IH1cbiAgY29uc3QgaXB2NiA9IGdldElQVjYoaG9zdClcblxuICBpZiAoIWlwdjYuZXJyb3IpIHtcbiAgICBsZXQgbmV3SG9zdCA9IGlwdjYuYWRkcmVzc1xuICAgIGxldCBlc2NhcGVkSG9zdCA9IGlwdjYuYWRkcmVzc1xuICAgIGlmIChpcHY2LnpvbmUpIHtcbiAgICAgIG5ld0hvc3QgKz0gJyUnICsgaXB2Ni56b25lXG4gICAgICBlc2NhcGVkSG9zdCArPSAnJTI1JyArIGlwdjYuem9uZVxuICAgIH1cbiAgICByZXR1cm4geyBob3N0OiBuZXdIb3N0LCBlc2NhcGVkSG9zdCwgaXNJUFY2OiB0cnVlIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geyBob3N0LCBpc0lQVjY6IGZhbHNlIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdHJpcExlYWRpbmdaZXJvcyAoc3RyLCB0b2tlbikge1xuICBsZXQgb3V0ID0gJydcbiAgbGV0IHNraXAgPSB0cnVlXG4gIGNvbnN0IGwgPSBzdHIubGVuZ3RoXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3QgYyA9IHN0cltpXVxuICAgIGlmIChjID09PSAnMCcgJiYgc2tpcCkge1xuICAgICAgaWYgKChpICsgMSA8PSBsICYmIHN0cltpICsgMV0gPT09IHRva2VuKSB8fCBpICsgMSA9PT0gbCkge1xuICAgICAgICBvdXQgKz0gY1xuICAgICAgICBza2lwID0gZmFsc2VcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGMgPT09IHRva2VuKSB7XG4gICAgICAgIHNraXAgPSB0cnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBza2lwID0gZmFsc2VcbiAgICAgIH1cbiAgICAgIG91dCArPSBjXG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gZmluZFRva2VuIChzdHIsIHRva2VuKSB7XG4gIGxldCBpbmQgPSAwXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0cltpXSA9PT0gdG9rZW4pIGluZCsrXG4gIH1cbiAgcmV0dXJuIGluZFxufVxuXG5jb25zdCBSRFMxID0gL15cXC5cXC4/XFwvL3VcbmNvbnN0IFJEUzIgPSAvXlxcL1xcLig/OlxcL3wkKS91XG5jb25zdCBSRFMzID0gL15cXC9cXC5cXC4oPzpcXC98JCkvdVxuY29uc3QgUkRTNSA9IC9eXFwvPyg/Oi58XFxuKSo/KD89XFwvfCQpL3VcblxuZnVuY3Rpb24gcmVtb3ZlRG90U2VnbWVudHMgKGlucHV0KSB7XG4gIGNvbnN0IG91dHB1dCA9IFtdXG5cbiAgd2hpbGUgKGlucHV0Lmxlbmd0aCkge1xuICAgIGlmIChpbnB1dC5tYXRjaChSRFMxKSkge1xuICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKFJEUzEsICcnKVxuICAgIH0gZWxzZSBpZiAoaW5wdXQubWF0Y2goUkRTMikpIHtcbiAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMyLCAnLycpXG4gICAgfSBlbHNlIGlmIChpbnB1dC5tYXRjaChSRFMzKSkge1xuICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKFJEUzMsICcvJylcbiAgICAgIG91dHB1dC5wb3AoKVxuICAgIH0gZWxzZSBpZiAoaW5wdXQgPT09ICcuJyB8fCBpbnB1dCA9PT0gJy4uJykge1xuICAgICAgaW5wdXQgPSAnJ1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpbSA9IGlucHV0Lm1hdGNoKFJEUzUpXG4gICAgICBpZiAoaW0pIHtcbiAgICAgICAgY29uc3QgcyA9IGltWzBdXG4gICAgICAgIGlucHV0ID0gaW5wdXQuc2xpY2Uocy5sZW5ndGgpXG4gICAgICAgIG91dHB1dC5wdXNoKHMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgZG90IHNlZ21lbnQgY29uZGl0aW9uJylcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyAoY29tcG9uZW50cywgZXNjKSB7XG4gIGNvbnN0IGZ1bmMgPSBlc2MgIT09IHRydWUgPyBlc2NhcGUgOiB1bmVzY2FwZVxuICBpZiAoY29tcG9uZW50cy5zY2hlbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbXBvbmVudHMuc2NoZW1lID0gZnVuYyhjb21wb25lbnRzLnNjaGVtZSlcbiAgfVxuICBpZiAoY29tcG9uZW50cy51c2VyaW5mbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29tcG9uZW50cy51c2VyaW5mbyA9IGZ1bmMoY29tcG9uZW50cy51c2VyaW5mbylcbiAgfVxuICBpZiAoY29tcG9uZW50cy5ob3N0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb21wb25lbnRzLmhvc3QgPSBmdW5jKGNvbXBvbmVudHMuaG9zdClcbiAgfVxuICBpZiAoY29tcG9uZW50cy5wYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb21wb25lbnRzLnBhdGggPSBmdW5jKGNvbXBvbmVudHMucGF0aClcbiAgfVxuICBpZiAoY29tcG9uZW50cy5xdWVyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29tcG9uZW50cy5xdWVyeSA9IGZ1bmMoY29tcG9uZW50cy5xdWVyeSlcbiAgfVxuICBpZiAoY29tcG9uZW50cy5mcmFnbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29tcG9uZW50cy5mcmFnbWVudCA9IGZ1bmMoY29tcG9uZW50cy5mcmFnbWVudClcbiAgfVxuICByZXR1cm4gY29tcG9uZW50c1xufVxuXG5mdW5jdGlvbiByZWNvbXBvc2VBdXRob3JpdHkgKGNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgY29uc3QgdXJpVG9rZW5zID0gW11cblxuICBpZiAoY29tcG9uZW50cy51c2VyaW5mbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy51c2VyaW5mbylcbiAgICB1cmlUb2tlbnMucHVzaCgnQCcpXG4gIH1cblxuICBpZiAoY29tcG9uZW50cy5ob3N0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBsZXQgaG9zdCA9IHVuZXNjYXBlKGNvbXBvbmVudHMuaG9zdClcbiAgICBjb25zdCBpcFY0cmVzID0gbm9ybWFsaXplSVB2NChob3N0KVxuXG4gICAgaWYgKGlwVjRyZXMuaXNJUFY0KSB7XG4gICAgICBob3N0ID0gaXBWNHJlcy5ob3N0XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGlwVjZyZXMgPSBub3JtYWxpemVJUHY2KGlwVjRyZXMuaG9zdCwgeyBpc0lQVjQ6IGZhbHNlIH0pXG4gICAgICBpZiAoaXBWNnJlcy5pc0lQVjYgPT09IHRydWUpIHtcbiAgICAgICAgaG9zdCA9IGBbJHtpcFY2cmVzLmVzY2FwZWRIb3N0fV1gXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBob3N0ID0gY29tcG9uZW50cy5ob3N0XG4gICAgICB9XG4gICAgfVxuICAgIHVyaVRva2Vucy5wdXNoKGhvc3QpXG4gIH1cblxuICBpZiAodHlwZW9mIGNvbXBvbmVudHMucG9ydCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGNvbXBvbmVudHMucG9ydCA9PT0gJ3N0cmluZycpIHtcbiAgICB1cmlUb2tlbnMucHVzaCgnOicpXG4gICAgdXJpVG9rZW5zLnB1c2goU3RyaW5nKGNvbXBvbmVudHMucG9ydCkpXG4gIH1cblxuICByZXR1cm4gdXJpVG9rZW5zLmxlbmd0aCA/IHVyaVRva2Vucy5qb2luKCcnKSA6IHVuZGVmaW5lZFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJlY29tcG9zZUF1dGhvcml0eSxcbiAgbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcsXG4gIHJlbW92ZURvdFNlZ21lbnRzLFxuICBub3JtYWxpemVJUHY0LFxuICBub3JtYWxpemVJUHY2LFxuICBzdHJpbmdBcnJheVRvSGV4U3RyaXBwZWRcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/utils.js\n");

/***/ })

};
;
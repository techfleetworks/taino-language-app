"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@smithy+middleware-stack@3.0.10";
exports.ids = ["vendor-chunks/@smithy+middleware-stack@3.0.10"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/@smithy+middleware-stack@3.0.10/node_modules/@smithy/middleware-stack/dist-es/MiddlewareStack.js":
/*!*****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@smithy+middleware-stack@3.0.10/node_modules/@smithy/middleware-stack/dist-es/MiddlewareStack.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   constructStack: () => (/* binding */ constructStack)\n/* harmony export */ });\nconst getAllAliases = (name, aliases) => {\n    const _aliases = [];\n    if (name) {\n        _aliases.push(name);\n    }\n    if (aliases) {\n        for (const alias of aliases) {\n            _aliases.push(alias);\n        }\n    }\n    return _aliases;\n};\nconst getMiddlewareNameWithAliases = (name, aliases) => {\n    return `${name || \"anonymous\"}${aliases && aliases.length > 0 ? ` (a.k.a. ${aliases.join(\",\")})` : \"\"}`;\n};\nconst constructStack = () => {\n    let absoluteEntries = [];\n    let relativeEntries = [];\n    let identifyOnResolve = false;\n    const entriesNameSet = new Set();\n    const sort = (entries) => entries.sort((a, b) => stepWeights[b.step] - stepWeights[a.step] ||\n        priorityWeights[b.priority || \"normal\"] - priorityWeights[a.priority || \"normal\"]);\n    const removeByName = (toRemove) => {\n        let isRemoved = false;\n        const filterCb = (entry) => {\n            const aliases = getAllAliases(entry.name, entry.aliases);\n            if (aliases.includes(toRemove)) {\n                isRemoved = true;\n                for (const alias of aliases) {\n                    entriesNameSet.delete(alias);\n                }\n                return false;\n            }\n            return true;\n        };\n        absoluteEntries = absoluteEntries.filter(filterCb);\n        relativeEntries = relativeEntries.filter(filterCb);\n        return isRemoved;\n    };\n    const removeByReference = (toRemove) => {\n        let isRemoved = false;\n        const filterCb = (entry) => {\n            if (entry.middleware === toRemove) {\n                isRemoved = true;\n                for (const alias of getAllAliases(entry.name, entry.aliases)) {\n                    entriesNameSet.delete(alias);\n                }\n                return false;\n            }\n            return true;\n        };\n        absoluteEntries = absoluteEntries.filter(filterCb);\n        relativeEntries = relativeEntries.filter(filterCb);\n        return isRemoved;\n    };\n    const cloneTo = (toStack) => {\n        absoluteEntries.forEach((entry) => {\n            toStack.add(entry.middleware, { ...entry });\n        });\n        relativeEntries.forEach((entry) => {\n            toStack.addRelativeTo(entry.middleware, { ...entry });\n        });\n        toStack.identifyOnResolve?.(stack.identifyOnResolve());\n        return toStack;\n    };\n    const expandRelativeMiddlewareList = (from) => {\n        const expandedMiddlewareList = [];\n        from.before.forEach((entry) => {\n            if (entry.before.length === 0 && entry.after.length === 0) {\n                expandedMiddlewareList.push(entry);\n            }\n            else {\n                expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));\n            }\n        });\n        expandedMiddlewareList.push(from);\n        from.after.reverse().forEach((entry) => {\n            if (entry.before.length === 0 && entry.after.length === 0) {\n                expandedMiddlewareList.push(entry);\n            }\n            else {\n                expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));\n            }\n        });\n        return expandedMiddlewareList;\n    };\n    const getMiddlewareList = (debug = false) => {\n        const normalizedAbsoluteEntries = [];\n        const normalizedRelativeEntries = [];\n        const normalizedEntriesNameMap = {};\n        absoluteEntries.forEach((entry) => {\n            const normalizedEntry = {\n                ...entry,\n                before: [],\n                after: [],\n            };\n            for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {\n                normalizedEntriesNameMap[alias] = normalizedEntry;\n            }\n            normalizedAbsoluteEntries.push(normalizedEntry);\n        });\n        relativeEntries.forEach((entry) => {\n            const normalizedEntry = {\n                ...entry,\n                before: [],\n                after: [],\n            };\n            for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {\n                normalizedEntriesNameMap[alias] = normalizedEntry;\n            }\n            normalizedRelativeEntries.push(normalizedEntry);\n        });\n        normalizedRelativeEntries.forEach((entry) => {\n            if (entry.toMiddleware) {\n                const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];\n                if (toMiddleware === undefined) {\n                    if (debug) {\n                        return;\n                    }\n                    throw new Error(`${entry.toMiddleware} is not found when adding ` +\n                        `${getMiddlewareNameWithAliases(entry.name, entry.aliases)} ` +\n                        `middleware ${entry.relation} ${entry.toMiddleware}`);\n                }\n                if (entry.relation === \"after\") {\n                    toMiddleware.after.push(entry);\n                }\n                if (entry.relation === \"before\") {\n                    toMiddleware.before.push(entry);\n                }\n            }\n        });\n        const mainChain = sort(normalizedAbsoluteEntries)\n            .map(expandRelativeMiddlewareList)\n            .reduce((wholeList, expandedMiddlewareList) => {\n            wholeList.push(...expandedMiddlewareList);\n            return wholeList;\n        }, []);\n        return mainChain;\n    };\n    const stack = {\n        add: (middleware, options = {}) => {\n            const { name, override, aliases: _aliases } = options;\n            const entry = {\n                step: \"initialize\",\n                priority: \"normal\",\n                middleware,\n                ...options,\n            };\n            const aliases = getAllAliases(name, _aliases);\n            if (aliases.length > 0) {\n                if (aliases.some((alias) => entriesNameSet.has(alias))) {\n                    if (!override)\n                        throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);\n                    for (const alias of aliases) {\n                        const toOverrideIndex = absoluteEntries.findIndex((entry) => entry.name === alias || entry.aliases?.some((a) => a === alias));\n                        if (toOverrideIndex === -1) {\n                            continue;\n                        }\n                        const toOverride = absoluteEntries[toOverrideIndex];\n                        if (toOverride.step !== entry.step || entry.priority !== toOverride.priority) {\n                            throw new Error(`\"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}\" middleware with ` +\n                                `${toOverride.priority} priority in ${toOverride.step} step cannot ` +\n                                `be overridden by \"${getMiddlewareNameWithAliases(name, _aliases)}\" middleware with ` +\n                                `${entry.priority} priority in ${entry.step} step.`);\n                        }\n                        absoluteEntries.splice(toOverrideIndex, 1);\n                    }\n                }\n                for (const alias of aliases) {\n                    entriesNameSet.add(alias);\n                }\n            }\n            absoluteEntries.push(entry);\n        },\n        addRelativeTo: (middleware, options) => {\n            const { name, override, aliases: _aliases } = options;\n            const entry = {\n                middleware,\n                ...options,\n            };\n            const aliases = getAllAliases(name, _aliases);\n            if (aliases.length > 0) {\n                if (aliases.some((alias) => entriesNameSet.has(alias))) {\n                    if (!override)\n                        throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);\n                    for (const alias of aliases) {\n                        const toOverrideIndex = relativeEntries.findIndex((entry) => entry.name === alias || entry.aliases?.some((a) => a === alias));\n                        if (toOverrideIndex === -1) {\n                            continue;\n                        }\n                        const toOverride = relativeEntries[toOverrideIndex];\n                        if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {\n                            throw new Error(`\"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}\" middleware ` +\n                                `${toOverride.relation} \"${toOverride.toMiddleware}\" middleware cannot be overridden ` +\n                                `by \"${getMiddlewareNameWithAliases(name, _aliases)}\" middleware ${entry.relation} ` +\n                                `\"${entry.toMiddleware}\" middleware.`);\n                        }\n                        relativeEntries.splice(toOverrideIndex, 1);\n                    }\n                }\n                for (const alias of aliases) {\n                    entriesNameSet.add(alias);\n                }\n            }\n            relativeEntries.push(entry);\n        },\n        clone: () => cloneTo(constructStack()),\n        use: (plugin) => {\n            plugin.applyToStack(stack);\n        },\n        remove: (toRemove) => {\n            if (typeof toRemove === \"string\")\n                return removeByName(toRemove);\n            else\n                return removeByReference(toRemove);\n        },\n        removeByTag: (toRemove) => {\n            let isRemoved = false;\n            const filterCb = (entry) => {\n                const { tags, name, aliases: _aliases } = entry;\n                if (tags && tags.includes(toRemove)) {\n                    const aliases = getAllAliases(name, _aliases);\n                    for (const alias of aliases) {\n                        entriesNameSet.delete(alias);\n                    }\n                    isRemoved = true;\n                    return false;\n                }\n                return true;\n            };\n            absoluteEntries = absoluteEntries.filter(filterCb);\n            relativeEntries = relativeEntries.filter(filterCb);\n            return isRemoved;\n        },\n        concat: (from) => {\n            const cloned = cloneTo(constructStack());\n            cloned.use(from);\n            cloned.identifyOnResolve(identifyOnResolve || cloned.identifyOnResolve() || (from.identifyOnResolve?.() ?? false));\n            return cloned;\n        },\n        applyToStack: cloneTo,\n        identify: () => {\n            return getMiddlewareList(true).map((mw) => {\n                const step = mw.step ??\n                    mw.relation +\n                        \" \" +\n                        mw.toMiddleware;\n                return getMiddlewareNameWithAliases(mw.name, mw.aliases) + \" - \" + step;\n            });\n        },\n        identifyOnResolve(toggle) {\n            if (typeof toggle === \"boolean\")\n                identifyOnResolve = toggle;\n            return identifyOnResolve;\n        },\n        resolve: (handler, context) => {\n            for (const middleware of getMiddlewareList()\n                .map((entry) => entry.middleware)\n                .reverse()) {\n                handler = middleware(handler, context);\n            }\n            if (identifyOnResolve) {\n                console.log(stack.identify());\n            }\n            return handler;\n        },\n    };\n    return stack;\n};\nconst stepWeights = {\n    initialize: 5,\n    serialize: 4,\n    build: 3,\n    finalizeRequest: 2,\n    deserialize: 1,\n};\nconst priorityWeights = {\n    high: 3,\n    normal: 2,\n    low: 1,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNtaXRoeSttaWRkbGV3YXJlLXN0YWNrQDMuMC4xMC9ub2RlX21vZHVsZXMvQHNtaXRoeS9taWRkbGV3YXJlLXN0YWNrL2Rpc3QtZXMvTWlkZGxld2FyZVN0YWNrLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0JBQW9CLEVBQUUsNENBQTRDLGtCQUFrQixRQUFRO0FBQzFHO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFVBQVU7QUFDdEQsU0FBUztBQUNUO0FBQ0Esc0RBQXNELFVBQVU7QUFDaEUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLG9CQUFvQjtBQUMzRCwyQkFBMkIseURBQXlEO0FBQ3BGLHNDQUFzQyxnQkFBZ0IsRUFBRSxtQkFBbUI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyxvQkFBb0Isb0NBQW9DO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLDZDQUE2QztBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxrRUFBa0U7QUFDbEgsbUNBQW1DLHFCQUFxQixjQUFjLGlCQUFpQjtBQUN2RixxREFBcUQsNkNBQTZDO0FBQ2xHLG1DQUFtQyxnQkFBZ0IsY0FBYyxZQUFZO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLG9CQUFvQixvQ0FBb0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSw2Q0FBNkM7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsa0VBQWtFO0FBQ2xILG1DQUFtQyxxQkFBcUIsR0FBRyx3QkFBd0I7QUFDbkYsdUNBQXVDLDZDQUE2QyxlQUFlLGdCQUFnQjtBQUNuSCxvQ0FBb0MsbUJBQW1CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0NBQWdDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMva2FyZWxsZS92c2Nwcm9qZWN0cy90ZWNoLWZsZWV0L3RhaW5vLWxhbmd1YWdlLWFwcC9sZXNzb24tYXV0aG9yaW5nL25vZGVfbW9kdWxlcy8ucG5wbS9Ac21pdGh5K21pZGRsZXdhcmUtc3RhY2tAMy4wLjEwL25vZGVfbW9kdWxlcy9Ac21pdGh5L21pZGRsZXdhcmUtc3RhY2svZGlzdC1lcy9NaWRkbGV3YXJlU3RhY2suanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZ2V0QWxsQWxpYXNlcyA9IChuYW1lLCBhbGlhc2VzKSA9PiB7XG4gICAgY29uc3QgX2FsaWFzZXMgPSBbXTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgICBfYWxpYXNlcy5wdXNoKG5hbWUpO1xuICAgIH1cbiAgICBpZiAoYWxpYXNlcykge1xuICAgICAgICBmb3IgKGNvbnN0IGFsaWFzIG9mIGFsaWFzZXMpIHtcbiAgICAgICAgICAgIF9hbGlhc2VzLnB1c2goYWxpYXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfYWxpYXNlcztcbn07XG5jb25zdCBnZXRNaWRkbGV3YXJlTmFtZVdpdGhBbGlhc2VzID0gKG5hbWUsIGFsaWFzZXMpID0+IHtcbiAgICByZXR1cm4gYCR7bmFtZSB8fCBcImFub255bW91c1wifSR7YWxpYXNlcyAmJiBhbGlhc2VzLmxlbmd0aCA+IDAgPyBgIChhLmsuYS4gJHthbGlhc2VzLmpvaW4oXCIsXCIpfSlgIDogXCJcIn1gO1xufTtcbmV4cG9ydCBjb25zdCBjb25zdHJ1Y3RTdGFjayA9ICgpID0+IHtcbiAgICBsZXQgYWJzb2x1dGVFbnRyaWVzID0gW107XG4gICAgbGV0IHJlbGF0aXZlRW50cmllcyA9IFtdO1xuICAgIGxldCBpZGVudGlmeU9uUmVzb2x2ZSA9IGZhbHNlO1xuICAgIGNvbnN0IGVudHJpZXNOYW1lU2V0ID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IHNvcnQgPSAoZW50cmllcykgPT4gZW50cmllcy5zb3J0KChhLCBiKSA9PiBzdGVwV2VpZ2h0c1tiLnN0ZXBdIC0gc3RlcFdlaWdodHNbYS5zdGVwXSB8fFxuICAgICAgICBwcmlvcml0eVdlaWdodHNbYi5wcmlvcml0eSB8fCBcIm5vcm1hbFwiXSAtIHByaW9yaXR5V2VpZ2h0c1thLnByaW9yaXR5IHx8IFwibm9ybWFsXCJdKTtcbiAgICBjb25zdCByZW1vdmVCeU5hbWUgPSAodG9SZW1vdmUpID0+IHtcbiAgICAgICAgbGV0IGlzUmVtb3ZlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBmaWx0ZXJDYiA9IChlbnRyeSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWxpYXNlcyA9IGdldEFsbEFsaWFzZXMoZW50cnkubmFtZSwgZW50cnkuYWxpYXNlcyk7XG4gICAgICAgICAgICBpZiAoYWxpYXNlcy5pbmNsdWRlcyh0b1JlbW92ZSkpIHtcbiAgICAgICAgICAgICAgICBpc1JlbW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYWxpYXMgb2YgYWxpYXNlcykge1xuICAgICAgICAgICAgICAgICAgICBlbnRyaWVzTmFtZVNldC5kZWxldGUoYWxpYXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgYWJzb2x1dGVFbnRyaWVzID0gYWJzb2x1dGVFbnRyaWVzLmZpbHRlcihmaWx0ZXJDYik7XG4gICAgICAgIHJlbGF0aXZlRW50cmllcyA9IHJlbGF0aXZlRW50cmllcy5maWx0ZXIoZmlsdGVyQ2IpO1xuICAgICAgICByZXR1cm4gaXNSZW1vdmVkO1xuICAgIH07XG4gICAgY29uc3QgcmVtb3ZlQnlSZWZlcmVuY2UgPSAodG9SZW1vdmUpID0+IHtcbiAgICAgICAgbGV0IGlzUmVtb3ZlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBmaWx0ZXJDYiA9IChlbnRyeSkgPT4ge1xuICAgICAgICAgICAgaWYgKGVudHJ5Lm1pZGRsZXdhcmUgPT09IHRvUmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgaXNSZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGFsaWFzIG9mIGdldEFsbEFsaWFzZXMoZW50cnkubmFtZSwgZW50cnkuYWxpYXNlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgZW50cmllc05hbWVTZXQuZGVsZXRlKGFsaWFzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIGFic29sdXRlRW50cmllcyA9IGFic29sdXRlRW50cmllcy5maWx0ZXIoZmlsdGVyQ2IpO1xuICAgICAgICByZWxhdGl2ZUVudHJpZXMgPSByZWxhdGl2ZUVudHJpZXMuZmlsdGVyKGZpbHRlckNiKTtcbiAgICAgICAgcmV0dXJuIGlzUmVtb3ZlZDtcbiAgICB9O1xuICAgIGNvbnN0IGNsb25lVG8gPSAodG9TdGFjaykgPT4ge1xuICAgICAgICBhYnNvbHV0ZUVudHJpZXMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgICAgICAgIHRvU3RhY2suYWRkKGVudHJ5Lm1pZGRsZXdhcmUsIHsgLi4uZW50cnkgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZWxhdGl2ZUVudHJpZXMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgICAgICAgIHRvU3RhY2suYWRkUmVsYXRpdmVUbyhlbnRyeS5taWRkbGV3YXJlLCB7IC4uLmVudHJ5IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdG9TdGFjay5pZGVudGlmeU9uUmVzb2x2ZT8uKHN0YWNrLmlkZW50aWZ5T25SZXNvbHZlKCkpO1xuICAgICAgICByZXR1cm4gdG9TdGFjaztcbiAgICB9O1xuICAgIGNvbnN0IGV4cGFuZFJlbGF0aXZlTWlkZGxld2FyZUxpc3QgPSAoZnJvbSkgPT4ge1xuICAgICAgICBjb25zdCBleHBhbmRlZE1pZGRsZXdhcmVMaXN0ID0gW107XG4gICAgICAgIGZyb20uYmVmb3JlLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICAgICAgICBpZiAoZW50cnkuYmVmb3JlLmxlbmd0aCA9PT0gMCAmJiBlbnRyeS5hZnRlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBleHBhbmRlZE1pZGRsZXdhcmVMaXN0LnB1c2goZW50cnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhwYW5kZWRNaWRkbGV3YXJlTGlzdC5wdXNoKC4uLmV4cGFuZFJlbGF0aXZlTWlkZGxld2FyZUxpc3QoZW50cnkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGV4cGFuZGVkTWlkZGxld2FyZUxpc3QucHVzaChmcm9tKTtcbiAgICAgICAgZnJvbS5hZnRlci5yZXZlcnNlKCkuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgICAgICAgIGlmIChlbnRyeS5iZWZvcmUubGVuZ3RoID09PSAwICYmIGVudHJ5LmFmdGVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGV4cGFuZGVkTWlkZGxld2FyZUxpc3QucHVzaChlbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHBhbmRlZE1pZGRsZXdhcmVMaXN0LnB1c2goLi4uZXhwYW5kUmVsYXRpdmVNaWRkbGV3YXJlTGlzdChlbnRyeSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGV4cGFuZGVkTWlkZGxld2FyZUxpc3Q7XG4gICAgfTtcbiAgICBjb25zdCBnZXRNaWRkbGV3YXJlTGlzdCA9IChkZWJ1ZyA9IGZhbHNlKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRBYnNvbHV0ZUVudHJpZXMgPSBbXTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFJlbGF0aXZlRW50cmllcyA9IFtdO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkRW50cmllc05hbWVNYXAgPSB7fTtcbiAgICAgICAgYWJzb2x1dGVFbnRyaWVzLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkRW50cnkgPSB7XG4gICAgICAgICAgICAgICAgLi4uZW50cnksXG4gICAgICAgICAgICAgICAgYmVmb3JlOiBbXSxcbiAgICAgICAgICAgICAgICBhZnRlcjogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBhbGlhcyBvZiBnZXRBbGxBbGlhc2VzKG5vcm1hbGl6ZWRFbnRyeS5uYW1lLCBub3JtYWxpemVkRW50cnkuYWxpYXNlcykpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkRW50cmllc05hbWVNYXBbYWxpYXNdID0gbm9ybWFsaXplZEVudHJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9ybWFsaXplZEFic29sdXRlRW50cmllcy5wdXNoKG5vcm1hbGl6ZWRFbnRyeSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZWxhdGl2ZUVudHJpZXMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRFbnRyeSA9IHtcbiAgICAgICAgICAgICAgICAuLi5lbnRyeSxcbiAgICAgICAgICAgICAgICBiZWZvcmU6IFtdLFxuICAgICAgICAgICAgICAgIGFmdGVyOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFsaWFzIG9mIGdldEFsbEFsaWFzZXMobm9ybWFsaXplZEVudHJ5Lm5hbWUsIG5vcm1hbGl6ZWRFbnRyeS5hbGlhc2VzKSkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRFbnRyaWVzTmFtZU1hcFthbGlhc10gPSBub3JtYWxpemVkRW50cnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub3JtYWxpemVkUmVsYXRpdmVFbnRyaWVzLnB1c2gobm9ybWFsaXplZEVudHJ5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG5vcm1hbGl6ZWRSZWxhdGl2ZUVudHJpZXMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgICAgICAgIGlmIChlbnRyeS50b01pZGRsZXdhcmUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b01pZGRsZXdhcmUgPSBub3JtYWxpemVkRW50cmllc05hbWVNYXBbZW50cnkudG9NaWRkbGV3YXJlXTtcbiAgICAgICAgICAgICAgICBpZiAodG9NaWRkbGV3YXJlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2VudHJ5LnRvTWlkZGxld2FyZX0gaXMgbm90IGZvdW5kIHdoZW4gYWRkaW5nIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCR7Z2V0TWlkZGxld2FyZU5hbWVXaXRoQWxpYXNlcyhlbnRyeS5uYW1lLCBlbnRyeS5hbGlhc2VzKX0gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgbWlkZGxld2FyZSAke2VudHJ5LnJlbGF0aW9ufSAke2VudHJ5LnRvTWlkZGxld2FyZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5LnJlbGF0aW9uID09PSBcImFmdGVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9NaWRkbGV3YXJlLmFmdGVyLnB1c2goZW50cnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZW50cnkucmVsYXRpb24gPT09IFwiYmVmb3JlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9NaWRkbGV3YXJlLmJlZm9yZS5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBtYWluQ2hhaW4gPSBzb3J0KG5vcm1hbGl6ZWRBYnNvbHV0ZUVudHJpZXMpXG4gICAgICAgICAgICAubWFwKGV4cGFuZFJlbGF0aXZlTWlkZGxld2FyZUxpc3QpXG4gICAgICAgICAgICAucmVkdWNlKCh3aG9sZUxpc3QsIGV4cGFuZGVkTWlkZGxld2FyZUxpc3QpID0+IHtcbiAgICAgICAgICAgIHdob2xlTGlzdC5wdXNoKC4uLmV4cGFuZGVkTWlkZGxld2FyZUxpc3QpO1xuICAgICAgICAgICAgcmV0dXJuIHdob2xlTGlzdDtcbiAgICAgICAgfSwgW10pO1xuICAgICAgICByZXR1cm4gbWFpbkNoYWluO1xuICAgIH07XG4gICAgY29uc3Qgc3RhY2sgPSB7XG4gICAgICAgIGFkZDogKG1pZGRsZXdhcmUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBuYW1lLCBvdmVycmlkZSwgYWxpYXNlczogX2FsaWFzZXMgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgICAgICAgICAgICBzdGVwOiBcImluaXRpYWxpemVcIixcbiAgICAgICAgICAgICAgICBwcmlvcml0eTogXCJub3JtYWxcIixcbiAgICAgICAgICAgICAgICBtaWRkbGV3YXJlLFxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgYWxpYXNlcyA9IGdldEFsbEFsaWFzZXMobmFtZSwgX2FsaWFzZXMpO1xuICAgICAgICAgICAgaWYgKGFsaWFzZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChhbGlhc2VzLnNvbWUoKGFsaWFzKSA9PiBlbnRyaWVzTmFtZVNldC5oYXMoYWxpYXMpKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW92ZXJyaWRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgbWlkZGxld2FyZSBuYW1lICcke2dldE1pZGRsZXdhcmVOYW1lV2l0aEFsaWFzZXMobmFtZSwgX2FsaWFzZXMpfSdgKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBhbGlhcyBvZiBhbGlhc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b092ZXJyaWRlSW5kZXggPSBhYnNvbHV0ZUVudHJpZXMuZmluZEluZGV4KChlbnRyeSkgPT4gZW50cnkubmFtZSA9PT0gYWxpYXMgfHwgZW50cnkuYWxpYXNlcz8uc29tZSgoYSkgPT4gYSA9PT0gYWxpYXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b092ZXJyaWRlSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b092ZXJyaWRlID0gYWJzb2x1dGVFbnRyaWVzW3RvT3ZlcnJpZGVJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9PdmVycmlkZS5zdGVwICE9PSBlbnRyeS5zdGVwIHx8IGVudHJ5LnByaW9yaXR5ICE9PSB0b092ZXJyaWRlLnByaW9yaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7Z2V0TWlkZGxld2FyZU5hbWVXaXRoQWxpYXNlcyh0b092ZXJyaWRlLm5hbWUsIHRvT3ZlcnJpZGUuYWxpYXNlcyl9XCIgbWlkZGxld2FyZSB3aXRoIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgJHt0b092ZXJyaWRlLnByaW9yaXR5fSBwcmlvcml0eSBpbiAke3RvT3ZlcnJpZGUuc3RlcH0gc3RlcCBjYW5ub3QgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBiZSBvdmVycmlkZGVuIGJ5IFwiJHtnZXRNaWRkbGV3YXJlTmFtZVdpdGhBbGlhc2VzKG5hbWUsIF9hbGlhc2VzKX1cIiBtaWRkbGV3YXJlIHdpdGggYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAke2VudHJ5LnByaW9yaXR5fSBwcmlvcml0eSBpbiAke2VudHJ5LnN0ZXB9IHN0ZXAuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhYnNvbHV0ZUVudHJpZXMuc3BsaWNlKHRvT3ZlcnJpZGVJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBhbGlhcyBvZiBhbGlhc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGVudHJpZXNOYW1lU2V0LmFkZChhbGlhcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWJzb2x1dGVFbnRyaWVzLnB1c2goZW50cnkpO1xuICAgICAgICB9LFxuICAgICAgICBhZGRSZWxhdGl2ZVRvOiAobWlkZGxld2FyZSwgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBuYW1lLCBvdmVycmlkZSwgYWxpYXNlczogX2FsaWFzZXMgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgICAgICAgICAgICBtaWRkbGV3YXJlLFxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgYWxpYXNlcyA9IGdldEFsbEFsaWFzZXMobmFtZSwgX2FsaWFzZXMpO1xuICAgICAgICAgICAgaWYgKGFsaWFzZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChhbGlhc2VzLnNvbWUoKGFsaWFzKSA9PiBlbnRyaWVzTmFtZVNldC5oYXMoYWxpYXMpKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW92ZXJyaWRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgbWlkZGxld2FyZSBuYW1lICcke2dldE1pZGRsZXdhcmVOYW1lV2l0aEFsaWFzZXMobmFtZSwgX2FsaWFzZXMpfSdgKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBhbGlhcyBvZiBhbGlhc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b092ZXJyaWRlSW5kZXggPSByZWxhdGl2ZUVudHJpZXMuZmluZEluZGV4KChlbnRyeSkgPT4gZW50cnkubmFtZSA9PT0gYWxpYXMgfHwgZW50cnkuYWxpYXNlcz8uc29tZSgoYSkgPT4gYSA9PT0gYWxpYXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b092ZXJyaWRlSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b092ZXJyaWRlID0gcmVsYXRpdmVFbnRyaWVzW3RvT3ZlcnJpZGVJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9PdmVycmlkZS50b01pZGRsZXdhcmUgIT09IGVudHJ5LnRvTWlkZGxld2FyZSB8fCB0b092ZXJyaWRlLnJlbGF0aW9uICE9PSBlbnRyeS5yZWxhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke2dldE1pZGRsZXdhcmVOYW1lV2l0aEFsaWFzZXModG9PdmVycmlkZS5uYW1lLCB0b092ZXJyaWRlLmFsaWFzZXMpfVwiIG1pZGRsZXdhcmUgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAke3RvT3ZlcnJpZGUucmVsYXRpb259IFwiJHt0b092ZXJyaWRlLnRvTWlkZGxld2FyZX1cIiBtaWRkbGV3YXJlIGNhbm5vdCBiZSBvdmVycmlkZGVuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgYnkgXCIke2dldE1pZGRsZXdhcmVOYW1lV2l0aEFsaWFzZXMobmFtZSwgX2FsaWFzZXMpfVwiIG1pZGRsZXdhcmUgJHtlbnRyeS5yZWxhdGlvbn0gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcIiR7ZW50cnkudG9NaWRkbGV3YXJlfVwiIG1pZGRsZXdhcmUuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZUVudHJpZXMuc3BsaWNlKHRvT3ZlcnJpZGVJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBhbGlhcyBvZiBhbGlhc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGVudHJpZXNOYW1lU2V0LmFkZChhbGlhcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVsYXRpdmVFbnRyaWVzLnB1c2goZW50cnkpO1xuICAgICAgICB9LFxuICAgICAgICBjbG9uZTogKCkgPT4gY2xvbmVUbyhjb25zdHJ1Y3RTdGFjaygpKSxcbiAgICAgICAgdXNlOiAocGx1Z2luKSA9PiB7XG4gICAgICAgICAgICBwbHVnaW4uYXBwbHlUb1N0YWNrKHN0YWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlOiAodG9SZW1vdmUpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG9SZW1vdmUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZUJ5TmFtZSh0b1JlbW92ZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZUJ5UmVmZXJlbmNlKHRvUmVtb3ZlKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlQnlUYWc6ICh0b1JlbW92ZSkgPT4ge1xuICAgICAgICAgICAgbGV0IGlzUmVtb3ZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyQ2IgPSAoZW50cnkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHRhZ3MsIG5hbWUsIGFsaWFzZXM6IF9hbGlhc2VzIH0gPSBlbnRyeTtcbiAgICAgICAgICAgICAgICBpZiAodGFncyAmJiB0YWdzLmluY2x1ZGVzKHRvUmVtb3ZlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbGlhc2VzID0gZ2V0QWxsQWxpYXNlcyhuYW1lLCBfYWxpYXNlcyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYWxpYXMgb2YgYWxpYXNlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW50cmllc05hbWVTZXQuZGVsZXRlKGFsaWFzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpc1JlbW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFic29sdXRlRW50cmllcyA9IGFic29sdXRlRW50cmllcy5maWx0ZXIoZmlsdGVyQ2IpO1xuICAgICAgICAgICAgcmVsYXRpdmVFbnRyaWVzID0gcmVsYXRpdmVFbnRyaWVzLmZpbHRlcihmaWx0ZXJDYik7XG4gICAgICAgICAgICByZXR1cm4gaXNSZW1vdmVkO1xuICAgICAgICB9LFxuICAgICAgICBjb25jYXQ6IChmcm9tKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjbG9uZWQgPSBjbG9uZVRvKGNvbnN0cnVjdFN0YWNrKCkpO1xuICAgICAgICAgICAgY2xvbmVkLnVzZShmcm9tKTtcbiAgICAgICAgICAgIGNsb25lZC5pZGVudGlmeU9uUmVzb2x2ZShpZGVudGlmeU9uUmVzb2x2ZSB8fCBjbG9uZWQuaWRlbnRpZnlPblJlc29sdmUoKSB8fCAoZnJvbS5pZGVudGlmeU9uUmVzb2x2ZT8uKCkgPz8gZmFsc2UpKTtcbiAgICAgICAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGFwcGx5VG9TdGFjazogY2xvbmVUbyxcbiAgICAgICAgaWRlbnRpZnk6ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRNaWRkbGV3YXJlTGlzdCh0cnVlKS5tYXAoKG13KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RlcCA9IG13LnN0ZXAgPz9cbiAgICAgICAgICAgICAgICAgICAgbXcucmVsYXRpb24gK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbXcudG9NaWRkbGV3YXJlO1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRNaWRkbGV3YXJlTmFtZVdpdGhBbGlhc2VzKG13Lm5hbWUsIG13LmFsaWFzZXMpICsgXCIgLSBcIiArIHN0ZXA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgaWRlbnRpZnlPblJlc29sdmUodG9nZ2xlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRvZ2dsZSA9PT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgICAgICAgaWRlbnRpZnlPblJlc29sdmUgPSB0b2dnbGU7XG4gICAgICAgICAgICByZXR1cm4gaWRlbnRpZnlPblJlc29sdmU7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc29sdmU6IChoYW5kbGVyLCBjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1pZGRsZXdhcmUgb2YgZ2V0TWlkZGxld2FyZUxpc3QoKVxuICAgICAgICAgICAgICAgIC5tYXAoKGVudHJ5KSA9PiBlbnRyeS5taWRkbGV3YXJlKVxuICAgICAgICAgICAgICAgIC5yZXZlcnNlKCkpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gbWlkZGxld2FyZShoYW5kbGVyLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpZGVudGlmeU9uUmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHN0YWNrLmlkZW50aWZ5KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXI7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gc3RhY2s7XG59O1xuY29uc3Qgc3RlcFdlaWdodHMgPSB7XG4gICAgaW5pdGlhbGl6ZTogNSxcbiAgICBzZXJpYWxpemU6IDQsXG4gICAgYnVpbGQ6IDMsXG4gICAgZmluYWxpemVSZXF1ZXN0OiAyLFxuICAgIGRlc2VyaWFsaXplOiAxLFxufTtcbmNvbnN0IHByaW9yaXR5V2VpZ2h0cyA9IHtcbiAgICBoaWdoOiAzLFxuICAgIG5vcm1hbDogMixcbiAgICBsb3c6IDEsXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@smithy+middleware-stack@3.0.10/node_modules/@smithy/middleware-stack/dist-es/MiddlewareStack.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@smithy+middleware-stack@3.0.10/node_modules/@smithy/middleware-stack/dist-es/index.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@smithy+middleware-stack@3.0.10/node_modules/@smithy/middleware-stack/dist-es/index.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   constructStack: () => (/* reexport safe */ _MiddlewareStack__WEBPACK_IMPORTED_MODULE_0__.constructStack)\n/* harmony export */ });\n/* harmony import */ var _MiddlewareStack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MiddlewareStack */ \"(rsc)/./node_modules/.pnpm/@smithy+middleware-stack@3.0.10/node_modules/@smithy/middleware-stack/dist-es/MiddlewareStack.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNtaXRoeSttaWRkbGV3YXJlLXN0YWNrQDMuMC4xMC9ub2RlX21vZHVsZXMvQHNtaXRoeS9taWRkbGV3YXJlLXN0YWNrL2Rpc3QtZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBa0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9rYXJlbGxlL3ZzY3Byb2plY3RzL3RlY2gtZmxlZXQvdGFpbm8tbGFuZ3VhZ2UtYXBwL2xlc3Nvbi1hdXRob3Jpbmcvbm9kZV9tb2R1bGVzLy5wbnBtL0BzbWl0aHkrbWlkZGxld2FyZS1zdGFja0AzLjAuMTAvbm9kZV9tb2R1bGVzL0BzbWl0aHkvbWlkZGxld2FyZS1zdGFjay9kaXN0LWVzL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gXCIuL01pZGRsZXdhcmVTdGFja1wiO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@smithy+middleware-stack@3.0.10/node_modules/@smithy/middleware-stack/dist-es/index.js\n");

/***/ })

};
;
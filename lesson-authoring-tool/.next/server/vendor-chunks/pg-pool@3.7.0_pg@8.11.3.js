"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pg-pool@3.7.0_pg@8.11.3";
exports.ids = ["vendor-chunks/pg-pool@3.7.0_pg@8.11.3"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/pg-pool@3.7.0_pg@8.11.3/node_modules/pg-pool/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/.pnpm/pg-pool@3.7.0_pg@8.11.3/node_modules/pg-pool/index.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter)\n\nconst NOOP = function () {}\n\nconst removeWhere = (list, predicate) => {\n  const i = list.findIndex(predicate)\n\n  return i === -1 ? undefined : list.splice(i, 1)[0]\n}\n\nclass IdleItem {\n  constructor(client, idleListener, timeoutId) {\n    this.client = client\n    this.idleListener = idleListener\n    this.timeoutId = timeoutId\n  }\n}\n\nclass PendingItem {\n  constructor(callback) {\n    this.callback = callback\n  }\n}\n\nfunction throwOnDoubleRelease() {\n  throw new Error('Release called on client which has already been released to the pool.')\n}\n\nfunction promisify(Promise, callback) {\n  if (callback) {\n    return { callback: callback, result: undefined }\n  }\n  let rej\n  let res\n  const cb = function (err, client) {\n    err ? rej(err) : res(client)\n  }\n  const result = new Promise(function (resolve, reject) {\n    res = resolve\n    rej = reject\n  }).catch((err) => {\n    // replace the stack trace that leads to `TCP.onStreamRead` with one that leads back to the\n    // application that created the query\n    Error.captureStackTrace(err)\n    throw err\n  })\n  return { callback: cb, result: result }\n}\n\nfunction makeIdleListener(pool, client) {\n  return function idleListener(err) {\n    err.client = client\n\n    client.removeListener('error', idleListener)\n    client.on('error', () => {\n      pool.log('additional client error after disconnection due to error', err)\n    })\n    pool._remove(client)\n    // TODO - document that once the pool emits an error\n    // the client has already been closed & purged and is unusable\n    pool.emit('error', err, client)\n  }\n}\n\nclass Pool extends EventEmitter {\n  constructor(options, Client) {\n    super()\n    this.options = Object.assign({}, options)\n\n    if (options != null && 'password' in options) {\n      // \"hiding\" the password so it doesn't show up in stack traces\n      // or if the client is console.logged\n      Object.defineProperty(this.options, 'password', {\n        configurable: true,\n        enumerable: false,\n        writable: true,\n        value: options.password,\n      })\n    }\n    if (options != null && options.ssl && options.ssl.key) {\n      // \"hiding\" the ssl->key so it doesn't show up in stack traces\n      // or if the client is console.logged\n      Object.defineProperty(this.options.ssl, 'key', {\n        enumerable: false,\n      })\n    }\n\n    this.options.max = this.options.max || this.options.poolSize || 10\n    this.options.maxUses = this.options.maxUses || Infinity\n    this.options.allowExitOnIdle = this.options.allowExitOnIdle || false\n    this.options.maxLifetimeSeconds = this.options.maxLifetimeSeconds || 0\n    this.log = this.options.log || function () {}\n    this.Client = this.options.Client || Client || (__webpack_require__(/*! pg */ \"(rsc)/./node_modules/.pnpm/pg@8.11.3/node_modules/pg/lib/index.js\").Client)\n    this.Promise = this.options.Promise || global.Promise\n\n    if (typeof this.options.idleTimeoutMillis === 'undefined') {\n      this.options.idleTimeoutMillis = 10000\n    }\n\n    this._clients = []\n    this._idle = []\n    this._expired = new WeakSet()\n    this._pendingQueue = []\n    this._endCallback = undefined\n    this.ending = false\n    this.ended = false\n  }\n\n  _isFull() {\n    return this._clients.length >= this.options.max\n  }\n\n  _pulseQueue() {\n    this.log('pulse queue')\n    if (this.ended) {\n      this.log('pulse queue ended')\n      return\n    }\n    if (this.ending) {\n      this.log('pulse queue on ending')\n      if (this._idle.length) {\n        this._idle.slice().map((item) => {\n          this._remove(item.client)\n        })\n      }\n      if (!this._clients.length) {\n        this.ended = true\n        this._endCallback()\n      }\n      return\n    }\n\n    // if we don't have any waiting, do nothing\n    if (!this._pendingQueue.length) {\n      this.log('no queued requests')\n      return\n    }\n    // if we don't have any idle clients and we have no more room do nothing\n    if (!this._idle.length && this._isFull()) {\n      return\n    }\n    const pendingItem = this._pendingQueue.shift()\n    if (this._idle.length) {\n      const idleItem = this._idle.pop()\n      clearTimeout(idleItem.timeoutId)\n      const client = idleItem.client\n      client.ref && client.ref()\n      const idleListener = idleItem.idleListener\n\n      return this._acquireClient(client, pendingItem, idleListener, false)\n    }\n    if (!this._isFull()) {\n      return this.newClient(pendingItem)\n    }\n    throw new Error('unexpected condition')\n  }\n\n  _remove(client) {\n    const removed = removeWhere(this._idle, (item) => item.client === client)\n\n    if (removed !== undefined) {\n      clearTimeout(removed.timeoutId)\n    }\n\n    this._clients = this._clients.filter((c) => c !== client)\n    client.end()\n    this.emit('remove', client)\n  }\n\n  connect(cb) {\n    if (this.ending) {\n      const err = new Error('Cannot use a pool after calling end on the pool')\n      return cb ? cb(err) : this.Promise.reject(err)\n    }\n\n    const response = promisify(this.Promise, cb)\n    const result = response.result\n\n    // if we don't have to connect a new client, don't do so\n    if (this._isFull() || this._idle.length) {\n      // if we have idle clients schedule a pulse immediately\n      if (this._idle.length) {\n        process.nextTick(() => this._pulseQueue())\n      }\n\n      if (!this.options.connectionTimeoutMillis) {\n        this._pendingQueue.push(new PendingItem(response.callback))\n        return result\n      }\n\n      const queueCallback = (err, res, done) => {\n        clearTimeout(tid)\n        response.callback(err, res, done)\n      }\n\n      const pendingItem = new PendingItem(queueCallback)\n\n      // set connection timeout on checking out an existing client\n      const tid = setTimeout(() => {\n        // remove the callback from pending waiters because\n        // we're going to call it with a timeout error\n        removeWhere(this._pendingQueue, (i) => i.callback === queueCallback)\n        pendingItem.timedOut = true\n        response.callback(new Error('timeout exceeded when trying to connect'))\n      }, this.options.connectionTimeoutMillis)\n\n      this._pendingQueue.push(pendingItem)\n      return result\n    }\n\n    this.newClient(new PendingItem(response.callback))\n\n    return result\n  }\n\n  newClient(pendingItem) {\n    const client = new this.Client(this.options)\n    this._clients.push(client)\n    const idleListener = makeIdleListener(this, client)\n\n    this.log('checking client timeout')\n\n    // connection timeout logic\n    let tid\n    let timeoutHit = false\n    if (this.options.connectionTimeoutMillis) {\n      tid = setTimeout(() => {\n        this.log('ending client due to timeout')\n        timeoutHit = true\n        // force kill the node driver, and let libpq do its teardown\n        client.connection ? client.connection.stream.destroy() : client.end()\n      }, this.options.connectionTimeoutMillis)\n    }\n\n    this.log('connecting new client')\n    client.connect((err) => {\n      if (tid) {\n        clearTimeout(tid)\n      }\n      client.on('error', idleListener)\n      if (err) {\n        this.log('client failed to connect', err)\n        // remove the dead client from our list of clients\n        this._clients = this._clients.filter((c) => c !== client)\n        if (timeoutHit) {\n          err.message = 'Connection terminated due to connection timeout'\n        }\n\n        // this client wonâ€™t be released, so move on immediately\n        this._pulseQueue()\n\n        if (!pendingItem.timedOut) {\n          pendingItem.callback(err, undefined, NOOP)\n        }\n      } else {\n        this.log('new client connected')\n\n        if (this.options.maxLifetimeSeconds !== 0) {\n          const maxLifetimeTimeout = setTimeout(() => {\n            this.log('ending client due to expired lifetime')\n            this._expired.add(client)\n            const idleIndex = this._idle.findIndex((idleItem) => idleItem.client === client)\n            if (idleIndex !== -1) {\n              this._acquireClient(\n                client,\n                new PendingItem((err, client, clientRelease) => clientRelease()),\n                idleListener,\n                false\n              )\n            }\n          }, this.options.maxLifetimeSeconds * 1000)\n\n          maxLifetimeTimeout.unref()\n          client.once('end', () => clearTimeout(maxLifetimeTimeout))\n        }\n\n        return this._acquireClient(client, pendingItem, idleListener, true)\n      }\n    })\n  }\n\n  // acquire a client for a pending work item\n  _acquireClient(client, pendingItem, idleListener, isNew) {\n    if (isNew) {\n      this.emit('connect', client)\n    }\n\n    this.emit('acquire', client)\n\n    client.release = this._releaseOnce(client, idleListener)\n\n    client.removeListener('error', idleListener)\n\n    if (!pendingItem.timedOut) {\n      if (isNew && this.options.verify) {\n        this.options.verify(client, (err) => {\n          if (err) {\n            client.release(err)\n            return pendingItem.callback(err, undefined, NOOP)\n          }\n\n          pendingItem.callback(undefined, client, client.release)\n        })\n      } else {\n        pendingItem.callback(undefined, client, client.release)\n      }\n    } else {\n      if (isNew && this.options.verify) {\n        this.options.verify(client, client.release)\n      } else {\n        client.release()\n      }\n    }\n  }\n\n  // returns a function that wraps _release and throws if called more than once\n  _releaseOnce(client, idleListener) {\n    let released = false\n\n    return (err) => {\n      if (released) {\n        throwOnDoubleRelease()\n      }\n\n      released = true\n      this._release(client, idleListener, err)\n    }\n  }\n\n  // release a client back to the poll, include an error\n  // to remove it from the pool\n  _release(client, idleListener, err) {\n    client.on('error', idleListener)\n\n    client._poolUseCount = (client._poolUseCount || 0) + 1\n\n    this.emit('release', err, client)\n\n    // TODO(bmc): expose a proper, public interface _queryable and _ending\n    if (err || this.ending || !client._queryable || client._ending || client._poolUseCount >= this.options.maxUses) {\n      if (client._poolUseCount >= this.options.maxUses) {\n        this.log('remove expended client')\n      }\n      this._remove(client)\n      this._pulseQueue()\n      return\n    }\n\n    const isExpired = this._expired.has(client)\n    if (isExpired) {\n      this.log('remove expired client')\n      this._expired.delete(client)\n      this._remove(client)\n      this._pulseQueue()\n      return\n    }\n\n    // idle timeout\n    let tid\n    if (this.options.idleTimeoutMillis) {\n      tid = setTimeout(() => {\n        this.log('remove idle client')\n        this._remove(client)\n      }, this.options.idleTimeoutMillis)\n\n      if (this.options.allowExitOnIdle) {\n        // allow Node to exit if this is all that's left\n        tid.unref()\n      }\n    }\n\n    if (this.options.allowExitOnIdle) {\n      client.unref()\n    }\n\n    this._idle.push(new IdleItem(client, idleListener, tid))\n    this._pulseQueue()\n  }\n\n  query(text, values, cb) {\n    // guard clause against passing a function as the first parameter\n    if (typeof text === 'function') {\n      const response = promisify(this.Promise, text)\n      setImmediate(function () {\n        return response.callback(new Error('Passing a function as the first parameter to pool.query is not supported'))\n      })\n      return response.result\n    }\n\n    // allow plain text query without values\n    if (typeof values === 'function') {\n      cb = values\n      values = undefined\n    }\n    const response = promisify(this.Promise, cb)\n    cb = response.callback\n\n    this.connect((err, client) => {\n      if (err) {\n        return cb(err)\n      }\n\n      let clientReleased = false\n      const onError = (err) => {\n        if (clientReleased) {\n          return\n        }\n        clientReleased = true\n        client.release(err)\n        cb(err)\n      }\n\n      client.once('error', onError)\n      this.log('dispatching query')\n      try {\n        client.query(text, values, (err, res) => {\n          this.log('query dispatched')\n          client.removeListener('error', onError)\n          if (clientReleased) {\n            return\n          }\n          clientReleased = true\n          client.release(err)\n          if (err) {\n            return cb(err)\n          }\n          return cb(undefined, res)\n        })\n      } catch (err) {\n        client.release(err)\n        return cb(err)\n      }\n    })\n    return response.result\n  }\n\n  end(cb) {\n    this.log('ending')\n    if (this.ending) {\n      const err = new Error('Called end on pool more than once')\n      return cb ? cb(err) : this.Promise.reject(err)\n    }\n    this.ending = true\n    const promised = promisify(this.Promise, cb)\n    this._endCallback = promised.callback\n    this._pulseQueue()\n    return promised.result\n  }\n\n  get waitingCount() {\n    return this._pendingQueue.length\n  }\n\n  get idleCount() {\n    return this._idle.length\n  }\n\n  get expiredCount() {\n    return this._clients.reduce((acc, client) => acc + (this._expired.has(client) ? 1 : 0), 0)\n  }\n\n  get totalCount() {\n    return this._clients.length\n  }\n}\nmodule.exports = Pool\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vcGctcG9vbEAzLjcuMF9wZ0A4LjExLjMvbm9kZV9tb2R1bGVzL3BnLXBvb2wvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWixxQkFBcUIsMERBQThCOztBQUVuRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCwyR0FBb0I7QUFDdkU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMva2FyZWxsZS92c2Nwcm9qZWN0cy90ZWNoLWZsZWV0L3RhaW5vLWxhbmd1YWdlLWFwcC9sZXNzb24tYXV0aG9yaW5nL25vZGVfbW9kdWxlcy8ucG5wbS9wZy1wb29sQDMuNy4wX3BnQDguMTEuMy9ub2RlX21vZHVsZXMvcGctcG9vbC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuXG5jb25zdCBOT09QID0gZnVuY3Rpb24gKCkge31cblxuY29uc3QgcmVtb3ZlV2hlcmUgPSAobGlzdCwgcHJlZGljYXRlKSA9PiB7XG4gIGNvbnN0IGkgPSBsaXN0LmZpbmRJbmRleChwcmVkaWNhdGUpXG5cbiAgcmV0dXJuIGkgPT09IC0xID8gdW5kZWZpbmVkIDogbGlzdC5zcGxpY2UoaSwgMSlbMF1cbn1cblxuY2xhc3MgSWRsZUl0ZW0ge1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIGlkbGVMaXN0ZW5lciwgdGltZW91dElkKSB7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnRcbiAgICB0aGlzLmlkbGVMaXN0ZW5lciA9IGlkbGVMaXN0ZW5lclxuICAgIHRoaXMudGltZW91dElkID0gdGltZW91dElkXG4gIH1cbn1cblxuY2xhc3MgUGVuZGluZ0l0ZW0ge1xuICBjb25zdHJ1Y3RvcihjYWxsYmFjaykge1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFja1xuICB9XG59XG5cbmZ1bmN0aW9uIHRocm93T25Eb3VibGVSZWxlYXNlKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1JlbGVhc2UgY2FsbGVkIG9uIGNsaWVudCB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIHJlbGVhc2VkIHRvIHRoZSBwb29sLicpXG59XG5cbmZ1bmN0aW9uIHByb21pc2lmeShQcm9taXNlLCBjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2spIHtcbiAgICByZXR1cm4geyBjYWxsYmFjazogY2FsbGJhY2ssIHJlc3VsdDogdW5kZWZpbmVkIH1cbiAgfVxuICBsZXQgcmVqXG4gIGxldCByZXNcbiAgY29uc3QgY2IgPSBmdW5jdGlvbiAoZXJyLCBjbGllbnQpIHtcbiAgICBlcnIgPyByZWooZXJyKSA6IHJlcyhjbGllbnQpXG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHJlcyA9IHJlc29sdmVcbiAgICByZWogPSByZWplY3RcbiAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgIC8vIHJlcGxhY2UgdGhlIHN0YWNrIHRyYWNlIHRoYXQgbGVhZHMgdG8gYFRDUC5vblN0cmVhbVJlYWRgIHdpdGggb25lIHRoYXQgbGVhZHMgYmFjayB0byB0aGVcbiAgICAvLyBhcHBsaWNhdGlvbiB0aGF0IGNyZWF0ZWQgdGhlIHF1ZXJ5XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyKVxuICAgIHRocm93IGVyclxuICB9KVxuICByZXR1cm4geyBjYWxsYmFjazogY2IsIHJlc3VsdDogcmVzdWx0IH1cbn1cblxuZnVuY3Rpb24gbWFrZUlkbGVMaXN0ZW5lcihwb29sLCBjbGllbnQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGlkbGVMaXN0ZW5lcihlcnIpIHtcbiAgICBlcnIuY2xpZW50ID0gY2xpZW50XG5cbiAgICBjbGllbnQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgaWRsZUxpc3RlbmVyKVxuICAgIGNsaWVudC5vbignZXJyb3InLCAoKSA9PiB7XG4gICAgICBwb29sLmxvZygnYWRkaXRpb25hbCBjbGllbnQgZXJyb3IgYWZ0ZXIgZGlzY29ubmVjdGlvbiBkdWUgdG8gZXJyb3InLCBlcnIpXG4gICAgfSlcbiAgICBwb29sLl9yZW1vdmUoY2xpZW50KVxuICAgIC8vIFRPRE8gLSBkb2N1bWVudCB0aGF0IG9uY2UgdGhlIHBvb2wgZW1pdHMgYW4gZXJyb3JcbiAgICAvLyB0aGUgY2xpZW50IGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkICYgcHVyZ2VkIGFuZCBpcyB1bnVzYWJsZVxuICAgIHBvb2wuZW1pdCgnZXJyb3InLCBlcnIsIGNsaWVudClcbiAgfVxufVxuXG5jbGFzcyBQb29sIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucywgQ2xpZW50KSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpXG5cbiAgICBpZiAob3B0aW9ucyAhPSBudWxsICYmICdwYXNzd29yZCcgaW4gb3B0aW9ucykge1xuICAgICAgLy8gXCJoaWRpbmdcIiB0aGUgcGFzc3dvcmQgc28gaXQgZG9lc24ndCBzaG93IHVwIGluIHN0YWNrIHRyYWNlc1xuICAgICAgLy8gb3IgaWYgdGhlIGNsaWVudCBpcyBjb25zb2xlLmxvZ2dlZFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMub3B0aW9ucywgJ3Bhc3N3b3JkJywge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IG9wdGlvbnMucGFzc3dvcmQsXG4gICAgICB9KVxuICAgIH1cbiAgICBpZiAob3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuc3NsICYmIG9wdGlvbnMuc3NsLmtleSkge1xuICAgICAgLy8gXCJoaWRpbmdcIiB0aGUgc3NsLT5rZXkgc28gaXQgZG9lc24ndCBzaG93IHVwIGluIHN0YWNrIHRyYWNlc1xuICAgICAgLy8gb3IgaWYgdGhlIGNsaWVudCBpcyBjb25zb2xlLmxvZ2dlZFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMub3B0aW9ucy5zc2wsICdrZXknLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMubWF4ID0gdGhpcy5vcHRpb25zLm1heCB8fCB0aGlzLm9wdGlvbnMucG9vbFNpemUgfHwgMTBcbiAgICB0aGlzLm9wdGlvbnMubWF4VXNlcyA9IHRoaXMub3B0aW9ucy5tYXhVc2VzIHx8IEluZmluaXR5XG4gICAgdGhpcy5vcHRpb25zLmFsbG93RXhpdE9uSWRsZSA9IHRoaXMub3B0aW9ucy5hbGxvd0V4aXRPbklkbGUgfHwgZmFsc2VcbiAgICB0aGlzLm9wdGlvbnMubWF4TGlmZXRpbWVTZWNvbmRzID0gdGhpcy5vcHRpb25zLm1heExpZmV0aW1lU2Vjb25kcyB8fCAwXG4gICAgdGhpcy5sb2cgPSB0aGlzLm9wdGlvbnMubG9nIHx8IGZ1bmN0aW9uICgpIHt9XG4gICAgdGhpcy5DbGllbnQgPSB0aGlzLm9wdGlvbnMuQ2xpZW50IHx8IENsaWVudCB8fCByZXF1aXJlKCdwZycpLkNsaWVudFxuICAgIHRoaXMuUHJvbWlzZSA9IHRoaXMub3B0aW9ucy5Qcm9taXNlIHx8IGdsb2JhbC5Qcm9taXNlXG5cbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5pZGxlVGltZW91dE1pbGxpcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5pZGxlVGltZW91dE1pbGxpcyA9IDEwMDAwXG4gICAgfVxuXG4gICAgdGhpcy5fY2xpZW50cyA9IFtdXG4gICAgdGhpcy5faWRsZSA9IFtdXG4gICAgdGhpcy5fZXhwaXJlZCA9IG5ldyBXZWFrU2V0KClcbiAgICB0aGlzLl9wZW5kaW5nUXVldWUgPSBbXVxuICAgIHRoaXMuX2VuZENhbGxiYWNrID0gdW5kZWZpbmVkXG4gICAgdGhpcy5lbmRpbmcgPSBmYWxzZVxuICAgIHRoaXMuZW5kZWQgPSBmYWxzZVxuICB9XG5cbiAgX2lzRnVsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50cy5sZW5ndGggPj0gdGhpcy5vcHRpb25zLm1heFxuICB9XG5cbiAgX3B1bHNlUXVldWUoKSB7XG4gICAgdGhpcy5sb2coJ3B1bHNlIHF1ZXVlJylcbiAgICBpZiAodGhpcy5lbmRlZCkge1xuICAgICAgdGhpcy5sb2coJ3B1bHNlIHF1ZXVlIGVuZGVkJylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAodGhpcy5lbmRpbmcpIHtcbiAgICAgIHRoaXMubG9nKCdwdWxzZSBxdWV1ZSBvbiBlbmRpbmcnKVxuICAgICAgaWYgKHRoaXMuX2lkbGUubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX2lkbGUuc2xpY2UoKS5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICB0aGlzLl9yZW1vdmUoaXRlbS5jbGllbnQpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX2NsaWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuZW5kZWQgPSB0cnVlXG4gICAgICAgIHRoaXMuX2VuZENhbGxiYWNrKClcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGlmIHdlIGRvbid0IGhhdmUgYW55IHdhaXRpbmcsIGRvIG5vdGhpbmdcbiAgICBpZiAoIXRoaXMuX3BlbmRpbmdRdWV1ZS5sZW5ndGgpIHtcbiAgICAgIHRoaXMubG9nKCdubyBxdWV1ZWQgcmVxdWVzdHMnKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIGlmIHdlIGRvbid0IGhhdmUgYW55IGlkbGUgY2xpZW50cyBhbmQgd2UgaGF2ZSBubyBtb3JlIHJvb20gZG8gbm90aGluZ1xuICAgIGlmICghdGhpcy5faWRsZS5sZW5ndGggJiYgdGhpcy5faXNGdWxsKCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nSXRlbSA9IHRoaXMuX3BlbmRpbmdRdWV1ZS5zaGlmdCgpXG4gICAgaWYgKHRoaXMuX2lkbGUubGVuZ3RoKSB7XG4gICAgICBjb25zdCBpZGxlSXRlbSA9IHRoaXMuX2lkbGUucG9wKClcbiAgICAgIGNsZWFyVGltZW91dChpZGxlSXRlbS50aW1lb3V0SWQpXG4gICAgICBjb25zdCBjbGllbnQgPSBpZGxlSXRlbS5jbGllbnRcbiAgICAgIGNsaWVudC5yZWYgJiYgY2xpZW50LnJlZigpXG4gICAgICBjb25zdCBpZGxlTGlzdGVuZXIgPSBpZGxlSXRlbS5pZGxlTGlzdGVuZXJcblxuICAgICAgcmV0dXJuIHRoaXMuX2FjcXVpcmVDbGllbnQoY2xpZW50LCBwZW5kaW5nSXRlbSwgaWRsZUxpc3RlbmVyLCBmYWxzZSlcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9pc0Z1bGwoKSkge1xuICAgICAgcmV0dXJuIHRoaXMubmV3Q2xpZW50KHBlbmRpbmdJdGVtKVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgY29uZGl0aW9uJylcbiAgfVxuXG4gIF9yZW1vdmUoY2xpZW50KSB7XG4gICAgY29uc3QgcmVtb3ZlZCA9IHJlbW92ZVdoZXJlKHRoaXMuX2lkbGUsIChpdGVtKSA9PiBpdGVtLmNsaWVudCA9PT0gY2xpZW50KVxuXG4gICAgaWYgKHJlbW92ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHJlbW92ZWQudGltZW91dElkKVxuICAgIH1cblxuICAgIHRoaXMuX2NsaWVudHMgPSB0aGlzLl9jbGllbnRzLmZpbHRlcigoYykgPT4gYyAhPT0gY2xpZW50KVxuICAgIGNsaWVudC5lbmQoKVxuICAgIHRoaXMuZW1pdCgncmVtb3ZlJywgY2xpZW50KVxuICB9XG5cbiAgY29ubmVjdChjYikge1xuICAgIGlmICh0aGlzLmVuZGluZykge1xuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdDYW5ub3QgdXNlIGEgcG9vbCBhZnRlciBjYWxsaW5nIGVuZCBvbiB0aGUgcG9vbCcpXG4gICAgICByZXR1cm4gY2IgPyBjYihlcnIpIDogdGhpcy5Qcm9taXNlLnJlamVjdChlcnIpXG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBwcm9taXNpZnkodGhpcy5Qcm9taXNlLCBjYilcbiAgICBjb25zdCByZXN1bHQgPSByZXNwb25zZS5yZXN1bHRcblxuICAgIC8vIGlmIHdlIGRvbid0IGhhdmUgdG8gY29ubmVjdCBhIG5ldyBjbGllbnQsIGRvbid0IGRvIHNvXG4gICAgaWYgKHRoaXMuX2lzRnVsbCgpIHx8IHRoaXMuX2lkbGUubGVuZ3RoKSB7XG4gICAgICAvLyBpZiB3ZSBoYXZlIGlkbGUgY2xpZW50cyBzY2hlZHVsZSBhIHB1bHNlIGltbWVkaWF0ZWx5XG4gICAgICBpZiAodGhpcy5faWRsZS5sZW5ndGgpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB0aGlzLl9wdWxzZVF1ZXVlKCkpXG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmNvbm5lY3Rpb25UaW1lb3V0TWlsbGlzKSB7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdRdWV1ZS5wdXNoKG5ldyBQZW5kaW5nSXRlbShyZXNwb25zZS5jYWxsYmFjaykpXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cblxuICAgICAgY29uc3QgcXVldWVDYWxsYmFjayA9IChlcnIsIHJlcywgZG9uZSkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGlkKVxuICAgICAgICByZXNwb25zZS5jYWxsYmFjayhlcnIsIHJlcywgZG9uZSlcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGVuZGluZ0l0ZW0gPSBuZXcgUGVuZGluZ0l0ZW0ocXVldWVDYWxsYmFjaylcblxuICAgICAgLy8gc2V0IGNvbm5lY3Rpb24gdGltZW91dCBvbiBjaGVja2luZyBvdXQgYW4gZXhpc3RpbmcgY2xpZW50XG4gICAgICBjb25zdCB0aWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBjYWxsYmFjayBmcm9tIHBlbmRpbmcgd2FpdGVycyBiZWNhdXNlXG4gICAgICAgIC8vIHdlJ3JlIGdvaW5nIHRvIGNhbGwgaXQgd2l0aCBhIHRpbWVvdXQgZXJyb3JcbiAgICAgICAgcmVtb3ZlV2hlcmUodGhpcy5fcGVuZGluZ1F1ZXVlLCAoaSkgPT4gaS5jYWxsYmFjayA9PT0gcXVldWVDYWxsYmFjaylcbiAgICAgICAgcGVuZGluZ0l0ZW0udGltZWRPdXQgPSB0cnVlXG4gICAgICAgIHJlc3BvbnNlLmNhbGxiYWNrKG5ldyBFcnJvcigndGltZW91dCBleGNlZWRlZCB3aGVuIHRyeWluZyB0byBjb25uZWN0JykpXG4gICAgICB9LCB0aGlzLm9wdGlvbnMuY29ubmVjdGlvblRpbWVvdXRNaWxsaXMpXG5cbiAgICAgIHRoaXMuX3BlbmRpbmdRdWV1ZS5wdXNoKHBlbmRpbmdJdGVtKVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cblxuICAgIHRoaXMubmV3Q2xpZW50KG5ldyBQZW5kaW5nSXRlbShyZXNwb25zZS5jYWxsYmFjaykpXG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBuZXdDbGllbnQocGVuZGluZ0l0ZW0pIHtcbiAgICBjb25zdCBjbGllbnQgPSBuZXcgdGhpcy5DbGllbnQodGhpcy5vcHRpb25zKVxuICAgIHRoaXMuX2NsaWVudHMucHVzaChjbGllbnQpXG4gICAgY29uc3QgaWRsZUxpc3RlbmVyID0gbWFrZUlkbGVMaXN0ZW5lcih0aGlzLCBjbGllbnQpXG5cbiAgICB0aGlzLmxvZygnY2hlY2tpbmcgY2xpZW50IHRpbWVvdXQnKVxuXG4gICAgLy8gY29ubmVjdGlvbiB0aW1lb3V0IGxvZ2ljXG4gICAgbGV0IHRpZFxuICAgIGxldCB0aW1lb3V0SGl0ID0gZmFsc2VcbiAgICBpZiAodGhpcy5vcHRpb25zLmNvbm5lY3Rpb25UaW1lb3V0TWlsbGlzKSB7XG4gICAgICB0aWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5sb2coJ2VuZGluZyBjbGllbnQgZHVlIHRvIHRpbWVvdXQnKVxuICAgICAgICB0aW1lb3V0SGl0ID0gdHJ1ZVxuICAgICAgICAvLyBmb3JjZSBraWxsIHRoZSBub2RlIGRyaXZlciwgYW5kIGxldCBsaWJwcSBkbyBpdHMgdGVhcmRvd25cbiAgICAgICAgY2xpZW50LmNvbm5lY3Rpb24gPyBjbGllbnQuY29ubmVjdGlvbi5zdHJlYW0uZGVzdHJveSgpIDogY2xpZW50LmVuZCgpXG4gICAgICB9LCB0aGlzLm9wdGlvbnMuY29ubmVjdGlvblRpbWVvdXRNaWxsaXMpXG4gICAgfVxuXG4gICAgdGhpcy5sb2coJ2Nvbm5lY3RpbmcgbmV3IGNsaWVudCcpXG4gICAgY2xpZW50LmNvbm5lY3QoKGVycikgPT4ge1xuICAgICAgaWYgKHRpZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGlkKVxuICAgICAgfVxuICAgICAgY2xpZW50Lm9uKCdlcnJvcicsIGlkbGVMaXN0ZW5lcilcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhpcy5sb2coJ2NsaWVudCBmYWlsZWQgdG8gY29ubmVjdCcsIGVycilcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBkZWFkIGNsaWVudCBmcm9tIG91ciBsaXN0IG9mIGNsaWVudHNcbiAgICAgICAgdGhpcy5fY2xpZW50cyA9IHRoaXMuX2NsaWVudHMuZmlsdGVyKChjKSA9PiBjICE9PSBjbGllbnQpXG4gICAgICAgIGlmICh0aW1lb3V0SGl0KSB7XG4gICAgICAgICAgZXJyLm1lc3NhZ2UgPSAnQ29ubmVjdGlvbiB0ZXJtaW5hdGVkIGR1ZSB0byBjb25uZWN0aW9uIHRpbWVvdXQnXG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGlzIGNsaWVudCB3b27igJl0IGJlIHJlbGVhc2VkLCBzbyBtb3ZlIG9uIGltbWVkaWF0ZWx5XG4gICAgICAgIHRoaXMuX3B1bHNlUXVldWUoKVxuXG4gICAgICAgIGlmICghcGVuZGluZ0l0ZW0udGltZWRPdXQpIHtcbiAgICAgICAgICBwZW5kaW5nSXRlbS5jYWxsYmFjayhlcnIsIHVuZGVmaW5lZCwgTk9PUClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sb2coJ25ldyBjbGllbnQgY29ubmVjdGVkJylcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1heExpZmV0aW1lU2Vjb25kcyAhPT0gMCkge1xuICAgICAgICAgIGNvbnN0IG1heExpZmV0aW1lVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2coJ2VuZGluZyBjbGllbnQgZHVlIHRvIGV4cGlyZWQgbGlmZXRpbWUnKVxuICAgICAgICAgICAgdGhpcy5fZXhwaXJlZC5hZGQoY2xpZW50KVxuICAgICAgICAgICAgY29uc3QgaWRsZUluZGV4ID0gdGhpcy5faWRsZS5maW5kSW5kZXgoKGlkbGVJdGVtKSA9PiBpZGxlSXRlbS5jbGllbnQgPT09IGNsaWVudClcbiAgICAgICAgICAgIGlmIChpZGxlSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2FjcXVpcmVDbGllbnQoXG4gICAgICAgICAgICAgICAgY2xpZW50LFxuICAgICAgICAgICAgICAgIG5ldyBQZW5kaW5nSXRlbSgoZXJyLCBjbGllbnQsIGNsaWVudFJlbGVhc2UpID0+IGNsaWVudFJlbGVhc2UoKSksXG4gICAgICAgICAgICAgICAgaWRsZUxpc3RlbmVyLFxuICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0aGlzLm9wdGlvbnMubWF4TGlmZXRpbWVTZWNvbmRzICogMTAwMClcblxuICAgICAgICAgIG1heExpZmV0aW1lVGltZW91dC51bnJlZigpXG4gICAgICAgICAgY2xpZW50Lm9uY2UoJ2VuZCcsICgpID0+IGNsZWFyVGltZW91dChtYXhMaWZldGltZVRpbWVvdXQpKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjcXVpcmVDbGllbnQoY2xpZW50LCBwZW5kaW5nSXRlbSwgaWRsZUxpc3RlbmVyLCB0cnVlKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvLyBhY3F1aXJlIGEgY2xpZW50IGZvciBhIHBlbmRpbmcgd29yayBpdGVtXG4gIF9hY3F1aXJlQ2xpZW50KGNsaWVudCwgcGVuZGluZ0l0ZW0sIGlkbGVMaXN0ZW5lciwgaXNOZXcpIHtcbiAgICBpZiAoaXNOZXcpIHtcbiAgICAgIHRoaXMuZW1pdCgnY29ubmVjdCcsIGNsaWVudClcbiAgICB9XG5cbiAgICB0aGlzLmVtaXQoJ2FjcXVpcmUnLCBjbGllbnQpXG5cbiAgICBjbGllbnQucmVsZWFzZSA9IHRoaXMuX3JlbGVhc2VPbmNlKGNsaWVudCwgaWRsZUxpc3RlbmVyKVxuXG4gICAgY2xpZW50LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGlkbGVMaXN0ZW5lcilcblxuICAgIGlmICghcGVuZGluZ0l0ZW0udGltZWRPdXQpIHtcbiAgICAgIGlmIChpc05ldyAmJiB0aGlzLm9wdGlvbnMudmVyaWZ5KSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy52ZXJpZnkoY2xpZW50LCAoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgY2xpZW50LnJlbGVhc2UoZXJyKVxuICAgICAgICAgICAgcmV0dXJuIHBlbmRpbmdJdGVtLmNhbGxiYWNrKGVyciwgdW5kZWZpbmVkLCBOT09QKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHBlbmRpbmdJdGVtLmNhbGxiYWNrKHVuZGVmaW5lZCwgY2xpZW50LCBjbGllbnQucmVsZWFzZSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlbmRpbmdJdGVtLmNhbGxiYWNrKHVuZGVmaW5lZCwgY2xpZW50LCBjbGllbnQucmVsZWFzZSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzTmV3ICYmIHRoaXMub3B0aW9ucy52ZXJpZnkpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnZlcmlmeShjbGllbnQsIGNsaWVudC5yZWxlYXNlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xpZW50LnJlbGVhc2UoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIF9yZWxlYXNlIGFuZCB0aHJvd3MgaWYgY2FsbGVkIG1vcmUgdGhhbiBvbmNlXG4gIF9yZWxlYXNlT25jZShjbGllbnQsIGlkbGVMaXN0ZW5lcikge1xuICAgIGxldCByZWxlYXNlZCA9IGZhbHNlXG5cbiAgICByZXR1cm4gKGVycikgPT4ge1xuICAgICAgaWYgKHJlbGVhc2VkKSB7XG4gICAgICAgIHRocm93T25Eb3VibGVSZWxlYXNlKClcbiAgICAgIH1cblxuICAgICAgcmVsZWFzZWQgPSB0cnVlXG4gICAgICB0aGlzLl9yZWxlYXNlKGNsaWVudCwgaWRsZUxpc3RlbmVyLCBlcnIpXG4gICAgfVxuICB9XG5cbiAgLy8gcmVsZWFzZSBhIGNsaWVudCBiYWNrIHRvIHRoZSBwb2xsLCBpbmNsdWRlIGFuIGVycm9yXG4gIC8vIHRvIHJlbW92ZSBpdCBmcm9tIHRoZSBwb29sXG4gIF9yZWxlYXNlKGNsaWVudCwgaWRsZUxpc3RlbmVyLCBlcnIpIHtcbiAgICBjbGllbnQub24oJ2Vycm9yJywgaWRsZUxpc3RlbmVyKVxuXG4gICAgY2xpZW50Ll9wb29sVXNlQ291bnQgPSAoY2xpZW50Ll9wb29sVXNlQ291bnQgfHwgMCkgKyAxXG5cbiAgICB0aGlzLmVtaXQoJ3JlbGVhc2UnLCBlcnIsIGNsaWVudClcblxuICAgIC8vIFRPRE8oYm1jKTogZXhwb3NlIGEgcHJvcGVyLCBwdWJsaWMgaW50ZXJmYWNlIF9xdWVyeWFibGUgYW5kIF9lbmRpbmdcbiAgICBpZiAoZXJyIHx8IHRoaXMuZW5kaW5nIHx8ICFjbGllbnQuX3F1ZXJ5YWJsZSB8fCBjbGllbnQuX2VuZGluZyB8fCBjbGllbnQuX3Bvb2xVc2VDb3VudCA+PSB0aGlzLm9wdGlvbnMubWF4VXNlcykge1xuICAgICAgaWYgKGNsaWVudC5fcG9vbFVzZUNvdW50ID49IHRoaXMub3B0aW9ucy5tYXhVc2VzKSB7XG4gICAgICAgIHRoaXMubG9nKCdyZW1vdmUgZXhwZW5kZWQgY2xpZW50JylcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlbW92ZShjbGllbnQpXG4gICAgICB0aGlzLl9wdWxzZVF1ZXVlKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGlzRXhwaXJlZCA9IHRoaXMuX2V4cGlyZWQuaGFzKGNsaWVudClcbiAgICBpZiAoaXNFeHBpcmVkKSB7XG4gICAgICB0aGlzLmxvZygncmVtb3ZlIGV4cGlyZWQgY2xpZW50JylcbiAgICAgIHRoaXMuX2V4cGlyZWQuZGVsZXRlKGNsaWVudClcbiAgICAgIHRoaXMuX3JlbW92ZShjbGllbnQpXG4gICAgICB0aGlzLl9wdWxzZVF1ZXVlKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGlkbGUgdGltZW91dFxuICAgIGxldCB0aWRcbiAgICBpZiAodGhpcy5vcHRpb25zLmlkbGVUaW1lb3V0TWlsbGlzKSB7XG4gICAgICB0aWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5sb2coJ3JlbW92ZSBpZGxlIGNsaWVudCcpXG4gICAgICAgIHRoaXMuX3JlbW92ZShjbGllbnQpXG4gICAgICB9LCB0aGlzLm9wdGlvbnMuaWRsZVRpbWVvdXRNaWxsaXMpXG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWxsb3dFeGl0T25JZGxlKSB7XG4gICAgICAgIC8vIGFsbG93IE5vZGUgdG8gZXhpdCBpZiB0aGlzIGlzIGFsbCB0aGF0J3MgbGVmdFxuICAgICAgICB0aWQudW5yZWYoKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuYWxsb3dFeGl0T25JZGxlKSB7XG4gICAgICBjbGllbnQudW5yZWYoKVxuICAgIH1cblxuICAgIHRoaXMuX2lkbGUucHVzaChuZXcgSWRsZUl0ZW0oY2xpZW50LCBpZGxlTGlzdGVuZXIsIHRpZCkpXG4gICAgdGhpcy5fcHVsc2VRdWV1ZSgpXG4gIH1cblxuICBxdWVyeSh0ZXh0LCB2YWx1ZXMsIGNiKSB7XG4gICAgLy8gZ3VhcmQgY2xhdXNlIGFnYWluc3QgcGFzc2luZyBhIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXJcbiAgICBpZiAodHlwZW9mIHRleHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gcHJvbWlzaWZ5KHRoaXMuUHJvbWlzZSwgdGV4dClcbiAgICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5jYWxsYmFjayhuZXcgRXJyb3IoJ1Bhc3NpbmcgYSBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyIHRvIHBvb2wucXVlcnkgaXMgbm90IHN1cHBvcnRlZCcpKVxuICAgICAgfSlcbiAgICAgIHJldHVybiByZXNwb25zZS5yZXN1bHRcbiAgICB9XG5cbiAgICAvLyBhbGxvdyBwbGFpbiB0ZXh0IHF1ZXJ5IHdpdGhvdXQgdmFsdWVzXG4gICAgaWYgKHR5cGVvZiB2YWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gdmFsdWVzXG4gICAgICB2YWx1ZXMgPSB1bmRlZmluZWRcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBwcm9taXNpZnkodGhpcy5Qcm9taXNlLCBjYilcbiAgICBjYiA9IHJlc3BvbnNlLmNhbGxiYWNrXG5cbiAgICB0aGlzLmNvbm5lY3QoKGVyciwgY2xpZW50KSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICB9XG5cbiAgICAgIGxldCBjbGllbnRSZWxlYXNlZCA9IGZhbHNlXG4gICAgICBjb25zdCBvbkVycm9yID0gKGVycikgPT4ge1xuICAgICAgICBpZiAoY2xpZW50UmVsZWFzZWQpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBjbGllbnRSZWxlYXNlZCA9IHRydWVcbiAgICAgICAgY2xpZW50LnJlbGVhc2UoZXJyKVxuICAgICAgICBjYihlcnIpXG4gICAgICB9XG5cbiAgICAgIGNsaWVudC5vbmNlKCdlcnJvcicsIG9uRXJyb3IpXG4gICAgICB0aGlzLmxvZygnZGlzcGF0Y2hpbmcgcXVlcnknKVxuICAgICAgdHJ5IHtcbiAgICAgICAgY2xpZW50LnF1ZXJ5KHRleHQsIHZhbHVlcywgKGVyciwgcmVzKSA9PiB7XG4gICAgICAgICAgdGhpcy5sb2coJ3F1ZXJ5IGRpc3BhdGNoZWQnKVxuICAgICAgICAgIGNsaWVudC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKVxuICAgICAgICAgIGlmIChjbGllbnRSZWxlYXNlZCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIGNsaWVudFJlbGVhc2VkID0gdHJ1ZVxuICAgICAgICAgIGNsaWVudC5yZWxlYXNlKGVycilcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2IoZXJyKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2IodW5kZWZpbmVkLCByZXMpXG4gICAgICAgIH0pXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY2xpZW50LnJlbGVhc2UoZXJyKVxuICAgICAgICByZXR1cm4gY2IoZXJyKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHJlc3BvbnNlLnJlc3VsdFxuICB9XG5cbiAgZW5kKGNiKSB7XG4gICAgdGhpcy5sb2coJ2VuZGluZycpXG4gICAgaWYgKHRoaXMuZW5kaW5nKSB7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ0NhbGxlZCBlbmQgb24gcG9vbCBtb3JlIHRoYW4gb25jZScpXG4gICAgICByZXR1cm4gY2IgPyBjYihlcnIpIDogdGhpcy5Qcm9taXNlLnJlamVjdChlcnIpXG4gICAgfVxuICAgIHRoaXMuZW5kaW5nID0gdHJ1ZVxuICAgIGNvbnN0IHByb21pc2VkID0gcHJvbWlzaWZ5KHRoaXMuUHJvbWlzZSwgY2IpXG4gICAgdGhpcy5fZW5kQ2FsbGJhY2sgPSBwcm9taXNlZC5jYWxsYmFja1xuICAgIHRoaXMuX3B1bHNlUXVldWUoKVxuICAgIHJldHVybiBwcm9taXNlZC5yZXN1bHRcbiAgfVxuXG4gIGdldCB3YWl0aW5nQ291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdRdWV1ZS5sZW5ndGhcbiAgfVxuXG4gIGdldCBpZGxlQ291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lkbGUubGVuZ3RoXG4gIH1cblxuICBnZXQgZXhwaXJlZENvdW50KCkge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnRzLnJlZHVjZSgoYWNjLCBjbGllbnQpID0+IGFjYyArICh0aGlzLl9leHBpcmVkLmhhcyhjbGllbnQpID8gMSA6IDApLCAwKVxuICB9XG5cbiAgZ2V0IHRvdGFsQ291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudHMubGVuZ3RoXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gUG9vbFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/pg-pool@3.7.0_pg@8.11.3/node_modules/pg-pool/index.js\n");

/***/ })

};
;
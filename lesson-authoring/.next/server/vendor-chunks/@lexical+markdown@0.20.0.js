"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lexical+markdown@0.20.0";
exports.ids = ["vendor-chunks/@lexical+markdown@0.20.0"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/@lexical+markdown@0.20.0/node_modules/@lexical/markdown/LexicalMarkdown.dev.mjs":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@lexical+markdown@0.20.0/node_modules/@lexical/markdown/LexicalMarkdown.dev.mjs ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $convertFromMarkdownString: () => (/* binding */ $convertFromMarkdownString),\n/* harmony export */   $convertToMarkdownString: () => (/* binding */ $convertToMarkdownString),\n/* harmony export */   BOLD_ITALIC_STAR: () => (/* binding */ BOLD_ITALIC_STAR),\n/* harmony export */   BOLD_ITALIC_UNDERSCORE: () => (/* binding */ BOLD_ITALIC_UNDERSCORE),\n/* harmony export */   BOLD_STAR: () => (/* binding */ BOLD_STAR),\n/* harmony export */   BOLD_UNDERSCORE: () => (/* binding */ BOLD_UNDERSCORE),\n/* harmony export */   CHECK_LIST: () => (/* binding */ CHECK_LIST),\n/* harmony export */   CODE: () => (/* binding */ CODE),\n/* harmony export */   ELEMENT_TRANSFORMERS: () => (/* binding */ ELEMENT_TRANSFORMERS),\n/* harmony export */   HEADING: () => (/* binding */ HEADING),\n/* harmony export */   HIGHLIGHT: () => (/* binding */ HIGHLIGHT),\n/* harmony export */   INLINE_CODE: () => (/* binding */ INLINE_CODE),\n/* harmony export */   ITALIC_STAR: () => (/* binding */ ITALIC_STAR),\n/* harmony export */   ITALIC_UNDERSCORE: () => (/* binding */ ITALIC_UNDERSCORE),\n/* harmony export */   LINK: () => (/* binding */ LINK),\n/* harmony export */   MULTILINE_ELEMENT_TRANSFORMERS: () => (/* binding */ MULTILINE_ELEMENT_TRANSFORMERS),\n/* harmony export */   ORDERED_LIST: () => (/* binding */ ORDERED_LIST),\n/* harmony export */   QUOTE: () => (/* binding */ QUOTE),\n/* harmony export */   STRIKETHROUGH: () => (/* binding */ STRIKETHROUGH),\n/* harmony export */   TEXT_FORMAT_TRANSFORMERS: () => (/* binding */ TEXT_FORMAT_TRANSFORMERS),\n/* harmony export */   TEXT_MATCH_TRANSFORMERS: () => (/* binding */ TEXT_MATCH_TRANSFORMERS),\n/* harmony export */   TRANSFORMERS: () => (/* binding */ TRANSFORMERS),\n/* harmony export */   UNORDERED_LIST: () => (/* binding */ UNORDERED_LIST),\n/* harmony export */   registerMarkdownShortcuts: () => (/* binding */ registerMarkdownShortcuts)\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lexical */ \"(rsc)/./node_modules/.pnpm/lexical@0.20.0/node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var _lexical_list__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/list */ \"(rsc)/./node_modules/.pnpm/@lexical+list@0.20.0/node_modules/@lexical/list/LexicalList.dev.mjs\");\n/* harmony import */ var _lexical_rich_text__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/rich-text */ \"(rsc)/./node_modules/.pnpm/@lexical+rich-text@0.20.0/node_modules/@lexical/rich-text/LexicalRichText.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lexical/utils */ \"(rsc)/./node_modules/.pnpm/@lexical+utils@0.20.0/node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var _lexical_code__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lexical/code */ \"(rsc)/./node_modules/.pnpm/@lexical+code@0.20.0/node_modules/@lexical/code/LexicalCode.dev.mjs\");\n/* harmony import */ var _lexical_link__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lexical/link */ \"(rsc)/./node_modules/.pnpm/@lexical+link@0.20.0/node_modules/@lexical/link/LexicalLink.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction indexBy(list, callback) {\n  const index = {};\n  for (const item of list) {\n    const key = callback(item);\n    if (!key) {\n      continue;\n    }\n    if (index[key]) {\n      index[key].push(item);\n    } else {\n      index[key] = [item];\n    }\n  }\n  return index;\n}\nfunction transformersByType(transformers) {\n  const byType = indexBy(transformers, t => t.type);\n  return {\n    element: byType.element || [],\n    multilineElement: byType['multiline-element'] || [],\n    textFormat: byType['text-format'] || [],\n    textMatch: byType['text-match'] || []\n  };\n}\nconst PUNCTUATION_OR_SPACE = /[!-/:-@[-`{-~\\s]/;\nconst MARKDOWN_EMPTY_LINE_REG_EXP = /^\\s{0,3}$/;\nfunction isEmptyParagraph(node) {\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isParagraphNode)(node)) {\n    return false;\n  }\n  const firstChild = node.getFirstChild();\n  return firstChild == null || node.getChildrenSize() === 1 && (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isTextNode)(firstChild) && MARKDOWN_EMPTY_LINE_REG_EXP.test(firstChild.getTextContent());\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * Renders string from markdown. The selection is moved to the start after the operation.\n */\nfunction createMarkdownExport(transformers, shouldPreserveNewLines = false) {\n  const byType = transformersByType(transformers);\n  const elementTransformers = [...byType.multilineElement, ...byType.element];\n  const isNewlineDelimited = !shouldPreserveNewLines;\n\n  // Export only uses text formats that are responsible for single format\n  // e.g. it will filter out *** (bold, italic) and instead use separate ** and *\n  const textFormatTransformers = byType.textFormat.filter(transformer => transformer.format.length === 1);\n  return node => {\n    const output = [];\n    const children = (node || (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getRoot)()).getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const result = exportTopLevelElements(child, elementTransformers, textFormatTransformers, byType.textMatch);\n      if (result != null) {\n        output.push(\n        // separate consecutive group of texts with a line break: eg. [\"hello\", \"world\"] -> [\"hello\", \"/nworld\"]\n        isNewlineDelimited && i > 0 && !isEmptyParagraph(child) && !isEmptyParagraph(children[i - 1]) ? '\\n'.concat(result) : result);\n      }\n    }\n    // Ensure consecutive groups of texts are at least \\n\\n apart while each empty paragraph render as a newline.\n    // Eg. [\"hello\", \"\", \"\", \"hi\", \"\\nworld\"] -> \"hello\\n\\n\\nhi\\n\\nworld\"\n    return output.join('\\n');\n  };\n}\nfunction exportTopLevelElements(node, elementTransformers, textTransformersIndex, textMatchTransformers) {\n  for (const transformer of elementTransformers) {\n    if (!transformer.export) {\n      continue;\n    }\n    const result = transformer.export(node, _node => exportChildren(_node, textTransformersIndex, textMatchTransformers));\n    if (result != null) {\n      return result;\n    }\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isElementNode)(node)) {\n    return exportChildren(node, textTransformersIndex, textMatchTransformers);\n  } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isDecoratorNode)(node)) {\n    return node.getTextContent();\n  } else {\n    return null;\n  }\n}\nfunction exportChildren(node, textTransformersIndex, textMatchTransformers) {\n  const output = [];\n  const children = node.getChildren();\n  mainLoop: for (const child of children) {\n    for (const transformer of textMatchTransformers) {\n      if (!transformer.export) {\n        continue;\n      }\n      const result = transformer.export(child, parentNode => exportChildren(parentNode, textTransformersIndex, textMatchTransformers), (textNode, textContent) => exportTextFormat(textNode, textContent, textTransformersIndex));\n      if (result != null) {\n        output.push(result);\n        continue mainLoop;\n      }\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isLineBreakNode)(child)) {\n      output.push('\\n');\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isTextNode)(child)) {\n      output.push(exportTextFormat(child, child.getTextContent(), textTransformersIndex));\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isElementNode)(child)) {\n      // empty paragraph returns \"\"\n      output.push(exportChildren(child, textTransformersIndex, textMatchTransformers));\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isDecoratorNode)(child)) {\n      output.push(child.getTextContent());\n    }\n  }\n  return output.join('');\n}\nfunction exportTextFormat(node, textContent, textTransformers) {\n  // This function handles the case of a string looking like this: \"   foo   \"\n  // Where it would be invalid markdown to generate: \"**   foo   **\"\n  // We instead want to trim the whitespace out, apply formatting, and then\n  // bring the whitespace back. So our returned string looks like this: \"   **foo**   \"\n  const frozenString = textContent.trim();\n  let output = frozenString;\n  const applied = new Set();\n  for (const transformer of textTransformers) {\n    const format = transformer.format[0];\n    const tag = transformer.tag;\n    if (hasFormat(node, format) && !applied.has(format)) {\n      // Multiple tags might be used for the same format (*, _)\n      applied.add(format);\n      // Prevent adding opening tag is already opened by the previous sibling\n      const previousNode = getTextSibling(node, true);\n      if (!hasFormat(previousNode, format)) {\n        output = tag + output;\n      }\n\n      // Prevent adding closing tag if next sibling will do it\n      const nextNode = getTextSibling(node, false);\n      if (!hasFormat(nextNode, format)) {\n        output += tag;\n      }\n    }\n  }\n\n  // Replace trimmed version of textContent ensuring surrounding whitespace is not modified\n  return textContent.replace(frozenString, () => output);\n}\n\n// Get next or previous text sibling a text node, including cases\n// when it's a child of inline element (e.g. link)\nfunction getTextSibling(node, backward) {\n  let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();\n  if (!sibling) {\n    const parent = node.getParentOrThrow();\n    if (parent.isInline()) {\n      sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();\n    }\n  }\n  while (sibling) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isElementNode)(sibling)) {\n      if (!sibling.isInline()) {\n        break;\n      }\n      const descendant = backward ? sibling.getLastDescendant() : sibling.getFirstDescendant();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isTextNode)(descendant)) {\n        return descendant;\n      } else {\n        sibling = backward ? sibling.getPreviousSibling() : sibling.getNextSibling();\n      }\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isTextNode)(sibling)) {\n      return sibling;\n    }\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isElementNode)(sibling)) {\n      return null;\n    }\n  }\n  return null;\n}\nfunction hasFormat(node, format) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isTextNode)(node) && node.hasFormat(format);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nCAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Renders markdown from a string. The selection is moved to the start after the operation.\n */\nfunction createMarkdownImport(transformers, shouldPreserveNewLines = false) {\n  const byType = transformersByType(transformers);\n  const textFormatTransformersIndex = createTextFormatTransformersIndex(byType.textFormat);\n  return (markdownString, node) => {\n    const lines = markdownString.split('\\n');\n    const linesLength = lines.length;\n    const root = node || (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getRoot)();\n    root.clear();\n    for (let i = 0; i < linesLength; i++) {\n      const lineText = lines[i];\n      const [imported, shiftedIndex] = $importMultiline(lines, i, byType.multilineElement, root);\n      if (imported) {\n        // If a multiline markdown element was imported, we don't want to process the lines that were part of it anymore.\n        // There could be other sub-markdown elements (both multiline and normal ones) matching within this matched multiline element's children.\n        // However, it would be the responsibility of the matched multiline transformer to decide how it wants to handle them.\n        // We cannot handle those, as there is no way for us to know how to maintain the correct order of generated lexical nodes for possible children.\n        i = shiftedIndex; // Next loop will start from the line after the last line of the multiline element\n        continue;\n      }\n      $importBlocks(lineText, root, byType.element, textFormatTransformersIndex, byType.textMatch);\n    }\n\n    // By default, removing empty paragraphs as md does not really\n    // allow empty lines and uses them as delimiter.\n    // If you need empty lines set shouldPreserveNewLines = true.\n    const children = root.getChildren();\n    for (const child of children) {\n      if (!shouldPreserveNewLines && isEmptyParagraph(child) && root.getChildrenSize() > 1) {\n        child.remove();\n      }\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)() !== null) {\n      root.selectStart();\n    }\n  };\n}\n\n/**\n *\n * @returns first element of the returned tuple is a boolean indicating if a multiline element was imported. The second element is the index of the last line that was processed.\n */\nfunction $importMultiline(lines, startLineIndex, multilineElementTransformers, rootNode) {\n  for (const transformer of multilineElementTransformers) {\n    const {\n      handleImportAfterStartMatch,\n      regExpEnd,\n      regExpStart,\n      replace\n    } = transformer;\n    const startMatch = lines[startLineIndex].match(regExpStart);\n    if (!startMatch) {\n      continue; // Try next transformer\n    }\n    if (handleImportAfterStartMatch) {\n      const result = handleImportAfterStartMatch({\n        lines,\n        rootNode,\n        startLineIndex,\n        startMatch,\n        transformer\n      });\n      if (result === null) {\n        continue;\n      } else if (result) {\n        return result;\n      }\n    }\n    const regexpEndRegex = typeof regExpEnd === 'object' && 'regExp' in regExpEnd ? regExpEnd.regExp : regExpEnd;\n    const isEndOptional = regExpEnd && typeof regExpEnd === 'object' && 'optional' in regExpEnd ? regExpEnd.optional : !regExpEnd;\n    let endLineIndex = startLineIndex;\n    const linesLength = lines.length;\n\n    // check every single line for the closing match. It could also be on the same line as the opening match.\n    while (endLineIndex < linesLength) {\n      const endMatch = regexpEndRegex ? lines[endLineIndex].match(regexpEndRegex) : null;\n      if (!endMatch) {\n        if (!isEndOptional || isEndOptional && endLineIndex < linesLength - 1 // Optional end, but didn't reach the end of the document yet => continue searching for potential closing match\n        ) {\n          endLineIndex++;\n          continue; // Search next line for closing match\n        }\n      }\n\n      // Now, check if the closing match matched is the same as the opening match.\n      // If it is, we need to continue searching for the actual closing match.\n      if (endMatch && startLineIndex === endLineIndex && endMatch.index === startMatch.index) {\n        endLineIndex++;\n        continue; // Search next line for closing match\n      }\n\n      // At this point, we have found the closing match. Next: calculate the lines in between open and closing match\n      // This should not include the matches themselves, and be split up by lines\n      const linesInBetween = [];\n      if (endMatch && startLineIndex === endLineIndex) {\n        linesInBetween.push(lines[startLineIndex].slice(startMatch[0].length, -endMatch[0].length));\n      } else {\n        for (let i = startLineIndex; i <= endLineIndex; i++) {\n          if (i === startLineIndex) {\n            const text = lines[i].slice(startMatch[0].length);\n            linesInBetween.push(text); // Also include empty text\n          } else if (i === endLineIndex && endMatch) {\n            const text = lines[i].slice(0, -endMatch[0].length);\n            linesInBetween.push(text); // Also include empty text\n          } else {\n            linesInBetween.push(lines[i]);\n          }\n        }\n      }\n      if (replace(rootNode, null, startMatch, endMatch, linesInBetween, true) !== false) {\n        // Return here. This $importMultiline function is run line by line and should only process a single multiline element at a time.\n        return [true, endLineIndex];\n      }\n\n      // The replace function returned false, despite finding the matching open and close tags => this transformer does not want to handle it.\n      // Thus, we continue letting the remaining transformers handle the passed lines of text from the beginning\n      break;\n    }\n  }\n\n  // No multiline transformer handled this line successfully\n  return [false, startLineIndex];\n}\nfunction $importBlocks(lineText, rootNode, elementTransformers, textFormatTransformersIndex, textMatchTransformers) {\n  const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$createTextNode)(lineText);\n  const elementNode = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$createParagraphNode)();\n  elementNode.append(textNode);\n  rootNode.append(elementNode);\n  for (const {\n    regExp,\n    replace\n  } of elementTransformers) {\n    const match = lineText.match(regExp);\n    if (match) {\n      textNode.setTextContent(lineText.slice(match[0].length));\n      if (replace(elementNode, [textNode], match, true) !== false) {\n        break;\n      }\n    }\n  }\n  importTextFormatTransformers(textNode, textFormatTransformersIndex, textMatchTransformers);\n\n  // If no transformer found and we left with original paragraph node\n  // can check if its content can be appended to the previous node\n  // if it's a paragraph, quote or list\n  if (elementNode.isAttached() && lineText.length > 0) {\n    const previousNode = elementNode.getPreviousSibling();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isParagraphNode)(previousNode) || (0,_lexical_rich_text__WEBPACK_IMPORTED_MODULE_2__.$isQuoteNode)(previousNode) || (0,_lexical_list__WEBPACK_IMPORTED_MODULE_3__.$isListNode)(previousNode)) {\n      let targetNode = previousNode;\n      if ((0,_lexical_list__WEBPACK_IMPORTED_MODULE_3__.$isListNode)(previousNode)) {\n        const lastDescendant = previousNode.getLastDescendant();\n        if (lastDescendant == null) {\n          targetNode = null;\n        } else {\n          targetNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_4__.$findMatchingParent)(lastDescendant, _lexical_list__WEBPACK_IMPORTED_MODULE_3__.$isListItemNode);\n        }\n      }\n      if (targetNode != null && targetNode.getTextContentSize() > 0) {\n        targetNode.splice(targetNode.getChildrenSize(), 0, [(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$createLineBreakNode)(), ...elementNode.getChildren()]);\n        elementNode.remove();\n      }\n    }\n  }\n}\n\n// Processing text content and replaces text format tags.\n// It takes outermost tag match and its content, creates text node with\n// format based on tag and then recursively executed over node's content\n//\n// E.g. for \"*Hello **world**!*\" string it will create text node with\n// \"Hello **world**!\" content and italic format and run recursively over\n// its content to transform \"**world**\" part\nfunction importTextFormatTransformers(textNode, textFormatTransformersIndex, textMatchTransformers) {\n  const textContent = textNode.getTextContent();\n  const match = findOutermostMatch(textContent, textFormatTransformersIndex);\n  if (!match) {\n    // Once text format processing is done run text match transformers, as it\n    // only can span within single text node (unline formats that can cover multiple nodes)\n    importTextMatchTransformers(textNode, textMatchTransformers);\n    return;\n  }\n  let currentNode, remainderNode, leadingNode;\n\n  // If matching full content there's no need to run splitText and can reuse existing textNode\n  // to update its content and apply format. E.g. for **_Hello_** string after applying bold\n  // format (**) it will reuse the same text node to apply italic (_)\n  if (match[0] === textContent) {\n    currentNode = textNode;\n  } else {\n    const startIndex = match.index || 0;\n    const endIndex = startIndex + match[0].length;\n    if (startIndex === 0) {\n      [currentNode, remainderNode] = textNode.splitText(endIndex);\n    } else {\n      [leadingNode, currentNode, remainderNode] = textNode.splitText(startIndex, endIndex);\n    }\n  }\n  currentNode.setTextContent(match[2]);\n  const transformer = textFormatTransformersIndex.transformersByTag[match[1]];\n  if (transformer) {\n    for (const format of transformer.format) {\n      if (!currentNode.hasFormat(format)) {\n        currentNode.toggleFormat(format);\n      }\n    }\n  }\n\n  // Recursively run over inner text if it's not inline code\n  if (!currentNode.hasFormat('code')) {\n    importTextFormatTransformers(currentNode, textFormatTransformersIndex, textMatchTransformers);\n  }\n\n  // Run over leading/remaining text if any\n  if (leadingNode) {\n    importTextFormatTransformers(leadingNode, textFormatTransformersIndex, textMatchTransformers);\n  }\n  if (remainderNode) {\n    importTextFormatTransformers(remainderNode, textFormatTransformersIndex, textMatchTransformers);\n  }\n}\nfunction importTextMatchTransformers(textNode_, textMatchTransformers) {\n  let textNode = textNode_;\n  mainLoop: while (textNode) {\n    for (const transformer of textMatchTransformers) {\n      if (!transformer.replace || !transformer.importRegExp) {\n        continue;\n      }\n      const match = textNode.getTextContent().match(transformer.importRegExp);\n      if (!match) {\n        continue;\n      }\n      const startIndex = match.index || 0;\n      const endIndex = transformer.getEndIndex ? transformer.getEndIndex(textNode, match) : startIndex + match[0].length;\n      if (endIndex === false) {\n        continue;\n      }\n      let replaceNode, newTextNode;\n      if (startIndex === 0) {\n        [replaceNode, textNode] = textNode.splitText(endIndex);\n      } else {\n        [, replaceNode, newTextNode] = textNode.splitText(startIndex, endIndex);\n      }\n      if (newTextNode) {\n        importTextMatchTransformers(newTextNode, textMatchTransformers);\n      }\n      transformer.replace(replaceNode, match);\n      continue mainLoop;\n    }\n    break;\n  }\n}\n\n// Finds first \"<tag>content<tag>\" match that is not nested into another tag\nfunction findOutermostMatch(textContent, textTransformersIndex) {\n  const openTagsMatch = textContent.match(textTransformersIndex.openTagsRegExp);\n  if (openTagsMatch == null) {\n    return null;\n  }\n  for (const match of openTagsMatch) {\n    // Open tags reg exp might capture leading space so removing it\n    // before using match to find transformer\n    const tag = match.replace(/^\\s/, '');\n    const fullMatchRegExp = textTransformersIndex.fullMatchRegExpByTag[tag];\n    if (fullMatchRegExp == null) {\n      continue;\n    }\n    const fullMatch = textContent.match(fullMatchRegExp);\n    const transformer = textTransformersIndex.transformersByTag[tag];\n    if (fullMatch != null && transformer != null) {\n      if (transformer.intraword !== false) {\n        return fullMatch;\n      }\n\n      // For non-intraword transformers checking if it's within a word\n      // or surrounded with space/punctuation/newline\n      const {\n        index = 0\n      } = fullMatch;\n      const beforeChar = textContent[index - 1];\n      const afterChar = textContent[index + fullMatch[0].length];\n      if ((!beforeChar || PUNCTUATION_OR_SPACE.test(beforeChar)) && (!afterChar || PUNCTUATION_OR_SPACE.test(afterChar))) {\n        return fullMatch;\n      }\n    }\n  }\n  return null;\n}\nfunction createTextFormatTransformersIndex(textTransformers) {\n  const transformersByTag = {};\n  const fullMatchRegExpByTag = {};\n  const openTagsRegExp = [];\n  const escapeRegExp = `(?<![\\\\\\\\])`;\n  for (const transformer of textTransformers) {\n    const {\n      tag\n    } = transformer;\n    transformersByTag[tag] = transformer;\n    const tagRegExp = tag.replace(/(\\*|\\^|\\+)/g, '\\\\$1');\n    openTagsRegExp.push(tagRegExp);\n    if (IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT) {\n      fullMatchRegExpByTag[tag] = new RegExp(`(${tagRegExp})(?![${tagRegExp}\\\\s])(.*?[^${tagRegExp}\\\\s])${tagRegExp}(?!${tagRegExp})`);\n    } else {\n      fullMatchRegExpByTag[tag] = new RegExp(`(?<![\\\\\\\\${tagRegExp}])(${tagRegExp})((\\\\\\\\${tagRegExp})?.*?[^${tagRegExp}\\\\s](\\\\\\\\${tagRegExp})?)((?<!\\\\\\\\)|(?<=\\\\\\\\\\\\\\\\))(${tagRegExp})(?![\\\\\\\\${tagRegExp}])`);\n    }\n  }\n  return {\n    // Reg exp to find open tag + content + close tag\n    fullMatchRegExpByTag,\n    // Reg exp to find opening tags\n    openTagsRegExp: new RegExp((IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? '' : `${escapeRegExp}`) + '(' + openTagsRegExp.join('|') + ')', 'g'),\n    transformersByTag\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction runElementTransformers(parentNode, anchorNode, anchorOffset, elementTransformers) {\n  const grandParentNode = parentNode.getParent();\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRootOrShadowRoot)(grandParentNode) || parentNode.getFirstChild() !== anchorNode) {\n    return false;\n  }\n  const textContent = anchorNode.getTextContent();\n\n  // Checking for anchorOffset position to prevent any checks for cases when caret is too far\n  // from a line start to be a part of block-level markdown trigger.\n  //\n  // TODO:\n  // Can have a quick check if caret is close enough to the beginning of the string (e.g. offset less than 10-20)\n  // since otherwise it won't be a markdown shortcut, but tables are exception\n  if (textContent[anchorOffset - 1] !== ' ') {\n    return false;\n  }\n  for (const {\n    regExp,\n    replace\n  } of elementTransformers) {\n    const match = textContent.match(regExp);\n    if (match && match[0].length === (match[0].endsWith(' ') ? anchorOffset : anchorOffset - 1)) {\n      const nextSiblings = anchorNode.getNextSiblings();\n      const [leadingNode, remainderNode] = anchorNode.splitText(anchorOffset);\n      leadingNode.remove();\n      const siblings = remainderNode ? [remainderNode, ...nextSiblings] : nextSiblings;\n      if (replace(parentNode, siblings, match, false) !== false) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction runMultilineElementTransformers(parentNode, anchorNode, anchorOffset, elementTransformers) {\n  const grandParentNode = parentNode.getParent();\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRootOrShadowRoot)(grandParentNode) || parentNode.getFirstChild() !== anchorNode) {\n    return false;\n  }\n  const textContent = anchorNode.getTextContent();\n\n  // Checking for anchorOffset position to prevent any checks for cases when caret is too far\n  // from a line start to be a part of block-level markdown trigger.\n  //\n  // TODO:\n  // Can have a quick check if caret is close enough to the beginning of the string (e.g. offset less than 10-20)\n  // since otherwise it won't be a markdown shortcut, but tables are exception\n  if (textContent[anchorOffset - 1] !== ' ') {\n    return false;\n  }\n  for (const {\n    regExpStart,\n    replace,\n    regExpEnd\n  } of elementTransformers) {\n    if (regExpEnd && !('optional' in regExpEnd) || regExpEnd && 'optional' in regExpEnd && !regExpEnd.optional) {\n      continue;\n    }\n    const match = textContent.match(regExpStart);\n    if (match && match[0].length === (match[0].endsWith(' ') ? anchorOffset : anchorOffset - 1)) {\n      const nextSiblings = anchorNode.getNextSiblings();\n      const [leadingNode, remainderNode] = anchorNode.splitText(anchorOffset);\n      leadingNode.remove();\n      const siblings = remainderNode ? [remainderNode, ...nextSiblings] : nextSiblings;\n      if (replace(parentNode, siblings, match, null, null, false) !== false) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction runTextMatchTransformers(anchorNode, anchorOffset, transformersByTrigger) {\n  let textContent = anchorNode.getTextContent();\n  const lastChar = textContent[anchorOffset - 1];\n  const transformers = transformersByTrigger[lastChar];\n  if (transformers == null) {\n    return false;\n  }\n\n  // If typing in the middle of content, remove the tail to do\n  // reg exp match up to a string end (caret position)\n  if (anchorOffset < textContent.length) {\n    textContent = textContent.slice(0, anchorOffset);\n  }\n  for (const transformer of transformers) {\n    if (!transformer.replace || !transformer.regExp) {\n      continue;\n    }\n    const match = textContent.match(transformer.regExp);\n    if (match === null) {\n      continue;\n    }\n    const startIndex = match.index || 0;\n    const endIndex = startIndex + match[0].length;\n    let replaceNode;\n    if (startIndex === 0) {\n      [replaceNode] = anchorNode.splitText(endIndex);\n    } else {\n      [, replaceNode] = anchorNode.splitText(startIndex, endIndex);\n    }\n    replaceNode.selectNext(0, 0);\n    transformer.replace(replaceNode, match);\n    return true;\n  }\n  return false;\n}\nfunction $runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformers) {\n  const textContent = anchorNode.getTextContent();\n  const closeTagEndIndex = anchorOffset - 1;\n  const closeChar = textContent[closeTagEndIndex];\n  // Quick check if we're possibly at the end of inline markdown style\n  const matchers = textFormatTransformers[closeChar];\n  if (!matchers) {\n    return false;\n  }\n  for (const matcher of matchers) {\n    const {\n      tag\n    } = matcher;\n    const tagLength = tag.length;\n    const closeTagStartIndex = closeTagEndIndex - tagLength + 1;\n\n    // If tag is not single char check if rest of it matches with text content\n    if (tagLength > 1) {\n      if (!isEqualSubString(textContent, closeTagStartIndex, tag, 0, tagLength)) {\n        continue;\n      }\n    }\n\n    // Space before closing tag cancels inline markdown\n    if (textContent[closeTagStartIndex - 1] === ' ') {\n      continue;\n    }\n\n    // Some tags can not be used within words, hence should have newline/space/punctuation after it\n    const afterCloseTagChar = textContent[closeTagEndIndex + 1];\n    if (matcher.intraword === false && afterCloseTagChar && !PUNCTUATION_OR_SPACE.test(afterCloseTagChar)) {\n      continue;\n    }\n    const closeNode = anchorNode;\n    let openNode = closeNode;\n    let openTagStartIndex = getOpenTagStartIndex(textContent, closeTagStartIndex, tag);\n\n    // Go through text node siblings and search for opening tag\n    // if haven't found it within the same text node as closing tag\n    let sibling = openNode;\n    while (openTagStartIndex < 0 && (sibling = sibling.getPreviousSibling())) {\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isLineBreakNode)(sibling)) {\n        break;\n      }\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isTextNode)(sibling)) {\n        const siblingTextContent = sibling.getTextContent();\n        openNode = sibling;\n        openTagStartIndex = getOpenTagStartIndex(siblingTextContent, siblingTextContent.length, tag);\n      }\n    }\n\n    // Opening tag is not found\n    if (openTagStartIndex < 0) {\n      continue;\n    }\n\n    // No content between opening and closing tag\n    if (openNode === closeNode && openTagStartIndex + tagLength === closeTagStartIndex) {\n      continue;\n    }\n\n    // Checking longer tags for repeating chars (e.g. *** vs **)\n    const prevOpenNodeText = openNode.getTextContent();\n    if (openTagStartIndex > 0 && prevOpenNodeText[openTagStartIndex - 1] === closeChar) {\n      continue;\n    }\n\n    // Some tags can not be used within words, hence should have newline/space/punctuation before it\n    const beforeOpenTagChar = prevOpenNodeText[openTagStartIndex - 1];\n    if (matcher.intraword === false && beforeOpenTagChar && !PUNCTUATION_OR_SPACE.test(beforeOpenTagChar)) {\n      continue;\n    }\n\n    // Clean text from opening and closing tags (starting from closing tag\n    // to prevent any offset shifts if we start from opening one)\n    const prevCloseNodeText = closeNode.getTextContent();\n    const closeNodeText = prevCloseNodeText.slice(0, closeTagStartIndex) + prevCloseNodeText.slice(closeTagEndIndex + 1);\n    closeNode.setTextContent(closeNodeText);\n    const openNodeText = openNode === closeNode ? closeNodeText : prevOpenNodeText;\n    openNode.setTextContent(openNodeText.slice(0, openTagStartIndex) + openNodeText.slice(openTagStartIndex + tagLength));\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n    const nextSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$createRangeSelection)();\n    (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$setSelection)(nextSelection);\n    // Adjust offset based on deleted chars\n    const newOffset = closeTagEndIndex - tagLength * (openNode === closeNode ? 2 : 1) + 1;\n    nextSelection.anchor.set(openNode.__key, openTagStartIndex, 'text');\n    nextSelection.focus.set(closeNode.__key, newOffset, 'text');\n\n    // Apply formatting to selected text\n    for (const format of matcher.format) {\n      if (!nextSelection.hasFormat(format)) {\n        nextSelection.formatText(format);\n      }\n    }\n\n    // Collapse selection up to the focus point\n    nextSelection.anchor.set(nextSelection.focus.key, nextSelection.focus.offset, nextSelection.focus.type);\n\n    // Remove formatting from collapsed selection\n    for (const format of matcher.format) {\n      if (nextSelection.hasFormat(format)) {\n        nextSelection.toggleFormat(format);\n      }\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection)) {\n      nextSelection.format = selection.format;\n    }\n    return true;\n  }\n  return false;\n}\nfunction getOpenTagStartIndex(string, maxIndex, tag) {\n  const tagLength = tag.length;\n  for (let i = maxIndex; i >= tagLength; i--) {\n    const startIndex = i - tagLength;\n    if (isEqualSubString(string, startIndex, tag, 0, tagLength) &&\n    // Space after opening tag cancels transformation\n    string[startIndex + tagLength] !== ' ') {\n      return startIndex;\n    }\n  }\n  return -1;\n}\nfunction isEqualSubString(stringA, aStart, stringB, bStart, length) {\n  for (let i = 0; i < length; i++) {\n    if (stringA[aStart + i] !== stringB[bStart + i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction registerMarkdownShortcuts(editor, transformers = TRANSFORMERS) {\n  const byType = transformersByType(transformers);\n  const textFormatTransformersByTrigger = indexBy(byType.textFormat, ({\n    tag\n  }) => tag[tag.length - 1]);\n  const textMatchTransformersByTrigger = indexBy(byType.textMatch, ({\n    trigger\n  }) => trigger);\n  for (const transformer of transformers) {\n    const type = transformer.type;\n    if (type === 'element' || type === 'text-match' || type === 'multiline-element') {\n      const dependencies = transformer.dependencies;\n      for (const node of dependencies) {\n        if (!editor.hasNode(node)) {\n          {\n            throw Error(`MarkdownShortcuts: missing dependency ${node.getType()} for transformer. Ensure node dependency is included in editor initial config.`);\n          }\n        }\n      }\n    }\n  }\n  const $transform = (parentNode, anchorNode, anchorOffset) => {\n    if (runElementTransformers(parentNode, anchorNode, anchorOffset, byType.element)) {\n      return;\n    }\n    if (runMultilineElementTransformers(parentNode, anchorNode, anchorOffset, byType.multilineElement)) {\n      return;\n    }\n    if (runTextMatchTransformers(anchorNode, anchorOffset, textMatchTransformersByTrigger)) {\n      return;\n    }\n    $runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformersByTrigger);\n  };\n  return editor.registerUpdateListener(({\n    tags,\n    dirtyLeaves,\n    editorState,\n    prevEditorState\n  }) => {\n    // Ignore updates from collaboration and undo/redo (as changes already calculated)\n    if (tags.has('collaboration') || tags.has('historic')) {\n      return;\n    }\n\n    // If editor is still composing (i.e. backticks) we must wait before the user confirms the key\n    if (editor.isComposing()) {\n      return;\n    }\n    const selection = editorState.read(lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection);\n    const prevSelection = prevEditorState.read(lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection);\n\n    // We expect selection to be a collapsed range and not match previous one (as we want\n    // to trigger transforms only as user types)\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(prevSelection) || !(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection) || !selection.isCollapsed() || selection.is(prevSelection)) {\n      return;\n    }\n    const anchorKey = selection.anchor.key;\n    const anchorOffset = selection.anchor.offset;\n    const anchorNode = editorState._nodeMap.get(anchorKey);\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isTextNode)(anchorNode) || !dirtyLeaves.has(anchorKey) || anchorOffset !== 1 && anchorOffset > prevSelection.anchor.offset + 1) {\n      return;\n    }\n    editor.update(() => {\n      // Markdown is not available inside code\n      if (anchorNode.hasFormat('code')) {\n        return;\n      }\n      const parentNode = anchorNode.getParent();\n      if (parentNode === null || (0,_lexical_code__WEBPACK_IMPORTED_MODULE_0__.$isCodeNode)(parentNode)) {\n        return;\n      }\n      $transform(parentNode, anchorNode, selection.anchor.offset);\n    });\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst ORDERED_LIST_REGEX = /^(\\s*)(\\d{1,})\\.\\s/;\nconst UNORDERED_LIST_REGEX = /^(\\s*)[-*+]\\s/;\nconst CHECK_LIST_REGEX = /^(\\s*)(?:-\\s)?\\s?(\\[(\\s|x)?\\])\\s/i;\nconst HEADING_REGEX = /^(#{1,6})\\s/;\nconst QUOTE_REGEX = /^>\\s/;\nconst CODE_START_REGEX = /^[ \\t]*```(\\w+)?/;\nconst CODE_END_REGEX = /[ \\t]*```$/;\nconst CODE_SINGLE_LINE_REGEX = /^[ \\t]*```[^`]+(?:(?:`{1,2}|`{4,})[^`]+)*```(?:[^`]|$)/;\nconst TABLE_ROW_REG_EXP = /^(?:\\|)(.+)(?:\\|)\\s?$/;\nconst TABLE_ROW_DIVIDER_REG_EXP = /^(\\| ?:?-*:? ?)+\\|\\s?$/;\nconst createBlockNode = createNode => {\n  return (parentNode, children, match) => {\n    const node = createNode(match);\n    node.append(...children);\n    parentNode.replace(node);\n    node.select(0, 0);\n  };\n};\n\n// Amount of spaces that define indentation level\n// TODO: should be an option\nconst LIST_INDENT_SIZE = 4;\nfunction getIndent(whitespaces) {\n  const tabs = whitespaces.match(/\\t/g);\n  const spaces = whitespaces.match(/ /g);\n  let indent = 0;\n  if (tabs) {\n    indent += tabs.length;\n  }\n  if (spaces) {\n    indent += Math.floor(spaces.length / LIST_INDENT_SIZE);\n  }\n  return indent;\n}\nconst listReplace = listType => {\n  return (parentNode, children, match) => {\n    const previousNode = parentNode.getPreviousSibling();\n    const nextNode = parentNode.getNextSibling();\n    const listItem = (0,_lexical_list__WEBPACK_IMPORTED_MODULE_3__.$createListItemNode)(listType === 'check' ? match[3] === 'x' : undefined);\n    if ((0,_lexical_list__WEBPACK_IMPORTED_MODULE_3__.$isListNode)(nextNode) && nextNode.getListType() === listType) {\n      const firstChild = nextNode.getFirstChild();\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItem);\n      } else {\n        // should never happen, but let's handle gracefully, just in case.\n        nextNode.append(listItem);\n      }\n      parentNode.remove();\n    } else if ((0,_lexical_list__WEBPACK_IMPORTED_MODULE_3__.$isListNode)(previousNode) && previousNode.getListType() === listType) {\n      previousNode.append(listItem);\n      parentNode.remove();\n    } else {\n      const list = (0,_lexical_list__WEBPACK_IMPORTED_MODULE_3__.$createListNode)(listType, listType === 'number' ? Number(match[2]) : undefined);\n      list.append(listItem);\n      parentNode.replace(list);\n    }\n    listItem.append(...children);\n    listItem.select(0, 0);\n    const indent = getIndent(match[1]);\n    if (indent) {\n      listItem.setIndent(indent);\n    }\n  };\n};\nconst listExport = (listNode, exportChildren, depth) => {\n  const output = [];\n  const children = listNode.getChildren();\n  let index = 0;\n  for (const listItemNode of children) {\n    if ((0,_lexical_list__WEBPACK_IMPORTED_MODULE_3__.$isListItemNode)(listItemNode)) {\n      if (listItemNode.getChildrenSize() === 1) {\n        const firstChild = listItemNode.getFirstChild();\n        if ((0,_lexical_list__WEBPACK_IMPORTED_MODULE_3__.$isListNode)(firstChild)) {\n          output.push(listExport(firstChild, exportChildren, depth + 1));\n          continue;\n        }\n      }\n      const indent = ' '.repeat(depth * LIST_INDENT_SIZE);\n      const listType = listNode.getListType();\n      const prefix = listType === 'number' ? `${listNode.getStart() + index}. ` : listType === 'check' ? `- [${listItemNode.getChecked() ? 'x' : ' '}] ` : '- ';\n      output.push(indent + prefix + exportChildren(listItemNode));\n      index++;\n    }\n  }\n  return output.join('\\n');\n};\nconst HEADING = {\n  dependencies: [_lexical_rich_text__WEBPACK_IMPORTED_MODULE_2__.HeadingNode],\n  export: (node, exportChildren) => {\n    if (!(0,_lexical_rich_text__WEBPACK_IMPORTED_MODULE_2__.$isHeadingNode)(node)) {\n      return null;\n    }\n    const level = Number(node.getTag().slice(1));\n    return '#'.repeat(level) + ' ' + exportChildren(node);\n  },\n  regExp: HEADING_REGEX,\n  replace: createBlockNode(match => {\n    const tag = 'h' + match[1].length;\n    return (0,_lexical_rich_text__WEBPACK_IMPORTED_MODULE_2__.$createHeadingNode)(tag);\n  }),\n  type: 'element'\n};\nconst QUOTE = {\n  dependencies: [_lexical_rich_text__WEBPACK_IMPORTED_MODULE_2__.QuoteNode],\n  export: (node, exportChildren) => {\n    if (!(0,_lexical_rich_text__WEBPACK_IMPORTED_MODULE_2__.$isQuoteNode)(node)) {\n      return null;\n    }\n    const lines = exportChildren(node).split('\\n');\n    const output = [];\n    for (const line of lines) {\n      output.push('> ' + line);\n    }\n    return output.join('\\n');\n  },\n  regExp: QUOTE_REGEX,\n  replace: (parentNode, children, _match, isImport) => {\n    if (isImport) {\n      const previousNode = parentNode.getPreviousSibling();\n      if ((0,_lexical_rich_text__WEBPACK_IMPORTED_MODULE_2__.$isQuoteNode)(previousNode)) {\n        previousNode.splice(previousNode.getChildrenSize(), 0, [(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$createLineBreakNode)(), ...children]);\n        previousNode.select(0, 0);\n        parentNode.remove();\n        return;\n      }\n    }\n    const node = (0,_lexical_rich_text__WEBPACK_IMPORTED_MODULE_2__.$createQuoteNode)();\n    node.append(...children);\n    parentNode.replace(node);\n    node.select(0, 0);\n  },\n  type: 'element'\n};\nconst CODE = {\n  dependencies: [_lexical_code__WEBPACK_IMPORTED_MODULE_0__.CodeNode],\n  export: node => {\n    if (!(0,_lexical_code__WEBPACK_IMPORTED_MODULE_0__.$isCodeNode)(node)) {\n      return null;\n    }\n    const textContent = node.getTextContent();\n    return '```' + (node.getLanguage() || '') + (textContent ? '\\n' + textContent : '') + '\\n' + '```';\n  },\n  regExpEnd: {\n    optional: true,\n    regExp: CODE_END_REGEX\n  },\n  regExpStart: CODE_START_REGEX,\n  replace: (rootNode, children, startMatch, endMatch, linesInBetween, isImport) => {\n    let codeBlockNode;\n    let code;\n    if (!children && linesInBetween) {\n      if (linesInBetween.length === 1) {\n        // Single-line code blocks\n        if (endMatch) {\n          // End match on same line. Example: ```markdown hello```. markdown should not be considered the language here.\n          codeBlockNode = (0,_lexical_code__WEBPACK_IMPORTED_MODULE_0__.$createCodeNode)();\n          code = startMatch[1] + linesInBetween[0];\n        } else {\n          // No end match. We should assume the language is next to the backticks and that code will be typed on the next line in the future\n          codeBlockNode = (0,_lexical_code__WEBPACK_IMPORTED_MODULE_0__.$createCodeNode)(startMatch[1]);\n          code = linesInBetween[0].startsWith(' ') ? linesInBetween[0].slice(1) : linesInBetween[0];\n        }\n      } else {\n        // Treat multi-line code blocks as if they always have an end match\n        codeBlockNode = (0,_lexical_code__WEBPACK_IMPORTED_MODULE_0__.$createCodeNode)(startMatch[1]);\n        if (linesInBetween[0].trim().length === 0) {\n          // Filter out all start and end lines that are length 0 until we find the first line with content\n          while (linesInBetween.length > 0 && !linesInBetween[0].length) {\n            linesInBetween.shift();\n          }\n        } else {\n          // The first line already has content => Remove the first space of the line if it exists\n          linesInBetween[0] = linesInBetween[0].startsWith(' ') ? linesInBetween[0].slice(1) : linesInBetween[0];\n        }\n\n        // Filter out all end lines that are length 0 until we find the last line with content\n        while (linesInBetween.length > 0 && !linesInBetween[linesInBetween.length - 1].length) {\n          linesInBetween.pop();\n        }\n        code = linesInBetween.join('\\n');\n      }\n      const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$createTextNode)(code);\n      codeBlockNode.append(textNode);\n      rootNode.append(codeBlockNode);\n    } else if (children) {\n      createBlockNode(match => {\n        return (0,_lexical_code__WEBPACK_IMPORTED_MODULE_0__.$createCodeNode)(match ? match[1] : undefined);\n      })(rootNode, children, startMatch, isImport);\n    }\n  },\n  type: 'multiline-element'\n};\nconst UNORDERED_LIST = {\n  dependencies: [_lexical_list__WEBPACK_IMPORTED_MODULE_3__.ListNode, _lexical_list__WEBPACK_IMPORTED_MODULE_3__.ListItemNode],\n  export: (node, exportChildren) => {\n    return (0,_lexical_list__WEBPACK_IMPORTED_MODULE_3__.$isListNode)(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: UNORDERED_LIST_REGEX,\n  replace: listReplace('bullet'),\n  type: 'element'\n};\nconst CHECK_LIST = {\n  dependencies: [_lexical_list__WEBPACK_IMPORTED_MODULE_3__.ListNode, _lexical_list__WEBPACK_IMPORTED_MODULE_3__.ListItemNode],\n  export: (node, exportChildren) => {\n    return (0,_lexical_list__WEBPACK_IMPORTED_MODULE_3__.$isListNode)(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: CHECK_LIST_REGEX,\n  replace: listReplace('check'),\n  type: 'element'\n};\nconst ORDERED_LIST = {\n  dependencies: [_lexical_list__WEBPACK_IMPORTED_MODULE_3__.ListNode, _lexical_list__WEBPACK_IMPORTED_MODULE_3__.ListItemNode],\n  export: (node, exportChildren) => {\n    return (0,_lexical_list__WEBPACK_IMPORTED_MODULE_3__.$isListNode)(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: ORDERED_LIST_REGEX,\n  replace: listReplace('number'),\n  type: 'element'\n};\nconst INLINE_CODE = {\n  format: ['code'],\n  tag: '`',\n  type: 'text-format'\n};\nconst HIGHLIGHT = {\n  format: ['highlight'],\n  tag: '==',\n  type: 'text-format'\n};\nconst BOLD_ITALIC_STAR = {\n  format: ['bold', 'italic'],\n  tag: '***',\n  type: 'text-format'\n};\nconst BOLD_ITALIC_UNDERSCORE = {\n  format: ['bold', 'italic'],\n  intraword: false,\n  tag: '___',\n  type: 'text-format'\n};\nconst BOLD_STAR = {\n  format: ['bold'],\n  tag: '**',\n  type: 'text-format'\n};\nconst BOLD_UNDERSCORE = {\n  format: ['bold'],\n  intraword: false,\n  tag: '__',\n  type: 'text-format'\n};\nconst STRIKETHROUGH = {\n  format: ['strikethrough'],\n  tag: '~~',\n  type: 'text-format'\n};\nconst ITALIC_STAR = {\n  format: ['italic'],\n  tag: '*',\n  type: 'text-format'\n};\nconst ITALIC_UNDERSCORE = {\n  format: ['italic'],\n  intraword: false,\n  tag: '_',\n  type: 'text-format'\n};\n\n// Order of text transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n// - then longer tags match (e.g. ** or __ should go before * or _)\nconst LINK = {\n  dependencies: [_lexical_link__WEBPACK_IMPORTED_MODULE_5__.LinkNode],\n  export: (node, exportChildren, exportFormat) => {\n    if (!(0,_lexical_link__WEBPACK_IMPORTED_MODULE_5__.$isLinkNode)(node)) {\n      return null;\n    }\n    const title = node.getTitle();\n    const linkContent = title ? `[${node.getTextContent()}](${node.getURL()} \"${title}\")` : `[${node.getTextContent()}](${node.getURL()})`;\n    const firstChild = node.getFirstChild();\n    // Add text styles only if link has single text node inside. If it's more\n    // then one we ignore it as markdown does not support nested styles for links\n    if (node.getChildrenSize() === 1 && (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isTextNode)(firstChild)) {\n      return exportFormat(firstChild, linkContent);\n    } else {\n      return linkContent;\n    }\n  },\n  importRegExp: /(?:\\[([^[]+)\\])(?:\\((?:([^()\\s]+)(?:\\s\"((?:[^\"]*\\\\\")*[^\"]*)\"\\s*)?)\\))/,\n  regExp: /(?:\\[([^[]+)\\])(?:\\((?:([^()\\s]+)(?:\\s\"((?:[^\"]*\\\\\")*[^\"]*)\"\\s*)?)\\))$/,\n  replace: (textNode, match) => {\n    const [, linkText, linkUrl, linkTitle] = match;\n    const linkNode = (0,_lexical_link__WEBPACK_IMPORTED_MODULE_5__.$createLinkNode)(linkUrl, {\n      title: linkTitle\n    });\n    const linkTextNode = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$createTextNode)(linkText);\n    linkTextNode.setFormat(textNode.getFormat());\n    linkNode.append(linkTextNode);\n    textNode.replace(linkNode);\n  },\n  trigger: ')',\n  type: 'text-match'\n};\nfunction normalizeMarkdown(input, shouldMergeAdjacentLines = false) {\n  const lines = input.split('\\n');\n  let inCodeBlock = false;\n  const sanitizedLines = [];\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const lastLine = sanitizedLines[sanitizedLines.length - 1];\n\n    // Code blocks of ```single line``` don't toggle the inCodeBlock flag\n    if (CODE_SINGLE_LINE_REGEX.test(line)) {\n      sanitizedLines.push(line);\n      continue;\n    }\n\n    // Detect the start or end of a code block\n    if (CODE_START_REGEX.test(line) || CODE_END_REGEX.test(line)) {\n      inCodeBlock = !inCodeBlock;\n      sanitizedLines.push(line);\n      continue;\n    }\n\n    // If we are inside a code block, keep the line unchanged\n    if (inCodeBlock) {\n      sanitizedLines.push(line);\n      continue;\n    }\n\n    // In markdown the concept of \"empty paragraphs\" does not exist.\n    // Blocks must be separated by an empty line. Non-empty adjacent lines must be merged.\n    if (line === '' || lastLine === '' || !lastLine || HEADING_REGEX.test(lastLine) || HEADING_REGEX.test(line) || QUOTE_REGEX.test(line) || ORDERED_LIST_REGEX.test(line) || UNORDERED_LIST_REGEX.test(line) || CHECK_LIST_REGEX.test(line) || TABLE_ROW_REG_EXP.test(line) || TABLE_ROW_DIVIDER_REG_EXP.test(line) || !shouldMergeAdjacentLines) {\n      sanitizedLines.push(line);\n    } else {\n      sanitizedLines[sanitizedLines.length - 1] = lastLine + line;\n    }\n  }\n  return sanitizedLines.join('\\n');\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst ELEMENT_TRANSFORMERS = [HEADING, QUOTE, UNORDERED_LIST, ORDERED_LIST];\nconst MULTILINE_ELEMENT_TRANSFORMERS = [CODE];\n\n// Order of text format transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n// - then longer tags match (e.g. ** or __ should go before * or _)\nconst TEXT_FORMAT_TRANSFORMERS = [INLINE_CODE, BOLD_ITALIC_STAR, BOLD_ITALIC_UNDERSCORE, BOLD_STAR, BOLD_UNDERSCORE, HIGHLIGHT, ITALIC_STAR, ITALIC_UNDERSCORE, STRIKETHROUGH];\nconst TEXT_MATCH_TRANSFORMERS = [LINK];\nconst TRANSFORMERS = [...ELEMENT_TRANSFORMERS, ...MULTILINE_ELEMENT_TRANSFORMERS, ...TEXT_FORMAT_TRANSFORMERS, ...TEXT_MATCH_TRANSFORMERS];\n\n/**\n * Renders markdown from a string. The selection is moved to the start after the operation.\n *\n *  @param {boolean} [shouldPreserveNewLines] By setting this to true, new lines will be preserved between conversions\n *  @param {boolean} [shouldMergeAdjacentLines] By setting this to true, adjacent non empty lines will be merged according to commonmark spec: https://spec.commonmark.org/0.24/#example-177. Not applicable if shouldPreserveNewLines = true.\n */\nfunction $convertFromMarkdownString(markdown, transformers = TRANSFORMERS, node, shouldPreserveNewLines = false, shouldMergeAdjacentLines = false) {\n  const sanitizedMarkdown = shouldPreserveNewLines ? markdown : normalizeMarkdown(markdown, shouldMergeAdjacentLines);\n  const importMarkdown = createMarkdownImport(transformers, shouldPreserveNewLines);\n  return importMarkdown(sanitizedMarkdown, node);\n}\n\n/**\n * Renders string from markdown. The selection is moved to the start after the operation.\n */\nfunction $convertToMarkdownString(transformers = TRANSFORMERS, node, shouldPreserveNewLines = false) {\n  const exportMarkdown = createMarkdownExport(transformers, shouldPreserveNewLines);\n  return exportMarkdown(node);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxleGljYWwrbWFya2Rvd25AMC4yMC4wL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9tYXJrZG93bi9MZXhpY2FsTWFya2Rvd24uZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ1I7QUFDcko7QUFDSztBQUMzRTtBQUNrQjtBQUNBOztBQUV2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qyx5Q0FBeUMsSUFBSTtBQUM3QztBQUNBLE9BQU8seURBQWdCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxvREFBVztBQUMxRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpREFBUTtBQUN0QyxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHVEQUFjO0FBQ3BCO0FBQ0EsSUFBSSxTQUFTLHlEQUFnQjtBQUM3QjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5REFBZ0I7QUFDeEI7QUFDQSxNQUFNLFNBQVMsb0RBQVc7QUFDMUI7QUFDQSxNQUFNLFNBQVMsdURBQWM7QUFDN0I7QUFDQTtBQUNBLE1BQU0sU0FBUyx5REFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0RBQVc7QUFDckI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvREFBVztBQUNuQjtBQUNBO0FBQ0EsU0FBUyx1REFBYztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG9EQUFXO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpREFBUTtBQUNqQztBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzREFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixxQ0FBcUMsbUJBQW1CO0FBQ3hEO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsWUFBWTtBQUNaO0FBQ0EsdUNBQXVDO0FBQ3ZDLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0RBQWU7QUFDbEMsc0JBQXNCLDZEQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5REFBZ0Isa0JBQWtCLGdFQUFZLGtCQUFrQiwwREFBVztBQUNuRjtBQUNBLFVBQVUsMERBQVc7QUFDckI7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHVCQUF1QixtRUFBbUIsaUJBQWlCLDBEQUFlO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCw2REFBb0I7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxVQUFVLE9BQU8sVUFBVSxhQUFhLFVBQVUsT0FBTyxVQUFVLEtBQUssVUFBVTtBQUNuSSxNQUFNO0FBQ04seURBQXlELFVBQVUsS0FBSyxVQUFVLFNBQVMsVUFBVSxTQUFTLFVBQVUsV0FBVyxVQUFVLCtCQUErQixVQUFVLFdBQVcsVUFBVTtBQUMzTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsYUFBYTtBQUM5RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU8sNERBQW1CO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyw0REFBbUI7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUseURBQWdCO0FBQzFCO0FBQ0E7QUFDQSxVQUFVLG9EQUFXO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFhO0FBQ25DLDBCQUEwQiw4REFBcUI7QUFDL0MsSUFBSSxzREFBYTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBEQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdCQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsZ0JBQWdCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGtEQUFhO0FBQ3BELCtDQUErQyxrREFBYTs7QUFFNUQ7QUFDQTtBQUNBLFNBQVMsMERBQWlCLG9CQUFvQiwwREFBaUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0RBQVc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywwREFBVztBQUM1QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxHQUFHO0FBQ3pDO0FBQ0E7QUFDQSwyQkFBMkIsSUFBSTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsSUFBSSxHQUFHLEdBQUc7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0VBQW1CO0FBQ3hDLFFBQVEsMERBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxTQUFTLDBEQUFXO0FBQzFCO0FBQ0E7QUFDQSxNQUFNO0FBQ04sbUJBQW1CLDhEQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw4REFBZTtBQUN2QjtBQUNBO0FBQ0EsWUFBWSwwREFBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsNEJBQTRCLG1DQUFtQyxzQ0FBc0M7QUFDcko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkRBQVc7QUFDNUI7QUFDQSxTQUFTLGtFQUFjO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0VBQWtCO0FBQzdCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseURBQVM7QUFDMUI7QUFDQSxTQUFTLGdFQUFZO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdFQUFZO0FBQ3RCLGdFQUFnRSw2REFBb0I7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvRUFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtREFBUTtBQUN6QjtBQUNBLFNBQVMsMERBQVc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw4REFBZTtBQUN6QztBQUNBLFVBQVU7QUFDVjtBQUNBLDBCQUEwQiw4REFBZTtBQUN6QztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esd0JBQXdCLDhEQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3REFBZTtBQUN0QztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsZUFBZSw4REFBZTtBQUM5QixPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1EQUFRLEVBQUUsdURBQVk7QUFDdkM7QUFDQSxXQUFXLDBEQUFXO0FBQ3RCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1EQUFRLEVBQUUsdURBQVk7QUFDdkM7QUFDQSxXQUFXLDBEQUFXO0FBQ3RCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1EQUFRLEVBQUUsdURBQVk7QUFDdkM7QUFDQSxXQUFXLDBEQUFXO0FBQ3RCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1EQUFRO0FBQ3pCO0FBQ0EsU0FBUywwREFBVztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msc0JBQXNCLElBQUksZUFBZSxHQUFHLE1BQU0sVUFBVSxzQkFBc0IsSUFBSSxjQUFjO0FBQ3hJO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxvREFBVztBQUNuRDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDhEQUFlO0FBQ3BDO0FBQ0EsS0FBSztBQUNMLHlCQUF5Qix3REFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXFhIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVzc29uLWF1dGhvcmluZy8uL25vZGVfbW9kdWxlcy8ucG5wbS9AbGV4aWNhbCttYXJrZG93bkAwLjIwLjAvbm9kZV9tb2R1bGVzL0BsZXhpY2FsL21hcmtkb3duL0xleGljYWxNYXJrZG93bi5kZXYubWpzP2JlOTUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyAkaXNQYXJhZ3JhcGhOb2RlLCAkaXNUZXh0Tm9kZSwgJGdldFJvb3QsICRpc0VsZW1lbnROb2RlLCAkaXNEZWNvcmF0b3JOb2RlLCAkaXNMaW5lQnJlYWtOb2RlLCAkZ2V0U2VsZWN0aW9uLCAkY3JlYXRlVGV4dE5vZGUsICRjcmVhdGVQYXJhZ3JhcGhOb2RlLCAkY3JlYXRlTGluZUJyZWFrTm9kZSwgJGlzUmFuZ2VTZWxlY3Rpb24sICRpc1Jvb3RPclNoYWRvd1Jvb3QsICRjcmVhdGVSYW5nZVNlbGVjdGlvbiwgJHNldFNlbGVjdGlvbiB9IGZyb20gJ2xleGljYWwnO1xuaW1wb3J0IHsgJGlzTGlzdE5vZGUsICRpc0xpc3RJdGVtTm9kZSwgTGlzdE5vZGUsIExpc3RJdGVtTm9kZSwgJGNyZWF0ZUxpc3RJdGVtTm9kZSwgJGNyZWF0ZUxpc3ROb2RlIH0gZnJvbSAnQGxleGljYWwvbGlzdCc7XG5pbXBvcnQgeyAkaXNRdW90ZU5vZGUsIEhlYWRpbmdOb2RlLCAkaXNIZWFkaW5nTm9kZSwgUXVvdGVOb2RlLCAkY3JlYXRlUXVvdGVOb2RlLCAkY3JlYXRlSGVhZGluZ05vZGUgfSBmcm9tICdAbGV4aWNhbC9yaWNoLXRleHQnO1xuaW1wb3J0IHsgJGZpbmRNYXRjaGluZ1BhcmVudCB9IGZyb20gJ0BsZXhpY2FsL3V0aWxzJztcbmltcG9ydCB7ICRpc0NvZGVOb2RlLCBDb2RlTm9kZSwgJGNyZWF0ZUNvZGVOb2RlIH0gZnJvbSAnQGxleGljYWwvY29kZSc7XG5pbXBvcnQgeyBMaW5rTm9kZSwgJGlzTGlua05vZGUsICRjcmVhdGVMaW5rTm9kZSB9IGZyb20gJ0BsZXhpY2FsL2xpbmsnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIGluZGV4QnkobGlzdCwgY2FsbGJhY2spIHtcbiAgY29uc3QgaW5kZXggPSB7fTtcbiAgZm9yIChjb25zdCBpdGVtIG9mIGxpc3QpIHtcbiAgICBjb25zdCBrZXkgPSBjYWxsYmFjayhpdGVtKTtcbiAgICBpZiAoIWtleSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChpbmRleFtrZXldKSB7XG4gICAgICBpbmRleFtrZXldLnB1c2goaXRlbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGV4W2tleV0gPSBbaXRlbV07XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybWVyc0J5VHlwZSh0cmFuc2Zvcm1lcnMpIHtcbiAgY29uc3QgYnlUeXBlID0gaW5kZXhCeSh0cmFuc2Zvcm1lcnMsIHQgPT4gdC50eXBlKTtcbiAgcmV0dXJuIHtcbiAgICBlbGVtZW50OiBieVR5cGUuZWxlbWVudCB8fCBbXSxcbiAgICBtdWx0aWxpbmVFbGVtZW50OiBieVR5cGVbJ211bHRpbGluZS1lbGVtZW50J10gfHwgW10sXG4gICAgdGV4dEZvcm1hdDogYnlUeXBlWyd0ZXh0LWZvcm1hdCddIHx8IFtdLFxuICAgIHRleHRNYXRjaDogYnlUeXBlWyd0ZXh0LW1hdGNoJ10gfHwgW11cbiAgfTtcbn1cbmNvbnN0IFBVTkNUVUFUSU9OX09SX1NQQUNFID0gL1shLS86LUBbLWB7LX5cXHNdLztcbmNvbnN0IE1BUktET1dOX0VNUFRZX0xJTkVfUkVHX0VYUCA9IC9eXFxzezAsM30kLztcbmZ1bmN0aW9uIGlzRW1wdHlQYXJhZ3JhcGgobm9kZSkge1xuICBpZiAoISRpc1BhcmFncmFwaE5vZGUobm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZmlyc3RDaGlsZCA9IG5vZGUuZ2V0Rmlyc3RDaGlsZCgpO1xuICByZXR1cm4gZmlyc3RDaGlsZCA9PSBudWxsIHx8IG5vZGUuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDEgJiYgJGlzVGV4dE5vZGUoZmlyc3RDaGlsZCkgJiYgTUFSS0RPV05fRU1QVFlfTElORV9SRUdfRVhQLnRlc3QoZmlyc3RDaGlsZC5nZXRUZXh0Q29udGVudCgpKTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5cbi8qKlxuICogUmVuZGVycyBzdHJpbmcgZnJvbSBtYXJrZG93bi4gVGhlIHNlbGVjdGlvbiBpcyBtb3ZlZCB0byB0aGUgc3RhcnQgYWZ0ZXIgdGhlIG9wZXJhdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWFya2Rvd25FeHBvcnQodHJhbnNmb3JtZXJzLCBzaG91bGRQcmVzZXJ2ZU5ld0xpbmVzID0gZmFsc2UpIHtcbiAgY29uc3QgYnlUeXBlID0gdHJhbnNmb3JtZXJzQnlUeXBlKHRyYW5zZm9ybWVycyk7XG4gIGNvbnN0IGVsZW1lbnRUcmFuc2Zvcm1lcnMgPSBbLi4uYnlUeXBlLm11bHRpbGluZUVsZW1lbnQsIC4uLmJ5VHlwZS5lbGVtZW50XTtcbiAgY29uc3QgaXNOZXdsaW5lRGVsaW1pdGVkID0gIXNob3VsZFByZXNlcnZlTmV3TGluZXM7XG5cbiAgLy8gRXhwb3J0IG9ubHkgdXNlcyB0ZXh0IGZvcm1hdHMgdGhhdCBhcmUgcmVzcG9uc2libGUgZm9yIHNpbmdsZSBmb3JtYXRcbiAgLy8gZS5nLiBpdCB3aWxsIGZpbHRlciBvdXQgKioqIChib2xkLCBpdGFsaWMpIGFuZCBpbnN0ZWFkIHVzZSBzZXBhcmF0ZSAqKiBhbmQgKlxuICBjb25zdCB0ZXh0Rm9ybWF0VHJhbnNmb3JtZXJzID0gYnlUeXBlLnRleHRGb3JtYXQuZmlsdGVyKHRyYW5zZm9ybWVyID0+IHRyYW5zZm9ybWVyLmZvcm1hdC5sZW5ndGggPT09IDEpO1xuICByZXR1cm4gbm9kZSA9PiB7XG4gICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgY29uc3QgY2hpbGRyZW4gPSAobm9kZSB8fCAkZ2V0Um9vdCgpKS5nZXRDaGlsZHJlbigpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBjb25zdCByZXN1bHQgPSBleHBvcnRUb3BMZXZlbEVsZW1lbnRzKGNoaWxkLCBlbGVtZW50VHJhbnNmb3JtZXJzLCB0ZXh0Rm9ybWF0VHJhbnNmb3JtZXJzLCBieVR5cGUudGV4dE1hdGNoKTtcbiAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBvdXRwdXQucHVzaChcbiAgICAgICAgLy8gc2VwYXJhdGUgY29uc2VjdXRpdmUgZ3JvdXAgb2YgdGV4dHMgd2l0aCBhIGxpbmUgYnJlYWs6IGVnLiBbXCJoZWxsb1wiLCBcIndvcmxkXCJdIC0+IFtcImhlbGxvXCIsIFwiL253b3JsZFwiXVxuICAgICAgICBpc05ld2xpbmVEZWxpbWl0ZWQgJiYgaSA+IDAgJiYgIWlzRW1wdHlQYXJhZ3JhcGgoY2hpbGQpICYmICFpc0VtcHR5UGFyYWdyYXBoKGNoaWxkcmVuW2kgLSAxXSkgPyAnXFxuJy5jb25jYXQocmVzdWx0KSA6IHJlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEVuc3VyZSBjb25zZWN1dGl2ZSBncm91cHMgb2YgdGV4dHMgYXJlIGF0IGxlYXN0IFxcblxcbiBhcGFydCB3aGlsZSBlYWNoIGVtcHR5IHBhcmFncmFwaCByZW5kZXIgYXMgYSBuZXdsaW5lLlxuICAgIC8vIEVnLiBbXCJoZWxsb1wiLCBcIlwiLCBcIlwiLCBcImhpXCIsIFwiXFxud29ybGRcIl0gLT4gXCJoZWxsb1xcblxcblxcbmhpXFxuXFxud29ybGRcIlxuICAgIHJldHVybiBvdXRwdXQuam9pbignXFxuJyk7XG4gIH07XG59XG5mdW5jdGlvbiBleHBvcnRUb3BMZXZlbEVsZW1lbnRzKG5vZGUsIGVsZW1lbnRUcmFuc2Zvcm1lcnMsIHRleHRUcmFuc2Zvcm1lcnNJbmRleCwgdGV4dE1hdGNoVHJhbnNmb3JtZXJzKSB7XG4gIGZvciAoY29uc3QgdHJhbnNmb3JtZXIgb2YgZWxlbWVudFRyYW5zZm9ybWVycykge1xuICAgIGlmICghdHJhbnNmb3JtZXIuZXhwb3J0KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gdHJhbnNmb3JtZXIuZXhwb3J0KG5vZGUsIF9ub2RlID0+IGV4cG9ydENoaWxkcmVuKF9ub2RlLCB0ZXh0VHJhbnNmb3JtZXJzSW5kZXgsIHRleHRNYXRjaFRyYW5zZm9ybWVycykpO1xuICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cbiAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgcmV0dXJuIGV4cG9ydENoaWxkcmVuKG5vZGUsIHRleHRUcmFuc2Zvcm1lcnNJbmRleCwgdGV4dE1hdGNoVHJhbnNmb3JtZXJzKTtcbiAgfSBlbHNlIGlmICgkaXNEZWNvcmF0b3JOb2RlKG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gZXhwb3J0Q2hpbGRyZW4obm9kZSwgdGV4dFRyYW5zZm9ybWVyc0luZGV4LCB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnMpIHtcbiAgY29uc3Qgb3V0cHV0ID0gW107XG4gIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5nZXRDaGlsZHJlbigpO1xuICBtYWluTG9vcDogZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgIGZvciAoY29uc3QgdHJhbnNmb3JtZXIgb2YgdGV4dE1hdGNoVHJhbnNmb3JtZXJzKSB7XG4gICAgICBpZiAoIXRyYW5zZm9ybWVyLmV4cG9ydCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRyYW5zZm9ybWVyLmV4cG9ydChjaGlsZCwgcGFyZW50Tm9kZSA9PiBleHBvcnRDaGlsZHJlbihwYXJlbnROb2RlLCB0ZXh0VHJhbnNmb3JtZXJzSW5kZXgsIHRleHRNYXRjaFRyYW5zZm9ybWVycyksICh0ZXh0Tm9kZSwgdGV4dENvbnRlbnQpID0+IGV4cG9ydFRleHRGb3JtYXQodGV4dE5vZGUsIHRleHRDb250ZW50LCB0ZXh0VHJhbnNmb3JtZXJzSW5kZXgpKTtcbiAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBvdXRwdXQucHVzaChyZXN1bHQpO1xuICAgICAgICBjb250aW51ZSBtYWluTG9vcDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCRpc0xpbmVCcmVha05vZGUoY2hpbGQpKSB7XG4gICAgICBvdXRwdXQucHVzaCgnXFxuJyk7XG4gICAgfSBlbHNlIGlmICgkaXNUZXh0Tm9kZShjaGlsZCkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGV4cG9ydFRleHRGb3JtYXQoY2hpbGQsIGNoaWxkLmdldFRleHRDb250ZW50KCksIHRleHRUcmFuc2Zvcm1lcnNJbmRleCkpO1xuICAgIH0gZWxzZSBpZiAoJGlzRWxlbWVudE5vZGUoY2hpbGQpKSB7XG4gICAgICAvLyBlbXB0eSBwYXJhZ3JhcGggcmV0dXJucyBcIlwiXG4gICAgICBvdXRwdXQucHVzaChleHBvcnRDaGlsZHJlbihjaGlsZCwgdGV4dFRyYW5zZm9ybWVyc0luZGV4LCB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnMpKTtcbiAgICB9IGVsc2UgaWYgKCRpc0RlY29yYXRvck5vZGUoY2hpbGQpKSB7XG4gICAgICBvdXRwdXQucHVzaChjaGlsZC5nZXRUZXh0Q29udGVudCgpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbn1cbmZ1bmN0aW9uIGV4cG9ydFRleHRGb3JtYXQobm9kZSwgdGV4dENvbnRlbnQsIHRleHRUcmFuc2Zvcm1lcnMpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiBoYW5kbGVzIHRoZSBjYXNlIG9mIGEgc3RyaW5nIGxvb2tpbmcgbGlrZSB0aGlzOiBcIiAgIGZvbyAgIFwiXG4gIC8vIFdoZXJlIGl0IHdvdWxkIGJlIGludmFsaWQgbWFya2Rvd24gdG8gZ2VuZXJhdGU6IFwiKiogICBmb28gICAqKlwiXG4gIC8vIFdlIGluc3RlYWQgd2FudCB0byB0cmltIHRoZSB3aGl0ZXNwYWNlIG91dCwgYXBwbHkgZm9ybWF0dGluZywgYW5kIHRoZW5cbiAgLy8gYnJpbmcgdGhlIHdoaXRlc3BhY2UgYmFjay4gU28gb3VyIHJldHVybmVkIHN0cmluZyBsb29rcyBsaWtlIHRoaXM6IFwiICAgKipmb28qKiAgIFwiXG4gIGNvbnN0IGZyb3plblN0cmluZyA9IHRleHRDb250ZW50LnRyaW0oKTtcbiAgbGV0IG91dHB1dCA9IGZyb3plblN0cmluZztcbiAgY29uc3QgYXBwbGllZCA9IG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCB0cmFuc2Zvcm1lciBvZiB0ZXh0VHJhbnNmb3JtZXJzKSB7XG4gICAgY29uc3QgZm9ybWF0ID0gdHJhbnNmb3JtZXIuZm9ybWF0WzBdO1xuICAgIGNvbnN0IHRhZyA9IHRyYW5zZm9ybWVyLnRhZztcbiAgICBpZiAoaGFzRm9ybWF0KG5vZGUsIGZvcm1hdCkgJiYgIWFwcGxpZWQuaGFzKGZvcm1hdCkpIHtcbiAgICAgIC8vIE11bHRpcGxlIHRhZ3MgbWlnaHQgYmUgdXNlZCBmb3IgdGhlIHNhbWUgZm9ybWF0ICgqLCBfKVxuICAgICAgYXBwbGllZC5hZGQoZm9ybWF0KTtcbiAgICAgIC8vIFByZXZlbnQgYWRkaW5nIG9wZW5pbmcgdGFnIGlzIGFscmVhZHkgb3BlbmVkIGJ5IHRoZSBwcmV2aW91cyBzaWJsaW5nXG4gICAgICBjb25zdCBwcmV2aW91c05vZGUgPSBnZXRUZXh0U2libGluZyhub2RlLCB0cnVlKTtcbiAgICAgIGlmICghaGFzRm9ybWF0KHByZXZpb3VzTm9kZSwgZm9ybWF0KSkge1xuICAgICAgICBvdXRwdXQgPSB0YWcgKyBvdXRwdXQ7XG4gICAgICB9XG5cbiAgICAgIC8vIFByZXZlbnQgYWRkaW5nIGNsb3NpbmcgdGFnIGlmIG5leHQgc2libGluZyB3aWxsIGRvIGl0XG4gICAgICBjb25zdCBuZXh0Tm9kZSA9IGdldFRleHRTaWJsaW5nKG5vZGUsIGZhbHNlKTtcbiAgICAgIGlmICghaGFzRm9ybWF0KG5leHROb2RlLCBmb3JtYXQpKSB7XG4gICAgICAgIG91dHB1dCArPSB0YWc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmVwbGFjZSB0cmltbWVkIHZlcnNpb24gb2YgdGV4dENvbnRlbnQgZW5zdXJpbmcgc3Vycm91bmRpbmcgd2hpdGVzcGFjZSBpcyBub3QgbW9kaWZpZWRcbiAgcmV0dXJuIHRleHRDb250ZW50LnJlcGxhY2UoZnJvemVuU3RyaW5nLCAoKSA9PiBvdXRwdXQpO1xufVxuXG4vLyBHZXQgbmV4dCBvciBwcmV2aW91cyB0ZXh0IHNpYmxpbmcgYSB0ZXh0IG5vZGUsIGluY2x1ZGluZyBjYXNlc1xuLy8gd2hlbiBpdCdzIGEgY2hpbGQgb2YgaW5saW5lIGVsZW1lbnQgKGUuZy4gbGluaylcbmZ1bmN0aW9uIGdldFRleHRTaWJsaW5nKG5vZGUsIGJhY2t3YXJkKSB7XG4gIGxldCBzaWJsaW5nID0gYmFja3dhcmQgPyBub2RlLmdldFByZXZpb3VzU2libGluZygpIDogbm9kZS5nZXROZXh0U2libGluZygpO1xuICBpZiAoIXNpYmxpbmcpIHtcbiAgICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICBpZiAocGFyZW50LmlzSW5saW5lKCkpIHtcbiAgICAgIHNpYmxpbmcgPSBiYWNrd2FyZCA/IHBhcmVudC5nZXRQcmV2aW91c1NpYmxpbmcoKSA6IHBhcmVudC5nZXROZXh0U2libGluZygpO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoc2libGluZykge1xuICAgIGlmICgkaXNFbGVtZW50Tm9kZShzaWJsaW5nKSkge1xuICAgICAgaWYgKCFzaWJsaW5nLmlzSW5saW5lKCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBkZXNjZW5kYW50ID0gYmFja3dhcmQgPyBzaWJsaW5nLmdldExhc3REZXNjZW5kYW50KCkgOiBzaWJsaW5nLmdldEZpcnN0RGVzY2VuZGFudCgpO1xuICAgICAgaWYgKCRpc1RleHROb2RlKGRlc2NlbmRhbnQpKSB7XG4gICAgICAgIHJldHVybiBkZXNjZW5kYW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2libGluZyA9IGJhY2t3YXJkID8gc2libGluZy5nZXRQcmV2aW91c1NpYmxpbmcoKSA6IHNpYmxpbmcuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCRpc1RleHROb2RlKHNpYmxpbmcpKSB7XG4gICAgICByZXR1cm4gc2libGluZztcbiAgICB9XG4gICAgaWYgKCEkaXNFbGVtZW50Tm9kZShzaWJsaW5nKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gaGFzRm9ybWF0KG5vZGUsIGZvcm1hdCkge1xuICByZXR1cm4gJGlzVGV4dE5vZGUobm9kZSkgJiYgbm9kZS5oYXNGb3JtYXQoZm9ybWF0KTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBDQU5fVVNFX0RPTSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgZG9jdW1lbnRNb2RlID0gQ0FOX1VTRV9ET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQgPyBkb2N1bWVudC5kb2N1bWVudE1vZGUgOiBudWxsO1xuQ0FOX1VTRV9ET00gJiYgJ0lucHV0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlID8gJ2dldFRhcmdldFJhbmdlcycgaW4gbmV3IHdpbmRvdy5JbnB1dEV2ZW50KCdpbnB1dCcpIDogZmFsc2U7XG5jb25zdCBJU19TQUZBUkkgPSBDQU5fVVNFX0RPTSAmJiAvVmVyc2lvblxcL1tcXGQuXSsuKlNhZmFyaS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbmNvbnN0IElTX0lPUyA9IENBTl9VU0VfRE9NICYmIC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICF3aW5kb3cuTVNTdHJlYW07XG5cbi8vIEtlZXAgdGhlc2UgaW4gY2FzZSB3ZSBuZWVkIHRvIHVzZSB0aGVtIGluIHRoZSBmdXR1cmUuXG4vLyBleHBvcnQgY29uc3QgSVNfV0lORE9XUzogYm9vbGVhbiA9IENBTl9VU0VfRE9NICYmIC9XaW4vLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKTtcbmNvbnN0IElTX0NIUk9NRSA9IENBTl9VU0VfRE9NICYmIC9eKD89LipDaHJvbWUpLiovaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuY29uc3QgSVNfQVBQTEVfV0VCS0lUID0gQ0FOX1VTRV9ET00gJiYgL0FwcGxlV2ViS2l0XFwvW1xcZC5dKy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhSVNfQ0hST01FO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKlxuICogUmVuZGVycyBtYXJrZG93biBmcm9tIGEgc3RyaW5nLiBUaGUgc2VsZWN0aW9uIGlzIG1vdmVkIHRvIHRoZSBzdGFydCBhZnRlciB0aGUgb3BlcmF0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVNYXJrZG93bkltcG9ydCh0cmFuc2Zvcm1lcnMsIHNob3VsZFByZXNlcnZlTmV3TGluZXMgPSBmYWxzZSkge1xuICBjb25zdCBieVR5cGUgPSB0cmFuc2Zvcm1lcnNCeVR5cGUodHJhbnNmb3JtZXJzKTtcbiAgY29uc3QgdGV4dEZvcm1hdFRyYW5zZm9ybWVyc0luZGV4ID0gY3JlYXRlVGV4dEZvcm1hdFRyYW5zZm9ybWVyc0luZGV4KGJ5VHlwZS50ZXh0Rm9ybWF0KTtcbiAgcmV0dXJuIChtYXJrZG93blN0cmluZywgbm9kZSkgPT4ge1xuICAgIGNvbnN0IGxpbmVzID0gbWFya2Rvd25TdHJpbmcuc3BsaXQoJ1xcbicpO1xuICAgIGNvbnN0IGxpbmVzTGVuZ3RoID0gbGluZXMubGVuZ3RoO1xuICAgIGNvbnN0IHJvb3QgPSBub2RlIHx8ICRnZXRSb290KCk7XG4gICAgcm9vdC5jbGVhcigpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXNMZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbGluZVRleHQgPSBsaW5lc1tpXTtcbiAgICAgIGNvbnN0IFtpbXBvcnRlZCwgc2hpZnRlZEluZGV4XSA9ICRpbXBvcnRNdWx0aWxpbmUobGluZXMsIGksIGJ5VHlwZS5tdWx0aWxpbmVFbGVtZW50LCByb290KTtcbiAgICAgIGlmIChpbXBvcnRlZCkge1xuICAgICAgICAvLyBJZiBhIG11bHRpbGluZSBtYXJrZG93biBlbGVtZW50IHdhcyBpbXBvcnRlZCwgd2UgZG9uJ3Qgd2FudCB0byBwcm9jZXNzIHRoZSBsaW5lcyB0aGF0IHdlcmUgcGFydCBvZiBpdCBhbnltb3JlLlxuICAgICAgICAvLyBUaGVyZSBjb3VsZCBiZSBvdGhlciBzdWItbWFya2Rvd24gZWxlbWVudHMgKGJvdGggbXVsdGlsaW5lIGFuZCBub3JtYWwgb25lcykgbWF0Y2hpbmcgd2l0aGluIHRoaXMgbWF0Y2hlZCBtdWx0aWxpbmUgZWxlbWVudCdzIGNoaWxkcmVuLlxuICAgICAgICAvLyBIb3dldmVyLCBpdCB3b3VsZCBiZSB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhlIG1hdGNoZWQgbXVsdGlsaW5lIHRyYW5zZm9ybWVyIHRvIGRlY2lkZSBob3cgaXQgd2FudHMgdG8gaGFuZGxlIHRoZW0uXG4gICAgICAgIC8vIFdlIGNhbm5vdCBoYW5kbGUgdGhvc2UsIGFzIHRoZXJlIGlzIG5vIHdheSBmb3IgdXMgdG8ga25vdyBob3cgdG8gbWFpbnRhaW4gdGhlIGNvcnJlY3Qgb3JkZXIgb2YgZ2VuZXJhdGVkIGxleGljYWwgbm9kZXMgZm9yIHBvc3NpYmxlIGNoaWxkcmVuLlxuICAgICAgICBpID0gc2hpZnRlZEluZGV4OyAvLyBOZXh0IGxvb3Agd2lsbCBzdGFydCBmcm9tIHRoZSBsaW5lIGFmdGVyIHRoZSBsYXN0IGxpbmUgb2YgdGhlIG11bHRpbGluZSBlbGVtZW50XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgJGltcG9ydEJsb2NrcyhsaW5lVGV4dCwgcm9vdCwgYnlUeXBlLmVsZW1lbnQsIHRleHRGb3JtYXRUcmFuc2Zvcm1lcnNJbmRleCwgYnlUeXBlLnRleHRNYXRjaCk7XG4gICAgfVxuXG4gICAgLy8gQnkgZGVmYXVsdCwgcmVtb3ZpbmcgZW1wdHkgcGFyYWdyYXBocyBhcyBtZCBkb2VzIG5vdCByZWFsbHlcbiAgICAvLyBhbGxvdyBlbXB0eSBsaW5lcyBhbmQgdXNlcyB0aGVtIGFzIGRlbGltaXRlci5cbiAgICAvLyBJZiB5b3UgbmVlZCBlbXB0eSBsaW5lcyBzZXQgc2hvdWxkUHJlc2VydmVOZXdMaW5lcyA9IHRydWUuXG4gICAgY29uc3QgY2hpbGRyZW4gPSByb290LmdldENoaWxkcmVuKCk7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgaWYgKCFzaG91bGRQcmVzZXJ2ZU5ld0xpbmVzICYmIGlzRW1wdHlQYXJhZ3JhcGgoY2hpbGQpICYmIHJvb3QuZ2V0Q2hpbGRyZW5TaXplKCkgPiAxKSB7XG4gICAgICAgIGNoaWxkLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoJGdldFNlbGVjdGlvbigpICE9PSBudWxsKSB7XG4gICAgICByb290LnNlbGVjdFN0YXJ0KCk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqXG4gKiBAcmV0dXJucyBmaXJzdCBlbGVtZW50IG9mIHRoZSByZXR1cm5lZCB0dXBsZSBpcyBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBhIG11bHRpbGluZSBlbGVtZW50IHdhcyBpbXBvcnRlZC4gVGhlIHNlY29uZCBlbGVtZW50IGlzIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBsaW5lIHRoYXQgd2FzIHByb2Nlc3NlZC5cbiAqL1xuZnVuY3Rpb24gJGltcG9ydE11bHRpbGluZShsaW5lcywgc3RhcnRMaW5lSW5kZXgsIG11bHRpbGluZUVsZW1lbnRUcmFuc2Zvcm1lcnMsIHJvb3ROb2RlKSB7XG4gIGZvciAoY29uc3QgdHJhbnNmb3JtZXIgb2YgbXVsdGlsaW5lRWxlbWVudFRyYW5zZm9ybWVycykge1xuICAgIGNvbnN0IHtcbiAgICAgIGhhbmRsZUltcG9ydEFmdGVyU3RhcnRNYXRjaCxcbiAgICAgIHJlZ0V4cEVuZCxcbiAgICAgIHJlZ0V4cFN0YXJ0LFxuICAgICAgcmVwbGFjZVxuICAgIH0gPSB0cmFuc2Zvcm1lcjtcbiAgICBjb25zdCBzdGFydE1hdGNoID0gbGluZXNbc3RhcnRMaW5lSW5kZXhdLm1hdGNoKHJlZ0V4cFN0YXJ0KTtcbiAgICBpZiAoIXN0YXJ0TWF0Y2gpIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBUcnkgbmV4dCB0cmFuc2Zvcm1lclxuICAgIH1cbiAgICBpZiAoaGFuZGxlSW1wb3J0QWZ0ZXJTdGFydE1hdGNoKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBoYW5kbGVJbXBvcnRBZnRlclN0YXJ0TWF0Y2goe1xuICAgICAgICBsaW5lcyxcbiAgICAgICAgcm9vdE5vZGUsXG4gICAgICAgIHN0YXJ0TGluZUluZGV4LFxuICAgICAgICBzdGFydE1hdGNoLFxuICAgICAgICB0cmFuc2Zvcm1lclxuICAgICAgfSk7XG4gICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVnZXhwRW5kUmVnZXggPSB0eXBlb2YgcmVnRXhwRW5kID09PSAnb2JqZWN0JyAmJiAncmVnRXhwJyBpbiByZWdFeHBFbmQgPyByZWdFeHBFbmQucmVnRXhwIDogcmVnRXhwRW5kO1xuICAgIGNvbnN0IGlzRW5kT3B0aW9uYWwgPSByZWdFeHBFbmQgJiYgdHlwZW9mIHJlZ0V4cEVuZCA9PT0gJ29iamVjdCcgJiYgJ29wdGlvbmFsJyBpbiByZWdFeHBFbmQgPyByZWdFeHBFbmQub3B0aW9uYWwgOiAhcmVnRXhwRW5kO1xuICAgIGxldCBlbmRMaW5lSW5kZXggPSBzdGFydExpbmVJbmRleDtcbiAgICBjb25zdCBsaW5lc0xlbmd0aCA9IGxpbmVzLmxlbmd0aDtcblxuICAgIC8vIGNoZWNrIGV2ZXJ5IHNpbmdsZSBsaW5lIGZvciB0aGUgY2xvc2luZyBtYXRjaC4gSXQgY291bGQgYWxzbyBiZSBvbiB0aGUgc2FtZSBsaW5lIGFzIHRoZSBvcGVuaW5nIG1hdGNoLlxuICAgIHdoaWxlIChlbmRMaW5lSW5kZXggPCBsaW5lc0xlbmd0aCkge1xuICAgICAgY29uc3QgZW5kTWF0Y2ggPSByZWdleHBFbmRSZWdleCA/IGxpbmVzW2VuZExpbmVJbmRleF0ubWF0Y2gocmVnZXhwRW5kUmVnZXgpIDogbnVsbDtcbiAgICAgIGlmICghZW5kTWF0Y2gpIHtcbiAgICAgICAgaWYgKCFpc0VuZE9wdGlvbmFsIHx8IGlzRW5kT3B0aW9uYWwgJiYgZW5kTGluZUluZGV4IDwgbGluZXNMZW5ndGggLSAxIC8vIE9wdGlvbmFsIGVuZCwgYnV0IGRpZG4ndCByZWFjaCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudCB5ZXQgPT4gY29udGludWUgc2VhcmNoaW5nIGZvciBwb3RlbnRpYWwgY2xvc2luZyBtYXRjaFxuICAgICAgICApIHtcbiAgICAgICAgICBlbmRMaW5lSW5kZXgrKztcbiAgICAgICAgICBjb250aW51ZTsgLy8gU2VhcmNoIG5leHQgbGluZSBmb3IgY2xvc2luZyBtYXRjaFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE5vdywgY2hlY2sgaWYgdGhlIGNsb3NpbmcgbWF0Y2ggbWF0Y2hlZCBpcyB0aGUgc2FtZSBhcyB0aGUgb3BlbmluZyBtYXRjaC5cbiAgICAgIC8vIElmIGl0IGlzLCB3ZSBuZWVkIHRvIGNvbnRpbnVlIHNlYXJjaGluZyBmb3IgdGhlIGFjdHVhbCBjbG9zaW5nIG1hdGNoLlxuICAgICAgaWYgKGVuZE1hdGNoICYmIHN0YXJ0TGluZUluZGV4ID09PSBlbmRMaW5lSW5kZXggJiYgZW5kTWF0Y2guaW5kZXggPT09IHN0YXJ0TWF0Y2guaW5kZXgpIHtcbiAgICAgICAgZW5kTGluZUluZGV4Kys7XG4gICAgICAgIGNvbnRpbnVlOyAvLyBTZWFyY2ggbmV4dCBsaW5lIGZvciBjbG9zaW5nIG1hdGNoXG4gICAgICB9XG5cbiAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIGhhdmUgZm91bmQgdGhlIGNsb3NpbmcgbWF0Y2guIE5leHQ6IGNhbGN1bGF0ZSB0aGUgbGluZXMgaW4gYmV0d2VlbiBvcGVuIGFuZCBjbG9zaW5nIG1hdGNoXG4gICAgICAvLyBUaGlzIHNob3VsZCBub3QgaW5jbHVkZSB0aGUgbWF0Y2hlcyB0aGVtc2VsdmVzLCBhbmQgYmUgc3BsaXQgdXAgYnkgbGluZXNcbiAgICAgIGNvbnN0IGxpbmVzSW5CZXR3ZWVuID0gW107XG4gICAgICBpZiAoZW5kTWF0Y2ggJiYgc3RhcnRMaW5lSW5kZXggPT09IGVuZExpbmVJbmRleCkge1xuICAgICAgICBsaW5lc0luQmV0d2Vlbi5wdXNoKGxpbmVzW3N0YXJ0TGluZUluZGV4XS5zbGljZShzdGFydE1hdGNoWzBdLmxlbmd0aCwgLWVuZE1hdGNoWzBdLmxlbmd0aCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0TGluZUluZGV4OyBpIDw9IGVuZExpbmVJbmRleDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGkgPT09IHN0YXJ0TGluZUluZGV4KSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gbGluZXNbaV0uc2xpY2Uoc3RhcnRNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgICAgbGluZXNJbkJldHdlZW4ucHVzaCh0ZXh0KTsgLy8gQWxzbyBpbmNsdWRlIGVtcHR5IHRleHRcbiAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IGVuZExpbmVJbmRleCAmJiBlbmRNYXRjaCkge1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IGxpbmVzW2ldLnNsaWNlKDAsIC1lbmRNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgICAgbGluZXNJbkJldHdlZW4ucHVzaCh0ZXh0KTsgLy8gQWxzbyBpbmNsdWRlIGVtcHR5IHRleHRcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGluZXNJbkJldHdlZW4ucHVzaChsaW5lc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVwbGFjZShyb290Tm9kZSwgbnVsbCwgc3RhcnRNYXRjaCwgZW5kTWF0Y2gsIGxpbmVzSW5CZXR3ZWVuLCB0cnVlKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgLy8gUmV0dXJuIGhlcmUuIFRoaXMgJGltcG9ydE11bHRpbGluZSBmdW5jdGlvbiBpcyBydW4gbGluZSBieSBsaW5lIGFuZCBzaG91bGQgb25seSBwcm9jZXNzIGEgc2luZ2xlIG11bHRpbGluZSBlbGVtZW50IGF0IGEgdGltZS5cbiAgICAgICAgcmV0dXJuIFt0cnVlLCBlbmRMaW5lSW5kZXhdO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgcmVwbGFjZSBmdW5jdGlvbiByZXR1cm5lZCBmYWxzZSwgZGVzcGl0ZSBmaW5kaW5nIHRoZSBtYXRjaGluZyBvcGVuIGFuZCBjbG9zZSB0YWdzID0+IHRoaXMgdHJhbnNmb3JtZXIgZG9lcyBub3Qgd2FudCB0byBoYW5kbGUgaXQuXG4gICAgICAvLyBUaHVzLCB3ZSBjb250aW51ZSBsZXR0aW5nIHRoZSByZW1haW5pbmcgdHJhbnNmb3JtZXJzIGhhbmRsZSB0aGUgcGFzc2VkIGxpbmVzIG9mIHRleHQgZnJvbSB0aGUgYmVnaW5uaW5nXG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBObyBtdWx0aWxpbmUgdHJhbnNmb3JtZXIgaGFuZGxlZCB0aGlzIGxpbmUgc3VjY2Vzc2Z1bGx5XG4gIHJldHVybiBbZmFsc2UsIHN0YXJ0TGluZUluZGV4XTtcbn1cbmZ1bmN0aW9uICRpbXBvcnRCbG9ja3MobGluZVRleHQsIHJvb3ROb2RlLCBlbGVtZW50VHJhbnNmb3JtZXJzLCB0ZXh0Rm9ybWF0VHJhbnNmb3JtZXJzSW5kZXgsIHRleHRNYXRjaFRyYW5zZm9ybWVycykge1xuICBjb25zdCB0ZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZShsaW5lVGV4dCk7XG4gIGNvbnN0IGVsZW1lbnROb2RlID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgZWxlbWVudE5vZGUuYXBwZW5kKHRleHROb2RlKTtcbiAgcm9vdE5vZGUuYXBwZW5kKGVsZW1lbnROb2RlKTtcbiAgZm9yIChjb25zdCB7XG4gICAgcmVnRXhwLFxuICAgIHJlcGxhY2VcbiAgfSBvZiBlbGVtZW50VHJhbnNmb3JtZXJzKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBsaW5lVGV4dC5tYXRjaChyZWdFeHApO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgdGV4dE5vZGUuc2V0VGV4dENvbnRlbnQobGluZVRleHQuc2xpY2UobWF0Y2hbMF0ubGVuZ3RoKSk7XG4gICAgICBpZiAocmVwbGFjZShlbGVtZW50Tm9kZSwgW3RleHROb2RlXSwgbWF0Y2gsIHRydWUpICE9PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaW1wb3J0VGV4dEZvcm1hdFRyYW5zZm9ybWVycyh0ZXh0Tm9kZSwgdGV4dEZvcm1hdFRyYW5zZm9ybWVyc0luZGV4LCB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnMpO1xuXG4gIC8vIElmIG5vIHRyYW5zZm9ybWVyIGZvdW5kIGFuZCB3ZSBsZWZ0IHdpdGggb3JpZ2luYWwgcGFyYWdyYXBoIG5vZGVcbiAgLy8gY2FuIGNoZWNrIGlmIGl0cyBjb250ZW50IGNhbiBiZSBhcHBlbmRlZCB0byB0aGUgcHJldmlvdXMgbm9kZVxuICAvLyBpZiBpdCdzIGEgcGFyYWdyYXBoLCBxdW90ZSBvciBsaXN0XG4gIGlmIChlbGVtZW50Tm9kZS5pc0F0dGFjaGVkKCkgJiYgbGluZVRleHQubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHByZXZpb3VzTm9kZSA9IGVsZW1lbnROb2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgIGlmICgkaXNQYXJhZ3JhcGhOb2RlKHByZXZpb3VzTm9kZSkgfHwgJGlzUXVvdGVOb2RlKHByZXZpb3VzTm9kZSkgfHwgJGlzTGlzdE5vZGUocHJldmlvdXNOb2RlKSkge1xuICAgICAgbGV0IHRhcmdldE5vZGUgPSBwcmV2aW91c05vZGU7XG4gICAgICBpZiAoJGlzTGlzdE5vZGUocHJldmlvdXNOb2RlKSkge1xuICAgICAgICBjb25zdCBsYXN0RGVzY2VuZGFudCA9IHByZXZpb3VzTm9kZS5nZXRMYXN0RGVzY2VuZGFudCgpO1xuICAgICAgICBpZiAobGFzdERlc2NlbmRhbnQgPT0gbnVsbCkge1xuICAgICAgICAgIHRhcmdldE5vZGUgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGxhc3REZXNjZW5kYW50LCAkaXNMaXN0SXRlbU5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGFyZ2V0Tm9kZSAhPSBudWxsICYmIHRhcmdldE5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkgPiAwKSB7XG4gICAgICAgIHRhcmdldE5vZGUuc3BsaWNlKHRhcmdldE5vZGUuZ2V0Q2hpbGRyZW5TaXplKCksIDAsIFskY3JlYXRlTGluZUJyZWFrTm9kZSgpLCAuLi5lbGVtZW50Tm9kZS5nZXRDaGlsZHJlbigpXSk7XG4gICAgICAgIGVsZW1lbnROb2RlLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBQcm9jZXNzaW5nIHRleHQgY29udGVudCBhbmQgcmVwbGFjZXMgdGV4dCBmb3JtYXQgdGFncy5cbi8vIEl0IHRha2VzIG91dGVybW9zdCB0YWcgbWF0Y2ggYW5kIGl0cyBjb250ZW50LCBjcmVhdGVzIHRleHQgbm9kZSB3aXRoXG4vLyBmb3JtYXQgYmFzZWQgb24gdGFnIGFuZCB0aGVuIHJlY3Vyc2l2ZWx5IGV4ZWN1dGVkIG92ZXIgbm9kZSdzIGNvbnRlbnRcbi8vXG4vLyBFLmcuIGZvciBcIipIZWxsbyAqKndvcmxkKiohKlwiIHN0cmluZyBpdCB3aWxsIGNyZWF0ZSB0ZXh0IG5vZGUgd2l0aFxuLy8gXCJIZWxsbyAqKndvcmxkKiohXCIgY29udGVudCBhbmQgaXRhbGljIGZvcm1hdCBhbmQgcnVuIHJlY3Vyc2l2ZWx5IG92ZXJcbi8vIGl0cyBjb250ZW50IHRvIHRyYW5zZm9ybSBcIioqd29ybGQqKlwiIHBhcnRcbmZ1bmN0aW9uIGltcG9ydFRleHRGb3JtYXRUcmFuc2Zvcm1lcnModGV4dE5vZGUsIHRleHRGb3JtYXRUcmFuc2Zvcm1lcnNJbmRleCwgdGV4dE1hdGNoVHJhbnNmb3JtZXJzKSB7XG4gIGNvbnN0IHRleHRDb250ZW50ID0gdGV4dE5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgY29uc3QgbWF0Y2ggPSBmaW5kT3V0ZXJtb3N0TWF0Y2godGV4dENvbnRlbnQsIHRleHRGb3JtYXRUcmFuc2Zvcm1lcnNJbmRleCk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICAvLyBPbmNlIHRleHQgZm9ybWF0IHByb2Nlc3NpbmcgaXMgZG9uZSBydW4gdGV4dCBtYXRjaCB0cmFuc2Zvcm1lcnMsIGFzIGl0XG4gICAgLy8gb25seSBjYW4gc3BhbiB3aXRoaW4gc2luZ2xlIHRleHQgbm9kZSAodW5saW5lIGZvcm1hdHMgdGhhdCBjYW4gY292ZXIgbXVsdGlwbGUgbm9kZXMpXG4gICAgaW1wb3J0VGV4dE1hdGNoVHJhbnNmb3JtZXJzKHRleHROb2RlLCB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnMpO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgY3VycmVudE5vZGUsIHJlbWFpbmRlck5vZGUsIGxlYWRpbmdOb2RlO1xuXG4gIC8vIElmIG1hdGNoaW5nIGZ1bGwgY29udGVudCB0aGVyZSdzIG5vIG5lZWQgdG8gcnVuIHNwbGl0VGV4dCBhbmQgY2FuIHJldXNlIGV4aXN0aW5nIHRleHROb2RlXG4gIC8vIHRvIHVwZGF0ZSBpdHMgY29udGVudCBhbmQgYXBwbHkgZm9ybWF0LiBFLmcuIGZvciAqKl9IZWxsb18qKiBzdHJpbmcgYWZ0ZXIgYXBwbHlpbmcgYm9sZFxuICAvLyBmb3JtYXQgKCoqKSBpdCB3aWxsIHJldXNlIHRoZSBzYW1lIHRleHQgbm9kZSB0byBhcHBseSBpdGFsaWMgKF8pXG4gIGlmIChtYXRjaFswXSA9PT0gdGV4dENvbnRlbnQpIHtcbiAgICBjdXJyZW50Tm9kZSA9IHRleHROb2RlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBtYXRjaC5pbmRleCB8fCAwO1xuICAgIGNvbnN0IGVuZEluZGV4ID0gc3RhcnRJbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICBpZiAoc3RhcnRJbmRleCA9PT0gMCkge1xuICAgICAgW2N1cnJlbnROb2RlLCByZW1haW5kZXJOb2RlXSA9IHRleHROb2RlLnNwbGl0VGV4dChlbmRJbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFtsZWFkaW5nTm9kZSwgY3VycmVudE5vZGUsIHJlbWFpbmRlck5vZGVdID0gdGV4dE5vZGUuc3BsaXRUZXh0KHN0YXJ0SW5kZXgsIGVuZEluZGV4KTtcbiAgICB9XG4gIH1cbiAgY3VycmVudE5vZGUuc2V0VGV4dENvbnRlbnQobWF0Y2hbMl0pO1xuICBjb25zdCB0cmFuc2Zvcm1lciA9IHRleHRGb3JtYXRUcmFuc2Zvcm1lcnNJbmRleC50cmFuc2Zvcm1lcnNCeVRhZ1ttYXRjaFsxXV07XG4gIGlmICh0cmFuc2Zvcm1lcikge1xuICAgIGZvciAoY29uc3QgZm9ybWF0IG9mIHRyYW5zZm9ybWVyLmZvcm1hdCkge1xuICAgICAgaWYgKCFjdXJyZW50Tm9kZS5oYXNGb3JtYXQoZm9ybWF0KSkge1xuICAgICAgICBjdXJyZW50Tm9kZS50b2dnbGVGb3JtYXQoZm9ybWF0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBSZWN1cnNpdmVseSBydW4gb3ZlciBpbm5lciB0ZXh0IGlmIGl0J3Mgbm90IGlubGluZSBjb2RlXG4gIGlmICghY3VycmVudE5vZGUuaGFzRm9ybWF0KCdjb2RlJykpIHtcbiAgICBpbXBvcnRUZXh0Rm9ybWF0VHJhbnNmb3JtZXJzKGN1cnJlbnROb2RlLCB0ZXh0Rm9ybWF0VHJhbnNmb3JtZXJzSW5kZXgsIHRleHRNYXRjaFRyYW5zZm9ybWVycyk7XG4gIH1cblxuICAvLyBSdW4gb3ZlciBsZWFkaW5nL3JlbWFpbmluZyB0ZXh0IGlmIGFueVxuICBpZiAobGVhZGluZ05vZGUpIHtcbiAgICBpbXBvcnRUZXh0Rm9ybWF0VHJhbnNmb3JtZXJzKGxlYWRpbmdOb2RlLCB0ZXh0Rm9ybWF0VHJhbnNmb3JtZXJzSW5kZXgsIHRleHRNYXRjaFRyYW5zZm9ybWVycyk7XG4gIH1cbiAgaWYgKHJlbWFpbmRlck5vZGUpIHtcbiAgICBpbXBvcnRUZXh0Rm9ybWF0VHJhbnNmb3JtZXJzKHJlbWFpbmRlck5vZGUsIHRleHRGb3JtYXRUcmFuc2Zvcm1lcnNJbmRleCwgdGV4dE1hdGNoVHJhbnNmb3JtZXJzKTtcbiAgfVxufVxuZnVuY3Rpb24gaW1wb3J0VGV4dE1hdGNoVHJhbnNmb3JtZXJzKHRleHROb2RlXywgdGV4dE1hdGNoVHJhbnNmb3JtZXJzKSB7XG4gIGxldCB0ZXh0Tm9kZSA9IHRleHROb2RlXztcbiAgbWFpbkxvb3A6IHdoaWxlICh0ZXh0Tm9kZSkge1xuICAgIGZvciAoY29uc3QgdHJhbnNmb3JtZXIgb2YgdGV4dE1hdGNoVHJhbnNmb3JtZXJzKSB7XG4gICAgICBpZiAoIXRyYW5zZm9ybWVyLnJlcGxhY2UgfHwgIXRyYW5zZm9ybWVyLmltcG9ydFJlZ0V4cCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1hdGNoID0gdGV4dE5vZGUuZ2V0VGV4dENvbnRlbnQoKS5tYXRjaCh0cmFuc2Zvcm1lci5pbXBvcnRSZWdFeHApO1xuICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBtYXRjaC5pbmRleCB8fCAwO1xuICAgICAgY29uc3QgZW5kSW5kZXggPSB0cmFuc2Zvcm1lci5nZXRFbmRJbmRleCA/IHRyYW5zZm9ybWVyLmdldEVuZEluZGV4KHRleHROb2RlLCBtYXRjaCkgOiBzdGFydEluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgaWYgKGVuZEluZGV4ID09PSBmYWxzZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldCByZXBsYWNlTm9kZSwgbmV3VGV4dE5vZGU7XG4gICAgICBpZiAoc3RhcnRJbmRleCA9PT0gMCkge1xuICAgICAgICBbcmVwbGFjZU5vZGUsIHRleHROb2RlXSA9IHRleHROb2RlLnNwbGl0VGV4dChlbmRJbmRleCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBbLCByZXBsYWNlTm9kZSwgbmV3VGV4dE5vZGVdID0gdGV4dE5vZGUuc3BsaXRUZXh0KHN0YXJ0SW5kZXgsIGVuZEluZGV4KTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdUZXh0Tm9kZSkge1xuICAgICAgICBpbXBvcnRUZXh0TWF0Y2hUcmFuc2Zvcm1lcnMobmV3VGV4dE5vZGUsIHRleHRNYXRjaFRyYW5zZm9ybWVycyk7XG4gICAgICB9XG4gICAgICB0cmFuc2Zvcm1lci5yZXBsYWNlKHJlcGxhY2VOb2RlLCBtYXRjaCk7XG4gICAgICBjb250aW51ZSBtYWluTG9vcDtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cbn1cblxuLy8gRmluZHMgZmlyc3QgXCI8dGFnPmNvbnRlbnQ8dGFnPlwiIG1hdGNoIHRoYXQgaXMgbm90IG5lc3RlZCBpbnRvIGFub3RoZXIgdGFnXG5mdW5jdGlvbiBmaW5kT3V0ZXJtb3N0TWF0Y2godGV4dENvbnRlbnQsIHRleHRUcmFuc2Zvcm1lcnNJbmRleCkge1xuICBjb25zdCBvcGVuVGFnc01hdGNoID0gdGV4dENvbnRlbnQubWF0Y2godGV4dFRyYW5zZm9ybWVyc0luZGV4Lm9wZW5UYWdzUmVnRXhwKTtcbiAgaWYgKG9wZW5UYWdzTWF0Y2ggPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZvciAoY29uc3QgbWF0Y2ggb2Ygb3BlblRhZ3NNYXRjaCkge1xuICAgIC8vIE9wZW4gdGFncyByZWcgZXhwIG1pZ2h0IGNhcHR1cmUgbGVhZGluZyBzcGFjZSBzbyByZW1vdmluZyBpdFxuICAgIC8vIGJlZm9yZSB1c2luZyBtYXRjaCB0byBmaW5kIHRyYW5zZm9ybWVyXG4gICAgY29uc3QgdGFnID0gbWF0Y2gucmVwbGFjZSgvXlxccy8sICcnKTtcbiAgICBjb25zdCBmdWxsTWF0Y2hSZWdFeHAgPSB0ZXh0VHJhbnNmb3JtZXJzSW5kZXguZnVsbE1hdGNoUmVnRXhwQnlUYWdbdGFnXTtcbiAgICBpZiAoZnVsbE1hdGNoUmVnRXhwID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBmdWxsTWF0Y2ggPSB0ZXh0Q29udGVudC5tYXRjaChmdWxsTWF0Y2hSZWdFeHApO1xuICAgIGNvbnN0IHRyYW5zZm9ybWVyID0gdGV4dFRyYW5zZm9ybWVyc0luZGV4LnRyYW5zZm9ybWVyc0J5VGFnW3RhZ107XG4gICAgaWYgKGZ1bGxNYXRjaCAhPSBudWxsICYmIHRyYW5zZm9ybWVyICE9IG51bGwpIHtcbiAgICAgIGlmICh0cmFuc2Zvcm1lci5pbnRyYXdvcmQgIT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmdWxsTWF0Y2g7XG4gICAgICB9XG5cbiAgICAgIC8vIEZvciBub24taW50cmF3b3JkIHRyYW5zZm9ybWVycyBjaGVja2luZyBpZiBpdCdzIHdpdGhpbiBhIHdvcmRcbiAgICAgIC8vIG9yIHN1cnJvdW5kZWQgd2l0aCBzcGFjZS9wdW5jdHVhdGlvbi9uZXdsaW5lXG4gICAgICBjb25zdCB7XG4gICAgICAgIGluZGV4ID0gMFxuICAgICAgfSA9IGZ1bGxNYXRjaDtcbiAgICAgIGNvbnN0IGJlZm9yZUNoYXIgPSB0ZXh0Q29udGVudFtpbmRleCAtIDFdO1xuICAgICAgY29uc3QgYWZ0ZXJDaGFyID0gdGV4dENvbnRlbnRbaW5kZXggKyBmdWxsTWF0Y2hbMF0ubGVuZ3RoXTtcbiAgICAgIGlmICgoIWJlZm9yZUNoYXIgfHwgUFVOQ1RVQVRJT05fT1JfU1BBQ0UudGVzdChiZWZvcmVDaGFyKSkgJiYgKCFhZnRlckNoYXIgfHwgUFVOQ1RVQVRJT05fT1JfU1BBQ0UudGVzdChhZnRlckNoYXIpKSkge1xuICAgICAgICByZXR1cm4gZnVsbE1hdGNoO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRleHRGb3JtYXRUcmFuc2Zvcm1lcnNJbmRleCh0ZXh0VHJhbnNmb3JtZXJzKSB7XG4gIGNvbnN0IHRyYW5zZm9ybWVyc0J5VGFnID0ge307XG4gIGNvbnN0IGZ1bGxNYXRjaFJlZ0V4cEJ5VGFnID0ge307XG4gIGNvbnN0IG9wZW5UYWdzUmVnRXhwID0gW107XG4gIGNvbnN0IGVzY2FwZVJlZ0V4cCA9IGAoPzwhW1xcXFxcXFxcXSlgO1xuICBmb3IgKGNvbnN0IHRyYW5zZm9ybWVyIG9mIHRleHRUcmFuc2Zvcm1lcnMpIHtcbiAgICBjb25zdCB7XG4gICAgICB0YWdcbiAgICB9ID0gdHJhbnNmb3JtZXI7XG4gICAgdHJhbnNmb3JtZXJzQnlUYWdbdGFnXSA9IHRyYW5zZm9ybWVyO1xuICAgIGNvbnN0IHRhZ1JlZ0V4cCA9IHRhZy5yZXBsYWNlKC8oXFwqfFxcXnxcXCspL2csICdcXFxcJDEnKTtcbiAgICBvcGVuVGFnc1JlZ0V4cC5wdXNoKHRhZ1JlZ0V4cCk7XG4gICAgaWYgKElTX1NBRkFSSSB8fCBJU19JT1MgfHwgSVNfQVBQTEVfV0VCS0lUKSB7XG4gICAgICBmdWxsTWF0Y2hSZWdFeHBCeVRhZ1t0YWddID0gbmV3IFJlZ0V4cChgKCR7dGFnUmVnRXhwfSkoPyFbJHt0YWdSZWdFeHB9XFxcXHNdKSguKj9bXiR7dGFnUmVnRXhwfVxcXFxzXSkke3RhZ1JlZ0V4cH0oPyEke3RhZ1JlZ0V4cH0pYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZ1bGxNYXRjaFJlZ0V4cEJ5VGFnW3RhZ10gPSBuZXcgUmVnRXhwKGAoPzwhW1xcXFxcXFxcJHt0YWdSZWdFeHB9XSkoJHt0YWdSZWdFeHB9KSgoXFxcXFxcXFwke3RhZ1JlZ0V4cH0pPy4qP1teJHt0YWdSZWdFeHB9XFxcXHNdKFxcXFxcXFxcJHt0YWdSZWdFeHB9KT8pKCg/PCFcXFxcXFxcXCl8KD88PVxcXFxcXFxcXFxcXFxcXFwpKSgke3RhZ1JlZ0V4cH0pKD8hW1xcXFxcXFxcJHt0YWdSZWdFeHB9XSlgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAvLyBSZWcgZXhwIHRvIGZpbmQgb3BlbiB0YWcgKyBjb250ZW50ICsgY2xvc2UgdGFnXG4gICAgZnVsbE1hdGNoUmVnRXhwQnlUYWcsXG4gICAgLy8gUmVnIGV4cCB0byBmaW5kIG9wZW5pbmcgdGFnc1xuICAgIG9wZW5UYWdzUmVnRXhwOiBuZXcgUmVnRXhwKChJU19TQUZBUkkgfHwgSVNfSU9TIHx8IElTX0FQUExFX1dFQktJVCA/ICcnIDogYCR7ZXNjYXBlUmVnRXhwfWApICsgJygnICsgb3BlblRhZ3NSZWdFeHAuam9pbignfCcpICsgJyknLCAnZycpLFxuICAgIHRyYW5zZm9ybWVyc0J5VGFnXG4gIH07XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gcnVuRWxlbWVudFRyYW5zZm9ybWVycyhwYXJlbnROb2RlLCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGVsZW1lbnRUcmFuc2Zvcm1lcnMpIHtcbiAgY29uc3QgZ3JhbmRQYXJlbnROb2RlID0gcGFyZW50Tm9kZS5nZXRQYXJlbnQoKTtcbiAgaWYgKCEkaXNSb290T3JTaGFkb3dSb290KGdyYW5kUGFyZW50Tm9kZSkgfHwgcGFyZW50Tm9kZS5nZXRGaXJzdENoaWxkKCkgIT09IGFuY2hvck5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgdGV4dENvbnRlbnQgPSBhbmNob3JOb2RlLmdldFRleHRDb250ZW50KCk7XG5cbiAgLy8gQ2hlY2tpbmcgZm9yIGFuY2hvck9mZnNldCBwb3NpdGlvbiB0byBwcmV2ZW50IGFueSBjaGVja3MgZm9yIGNhc2VzIHdoZW4gY2FyZXQgaXMgdG9vIGZhclxuICAvLyBmcm9tIGEgbGluZSBzdGFydCB0byBiZSBhIHBhcnQgb2YgYmxvY2stbGV2ZWwgbWFya2Rvd24gdHJpZ2dlci5cbiAgLy9cbiAgLy8gVE9ETzpcbiAgLy8gQ2FuIGhhdmUgYSBxdWljayBjaGVjayBpZiBjYXJldCBpcyBjbG9zZSBlbm91Z2ggdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgc3RyaW5nIChlLmcuIG9mZnNldCBsZXNzIHRoYW4gMTAtMjApXG4gIC8vIHNpbmNlIG90aGVyd2lzZSBpdCB3b24ndCBiZSBhIG1hcmtkb3duIHNob3J0Y3V0LCBidXQgdGFibGVzIGFyZSBleGNlcHRpb25cbiAgaWYgKHRleHRDb250ZW50W2FuY2hvck9mZnNldCAtIDFdICE9PSAnICcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCB7XG4gICAgcmVnRXhwLFxuICAgIHJlcGxhY2VcbiAgfSBvZiBlbGVtZW50VHJhbnNmb3JtZXJzKSB7XG4gICAgY29uc3QgbWF0Y2ggPSB0ZXh0Q29udGVudC5tYXRjaChyZWdFeHApO1xuICAgIGlmIChtYXRjaCAmJiBtYXRjaFswXS5sZW5ndGggPT09IChtYXRjaFswXS5lbmRzV2l0aCgnICcpID8gYW5jaG9yT2Zmc2V0IDogYW5jaG9yT2Zmc2V0IC0gMSkpIHtcbiAgICAgIGNvbnN0IG5leHRTaWJsaW5ncyA9IGFuY2hvck5vZGUuZ2V0TmV4dFNpYmxpbmdzKCk7XG4gICAgICBjb25zdCBbbGVhZGluZ05vZGUsIHJlbWFpbmRlck5vZGVdID0gYW5jaG9yTm9kZS5zcGxpdFRleHQoYW5jaG9yT2Zmc2V0KTtcbiAgICAgIGxlYWRpbmdOb2RlLnJlbW92ZSgpO1xuICAgICAgY29uc3Qgc2libGluZ3MgPSByZW1haW5kZXJOb2RlID8gW3JlbWFpbmRlck5vZGUsIC4uLm5leHRTaWJsaW5nc10gOiBuZXh0U2libGluZ3M7XG4gICAgICBpZiAocmVwbGFjZShwYXJlbnROb2RlLCBzaWJsaW5ncywgbWF0Y2gsIGZhbHNlKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHJ1bk11bHRpbGluZUVsZW1lbnRUcmFuc2Zvcm1lcnMocGFyZW50Tm9kZSwgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBlbGVtZW50VHJhbnNmb3JtZXJzKSB7XG4gIGNvbnN0IGdyYW5kUGFyZW50Tm9kZSA9IHBhcmVudE5vZGUuZ2V0UGFyZW50KCk7XG4gIGlmICghJGlzUm9vdE9yU2hhZG93Um9vdChncmFuZFBhcmVudE5vZGUpIHx8IHBhcmVudE5vZGUuZ2V0Rmlyc3RDaGlsZCgpICE9PSBhbmNob3JOb2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHRleHRDb250ZW50ID0gYW5jaG9yTm9kZS5nZXRUZXh0Q29udGVudCgpO1xuXG4gIC8vIENoZWNraW5nIGZvciBhbmNob3JPZmZzZXQgcG9zaXRpb24gdG8gcHJldmVudCBhbnkgY2hlY2tzIGZvciBjYXNlcyB3aGVuIGNhcmV0IGlzIHRvbyBmYXJcbiAgLy8gZnJvbSBhIGxpbmUgc3RhcnQgdG8gYmUgYSBwYXJ0IG9mIGJsb2NrLWxldmVsIG1hcmtkb3duIHRyaWdnZXIuXG4gIC8vXG4gIC8vIFRPRE86XG4gIC8vIENhbiBoYXZlIGEgcXVpY2sgY2hlY2sgaWYgY2FyZXQgaXMgY2xvc2UgZW5vdWdoIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHN0cmluZyAoZS5nLiBvZmZzZXQgbGVzcyB0aGFuIDEwLTIwKVxuICAvLyBzaW5jZSBvdGhlcndpc2UgaXQgd29uJ3QgYmUgYSBtYXJrZG93biBzaG9ydGN1dCwgYnV0IHRhYmxlcyBhcmUgZXhjZXB0aW9uXG4gIGlmICh0ZXh0Q29udGVudFthbmNob3JPZmZzZXQgLSAxXSAhPT0gJyAnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoY29uc3Qge1xuICAgIHJlZ0V4cFN0YXJ0LFxuICAgIHJlcGxhY2UsXG4gICAgcmVnRXhwRW5kXG4gIH0gb2YgZWxlbWVudFRyYW5zZm9ybWVycykge1xuICAgIGlmIChyZWdFeHBFbmQgJiYgISgnb3B0aW9uYWwnIGluIHJlZ0V4cEVuZCkgfHwgcmVnRXhwRW5kICYmICdvcHRpb25hbCcgaW4gcmVnRXhwRW5kICYmICFyZWdFeHBFbmQub3B0aW9uYWwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaCA9IHRleHRDb250ZW50Lm1hdGNoKHJlZ0V4cFN0YXJ0KTtcbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2hbMF0ubGVuZ3RoID09PSAobWF0Y2hbMF0uZW5kc1dpdGgoJyAnKSA/IGFuY2hvck9mZnNldCA6IGFuY2hvck9mZnNldCAtIDEpKSB7XG4gICAgICBjb25zdCBuZXh0U2libGluZ3MgPSBhbmNob3JOb2RlLmdldE5leHRTaWJsaW5ncygpO1xuICAgICAgY29uc3QgW2xlYWRpbmdOb2RlLCByZW1haW5kZXJOb2RlXSA9IGFuY2hvck5vZGUuc3BsaXRUZXh0KGFuY2hvck9mZnNldCk7XG4gICAgICBsZWFkaW5nTm9kZS5yZW1vdmUoKTtcbiAgICAgIGNvbnN0IHNpYmxpbmdzID0gcmVtYWluZGVyTm9kZSA/IFtyZW1haW5kZXJOb2RlLCAuLi5uZXh0U2libGluZ3NdIDogbmV4dFNpYmxpbmdzO1xuICAgICAgaWYgKHJlcGxhY2UocGFyZW50Tm9kZSwgc2libGluZ3MsIG1hdGNoLCBudWxsLCBudWxsLCBmYWxzZSkgIT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBydW5UZXh0TWF0Y2hUcmFuc2Zvcm1lcnMoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCB0cmFuc2Zvcm1lcnNCeVRyaWdnZXIpIHtcbiAgbGV0IHRleHRDb250ZW50ID0gYW5jaG9yTm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICBjb25zdCBsYXN0Q2hhciA9IHRleHRDb250ZW50W2FuY2hvck9mZnNldCAtIDFdO1xuICBjb25zdCB0cmFuc2Zvcm1lcnMgPSB0cmFuc2Zvcm1lcnNCeVRyaWdnZXJbbGFzdENoYXJdO1xuICBpZiAodHJhbnNmb3JtZXJzID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBJZiB0eXBpbmcgaW4gdGhlIG1pZGRsZSBvZiBjb250ZW50LCByZW1vdmUgdGhlIHRhaWwgdG8gZG9cbiAgLy8gcmVnIGV4cCBtYXRjaCB1cCB0byBhIHN0cmluZyBlbmQgKGNhcmV0IHBvc2l0aW9uKVxuICBpZiAoYW5jaG9yT2Zmc2V0IDwgdGV4dENvbnRlbnQubGVuZ3RoKSB7XG4gICAgdGV4dENvbnRlbnQgPSB0ZXh0Q29udGVudC5zbGljZSgwLCBhbmNob3JPZmZzZXQpO1xuICB9XG4gIGZvciAoY29uc3QgdHJhbnNmb3JtZXIgb2YgdHJhbnNmb3JtZXJzKSB7XG4gICAgaWYgKCF0cmFuc2Zvcm1lci5yZXBsYWNlIHx8ICF0cmFuc2Zvcm1lci5yZWdFeHApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaCA9IHRleHRDb250ZW50Lm1hdGNoKHRyYW5zZm9ybWVyLnJlZ0V4cCk7XG4gICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRJbmRleCA9IG1hdGNoLmluZGV4IHx8IDA7XG4gICAgY29uc3QgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgIGxldCByZXBsYWNlTm9kZTtcbiAgICBpZiAoc3RhcnRJbmRleCA9PT0gMCkge1xuICAgICAgW3JlcGxhY2VOb2RlXSA9IGFuY2hvck5vZGUuc3BsaXRUZXh0KGVuZEluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgWywgcmVwbGFjZU5vZGVdID0gYW5jaG9yTm9kZS5zcGxpdFRleHQoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICAgIH1cbiAgICByZXBsYWNlTm9kZS5zZWxlY3ROZXh0KDAsIDApO1xuICAgIHRyYW5zZm9ybWVyLnJlcGxhY2UocmVwbGFjZU5vZGUsIG1hdGNoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiAkcnVuVGV4dEZvcm1hdFRyYW5zZm9ybWVycyhhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIHRleHRGb3JtYXRUcmFuc2Zvcm1lcnMpIHtcbiAgY29uc3QgdGV4dENvbnRlbnQgPSBhbmNob3JOb2RlLmdldFRleHRDb250ZW50KCk7XG4gIGNvbnN0IGNsb3NlVGFnRW5kSW5kZXggPSBhbmNob3JPZmZzZXQgLSAxO1xuICBjb25zdCBjbG9zZUNoYXIgPSB0ZXh0Q29udGVudFtjbG9zZVRhZ0VuZEluZGV4XTtcbiAgLy8gUXVpY2sgY2hlY2sgaWYgd2UncmUgcG9zc2libHkgYXQgdGhlIGVuZCBvZiBpbmxpbmUgbWFya2Rvd24gc3R5bGVcbiAgY29uc3QgbWF0Y2hlcnMgPSB0ZXh0Rm9ybWF0VHJhbnNmb3JtZXJzW2Nsb3NlQ2hhcl07XG4gIGlmICghbWF0Y2hlcnMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBtYXRjaGVyIG9mIG1hdGNoZXJzKSB7XG4gICAgY29uc3Qge1xuICAgICAgdGFnXG4gICAgfSA9IG1hdGNoZXI7XG4gICAgY29uc3QgdGFnTGVuZ3RoID0gdGFnLmxlbmd0aDtcbiAgICBjb25zdCBjbG9zZVRhZ1N0YXJ0SW5kZXggPSBjbG9zZVRhZ0VuZEluZGV4IC0gdGFnTGVuZ3RoICsgMTtcblxuICAgIC8vIElmIHRhZyBpcyBub3Qgc2luZ2xlIGNoYXIgY2hlY2sgaWYgcmVzdCBvZiBpdCBtYXRjaGVzIHdpdGggdGV4dCBjb250ZW50XG4gICAgaWYgKHRhZ0xlbmd0aCA+IDEpIHtcbiAgICAgIGlmICghaXNFcXVhbFN1YlN0cmluZyh0ZXh0Q29udGVudCwgY2xvc2VUYWdTdGFydEluZGV4LCB0YWcsIDAsIHRhZ0xlbmd0aCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3BhY2UgYmVmb3JlIGNsb3NpbmcgdGFnIGNhbmNlbHMgaW5saW5lIG1hcmtkb3duXG4gICAgaWYgKHRleHRDb250ZW50W2Nsb3NlVGFnU3RhcnRJbmRleCAtIDFdID09PSAnICcpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIFNvbWUgdGFncyBjYW4gbm90IGJlIHVzZWQgd2l0aGluIHdvcmRzLCBoZW5jZSBzaG91bGQgaGF2ZSBuZXdsaW5lL3NwYWNlL3B1bmN0dWF0aW9uIGFmdGVyIGl0XG4gICAgY29uc3QgYWZ0ZXJDbG9zZVRhZ0NoYXIgPSB0ZXh0Q29udGVudFtjbG9zZVRhZ0VuZEluZGV4ICsgMV07XG4gICAgaWYgKG1hdGNoZXIuaW50cmF3b3JkID09PSBmYWxzZSAmJiBhZnRlckNsb3NlVGFnQ2hhciAmJiAhUFVOQ1RVQVRJT05fT1JfU1BBQ0UudGVzdChhZnRlckNsb3NlVGFnQ2hhcikpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBjbG9zZU5vZGUgPSBhbmNob3JOb2RlO1xuICAgIGxldCBvcGVuTm9kZSA9IGNsb3NlTm9kZTtcbiAgICBsZXQgb3BlblRhZ1N0YXJ0SW5kZXggPSBnZXRPcGVuVGFnU3RhcnRJbmRleCh0ZXh0Q29udGVudCwgY2xvc2VUYWdTdGFydEluZGV4LCB0YWcpO1xuXG4gICAgLy8gR28gdGhyb3VnaCB0ZXh0IG5vZGUgc2libGluZ3MgYW5kIHNlYXJjaCBmb3Igb3BlbmluZyB0YWdcbiAgICAvLyBpZiBoYXZlbid0IGZvdW5kIGl0IHdpdGhpbiB0aGUgc2FtZSB0ZXh0IG5vZGUgYXMgY2xvc2luZyB0YWdcbiAgICBsZXQgc2libGluZyA9IG9wZW5Ob2RlO1xuICAgIHdoaWxlIChvcGVuVGFnU3RhcnRJbmRleCA8IDAgJiYgKHNpYmxpbmcgPSBzaWJsaW5nLmdldFByZXZpb3VzU2libGluZygpKSkge1xuICAgICAgaWYgKCRpc0xpbmVCcmVha05vZGUoc2libGluZykpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoJGlzVGV4dE5vZGUoc2libGluZykpIHtcbiAgICAgICAgY29uc3Qgc2libGluZ1RleHRDb250ZW50ID0gc2libGluZy5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgICBvcGVuTm9kZSA9IHNpYmxpbmc7XG4gICAgICAgIG9wZW5UYWdTdGFydEluZGV4ID0gZ2V0T3BlblRhZ1N0YXJ0SW5kZXgoc2libGluZ1RleHRDb250ZW50LCBzaWJsaW5nVGV4dENvbnRlbnQubGVuZ3RoLCB0YWcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9wZW5pbmcgdGFnIGlzIG5vdCBmb3VuZFxuICAgIGlmIChvcGVuVGFnU3RhcnRJbmRleCA8IDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIE5vIGNvbnRlbnQgYmV0d2VlbiBvcGVuaW5nIGFuZCBjbG9zaW5nIHRhZ1xuICAgIGlmIChvcGVuTm9kZSA9PT0gY2xvc2VOb2RlICYmIG9wZW5UYWdTdGFydEluZGV4ICsgdGFnTGVuZ3RoID09PSBjbG9zZVRhZ1N0YXJ0SW5kZXgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIENoZWNraW5nIGxvbmdlciB0YWdzIGZvciByZXBlYXRpbmcgY2hhcnMgKGUuZy4gKioqIHZzICoqKVxuICAgIGNvbnN0IHByZXZPcGVuTm9kZVRleHQgPSBvcGVuTm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgIGlmIChvcGVuVGFnU3RhcnRJbmRleCA+IDAgJiYgcHJldk9wZW5Ob2RlVGV4dFtvcGVuVGFnU3RhcnRJbmRleCAtIDFdID09PSBjbG9zZUNoYXIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIFNvbWUgdGFncyBjYW4gbm90IGJlIHVzZWQgd2l0aGluIHdvcmRzLCBoZW5jZSBzaG91bGQgaGF2ZSBuZXdsaW5lL3NwYWNlL3B1bmN0dWF0aW9uIGJlZm9yZSBpdFxuICAgIGNvbnN0IGJlZm9yZU9wZW5UYWdDaGFyID0gcHJldk9wZW5Ob2RlVGV4dFtvcGVuVGFnU3RhcnRJbmRleCAtIDFdO1xuICAgIGlmIChtYXRjaGVyLmludHJhd29yZCA9PT0gZmFsc2UgJiYgYmVmb3JlT3BlblRhZ0NoYXIgJiYgIVBVTkNUVUFUSU9OX09SX1NQQUNFLnRlc3QoYmVmb3JlT3BlblRhZ0NoYXIpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBDbGVhbiB0ZXh0IGZyb20gb3BlbmluZyBhbmQgY2xvc2luZyB0YWdzIChzdGFydGluZyBmcm9tIGNsb3NpbmcgdGFnXG4gICAgLy8gdG8gcHJldmVudCBhbnkgb2Zmc2V0IHNoaWZ0cyBpZiB3ZSBzdGFydCBmcm9tIG9wZW5pbmcgb25lKVxuICAgIGNvbnN0IHByZXZDbG9zZU5vZGVUZXh0ID0gY2xvc2VOb2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgY29uc3QgY2xvc2VOb2RlVGV4dCA9IHByZXZDbG9zZU5vZGVUZXh0LnNsaWNlKDAsIGNsb3NlVGFnU3RhcnRJbmRleCkgKyBwcmV2Q2xvc2VOb2RlVGV4dC5zbGljZShjbG9zZVRhZ0VuZEluZGV4ICsgMSk7XG4gICAgY2xvc2VOb2RlLnNldFRleHRDb250ZW50KGNsb3NlTm9kZVRleHQpO1xuICAgIGNvbnN0IG9wZW5Ob2RlVGV4dCA9IG9wZW5Ob2RlID09PSBjbG9zZU5vZGUgPyBjbG9zZU5vZGVUZXh0IDogcHJldk9wZW5Ob2RlVGV4dDtcbiAgICBvcGVuTm9kZS5zZXRUZXh0Q29udGVudChvcGVuTm9kZVRleHQuc2xpY2UoMCwgb3BlblRhZ1N0YXJ0SW5kZXgpICsgb3Blbk5vZGVUZXh0LnNsaWNlKG9wZW5UYWdTdGFydEluZGV4ICsgdGFnTGVuZ3RoKSk7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGNvbnN0IG5leHRTZWxlY3Rpb24gPSAkY3JlYXRlUmFuZ2VTZWxlY3Rpb24oKTtcbiAgICAkc2V0U2VsZWN0aW9uKG5leHRTZWxlY3Rpb24pO1xuICAgIC8vIEFkanVzdCBvZmZzZXQgYmFzZWQgb24gZGVsZXRlZCBjaGFyc1xuICAgIGNvbnN0IG5ld09mZnNldCA9IGNsb3NlVGFnRW5kSW5kZXggLSB0YWdMZW5ndGggKiAob3Blbk5vZGUgPT09IGNsb3NlTm9kZSA/IDIgOiAxKSArIDE7XG4gICAgbmV4dFNlbGVjdGlvbi5hbmNob3Iuc2V0KG9wZW5Ob2RlLl9fa2V5LCBvcGVuVGFnU3RhcnRJbmRleCwgJ3RleHQnKTtcbiAgICBuZXh0U2VsZWN0aW9uLmZvY3VzLnNldChjbG9zZU5vZGUuX19rZXksIG5ld09mZnNldCwgJ3RleHQnKTtcblxuICAgIC8vIEFwcGx5IGZvcm1hdHRpbmcgdG8gc2VsZWN0ZWQgdGV4dFxuICAgIGZvciAoY29uc3QgZm9ybWF0IG9mIG1hdGNoZXIuZm9ybWF0KSB7XG4gICAgICBpZiAoIW5leHRTZWxlY3Rpb24uaGFzRm9ybWF0KGZvcm1hdCkpIHtcbiAgICAgICAgbmV4dFNlbGVjdGlvbi5mb3JtYXRUZXh0KGZvcm1hdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29sbGFwc2Ugc2VsZWN0aW9uIHVwIHRvIHRoZSBmb2N1cyBwb2ludFxuICAgIG5leHRTZWxlY3Rpb24uYW5jaG9yLnNldChuZXh0U2VsZWN0aW9uLmZvY3VzLmtleSwgbmV4dFNlbGVjdGlvbi5mb2N1cy5vZmZzZXQsIG5leHRTZWxlY3Rpb24uZm9jdXMudHlwZSk7XG5cbiAgICAvLyBSZW1vdmUgZm9ybWF0dGluZyBmcm9tIGNvbGxhcHNlZCBzZWxlY3Rpb25cbiAgICBmb3IgKGNvbnN0IGZvcm1hdCBvZiBtYXRjaGVyLmZvcm1hdCkge1xuICAgICAgaWYgKG5leHRTZWxlY3Rpb24uaGFzRm9ybWF0KGZvcm1hdCkpIHtcbiAgICAgICAgbmV4dFNlbGVjdGlvbi50b2dnbGVGb3JtYXQoZm9ybWF0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIG5leHRTZWxlY3Rpb24uZm9ybWF0ID0gc2VsZWN0aW9uLmZvcm1hdDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0T3BlblRhZ1N0YXJ0SW5kZXgoc3RyaW5nLCBtYXhJbmRleCwgdGFnKSB7XG4gIGNvbnN0IHRhZ0xlbmd0aCA9IHRhZy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSBtYXhJbmRleDsgaSA+PSB0YWdMZW5ndGg7IGktLSkge1xuICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBpIC0gdGFnTGVuZ3RoO1xuICAgIGlmIChpc0VxdWFsU3ViU3RyaW5nKHN0cmluZywgc3RhcnRJbmRleCwgdGFnLCAwLCB0YWdMZW5ndGgpICYmXG4gICAgLy8gU3BhY2UgYWZ0ZXIgb3BlbmluZyB0YWcgY2FuY2VscyB0cmFuc2Zvcm1hdGlvblxuICAgIHN0cmluZ1tzdGFydEluZGV4ICsgdGFnTGVuZ3RoXSAhPT0gJyAnKSB7XG4gICAgICByZXR1cm4gc3RhcnRJbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gaXNFcXVhbFN1YlN0cmluZyhzdHJpbmdBLCBhU3RhcnQsIHN0cmluZ0IsIGJTdGFydCwgbGVuZ3RoKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3RyaW5nQVthU3RhcnQgKyBpXSAhPT0gc3RyaW5nQltiU3RhcnQgKyBpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyTWFya2Rvd25TaG9ydGN1dHMoZWRpdG9yLCB0cmFuc2Zvcm1lcnMgPSBUUkFOU0ZPUk1FUlMpIHtcbiAgY29uc3QgYnlUeXBlID0gdHJhbnNmb3JtZXJzQnlUeXBlKHRyYW5zZm9ybWVycyk7XG4gIGNvbnN0IHRleHRGb3JtYXRUcmFuc2Zvcm1lcnNCeVRyaWdnZXIgPSBpbmRleEJ5KGJ5VHlwZS50ZXh0Rm9ybWF0LCAoe1xuICAgIHRhZ1xuICB9KSA9PiB0YWdbdGFnLmxlbmd0aCAtIDFdKTtcbiAgY29uc3QgdGV4dE1hdGNoVHJhbnNmb3JtZXJzQnlUcmlnZ2VyID0gaW5kZXhCeShieVR5cGUudGV4dE1hdGNoLCAoe1xuICAgIHRyaWdnZXJcbiAgfSkgPT4gdHJpZ2dlcik7XG4gIGZvciAoY29uc3QgdHJhbnNmb3JtZXIgb2YgdHJhbnNmb3JtZXJzKSB7XG4gICAgY29uc3QgdHlwZSA9IHRyYW5zZm9ybWVyLnR5cGU7XG4gICAgaWYgKHR5cGUgPT09ICdlbGVtZW50JyB8fCB0eXBlID09PSAndGV4dC1tYXRjaCcgfHwgdHlwZSA9PT0gJ211bHRpbGluZS1lbGVtZW50Jykge1xuICAgICAgY29uc3QgZGVwZW5kZW5jaWVzID0gdHJhbnNmb3JtZXIuZGVwZW5kZW5jaWVzO1xuICAgICAgZm9yIChjb25zdCBub2RlIG9mIGRlcGVuZGVuY2llcykge1xuICAgICAgICBpZiAoIWVkaXRvci5oYXNOb2RlKG5vZGUpKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYE1hcmtkb3duU2hvcnRjdXRzOiBtaXNzaW5nIGRlcGVuZGVuY3kgJHtub2RlLmdldFR5cGUoKX0gZm9yIHRyYW5zZm9ybWVyLiBFbnN1cmUgbm9kZSBkZXBlbmRlbmN5IGlzIGluY2x1ZGVkIGluIGVkaXRvciBpbml0aWFsIGNvbmZpZy5gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgJHRyYW5zZm9ybSA9IChwYXJlbnROb2RlLCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQpID0+IHtcbiAgICBpZiAocnVuRWxlbWVudFRyYW5zZm9ybWVycyhwYXJlbnROb2RlLCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGJ5VHlwZS5lbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocnVuTXVsdGlsaW5lRWxlbWVudFRyYW5zZm9ybWVycyhwYXJlbnROb2RlLCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGJ5VHlwZS5tdWx0aWxpbmVFbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocnVuVGV4dE1hdGNoVHJhbnNmb3JtZXJzKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgdGV4dE1hdGNoVHJhbnNmb3JtZXJzQnlUcmlnZ2VyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAkcnVuVGV4dEZvcm1hdFRyYW5zZm9ybWVycyhhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIHRleHRGb3JtYXRUcmFuc2Zvcm1lcnNCeVRyaWdnZXIpO1xuICB9O1xuICByZXR1cm4gZWRpdG9yLnJlZ2lzdGVyVXBkYXRlTGlzdGVuZXIoKHtcbiAgICB0YWdzLFxuICAgIGRpcnR5TGVhdmVzLFxuICAgIGVkaXRvclN0YXRlLFxuICAgIHByZXZFZGl0b3JTdGF0ZVxuICB9KSA9PiB7XG4gICAgLy8gSWdub3JlIHVwZGF0ZXMgZnJvbSBjb2xsYWJvcmF0aW9uIGFuZCB1bmRvL3JlZG8gKGFzIGNoYW5nZXMgYWxyZWFkeSBjYWxjdWxhdGVkKVxuICAgIGlmICh0YWdzLmhhcygnY29sbGFib3JhdGlvbicpIHx8IHRhZ3MuaGFzKCdoaXN0b3JpYycpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgZWRpdG9yIGlzIHN0aWxsIGNvbXBvc2luZyAoaS5lLiBiYWNrdGlja3MpIHdlIG11c3Qgd2FpdCBiZWZvcmUgdGhlIHVzZXIgY29uZmlybXMgdGhlIGtleVxuICAgIGlmIChlZGl0b3IuaXNDb21wb3NpbmcoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3JTdGF0ZS5yZWFkKCRnZXRTZWxlY3Rpb24pO1xuICAgIGNvbnN0IHByZXZTZWxlY3Rpb24gPSBwcmV2RWRpdG9yU3RhdGUucmVhZCgkZ2V0U2VsZWN0aW9uKTtcblxuICAgIC8vIFdlIGV4cGVjdCBzZWxlY3Rpb24gdG8gYmUgYSBjb2xsYXBzZWQgcmFuZ2UgYW5kIG5vdCBtYXRjaCBwcmV2aW91cyBvbmUgKGFzIHdlIHdhbnRcbiAgICAvLyB0byB0cmlnZ2VyIHRyYW5zZm9ybXMgb25seSBhcyB1c2VyIHR5cGVzKVxuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24ocHJldlNlbGVjdGlvbikgfHwgISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpIHx8IHNlbGVjdGlvbi5pcyhwcmV2U2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhbmNob3JLZXkgPSBzZWxlY3Rpb24uYW5jaG9yLmtleTtcbiAgICBjb25zdCBhbmNob3JPZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yLm9mZnNldDtcbiAgICBjb25zdCBhbmNob3JOb2RlID0gZWRpdG9yU3RhdGUuX25vZGVNYXAuZ2V0KGFuY2hvcktleSk7XG4gICAgaWYgKCEkaXNUZXh0Tm9kZShhbmNob3JOb2RlKSB8fCAhZGlydHlMZWF2ZXMuaGFzKGFuY2hvcktleSkgfHwgYW5jaG9yT2Zmc2V0ICE9PSAxICYmIGFuY2hvck9mZnNldCA+IHByZXZTZWxlY3Rpb24uYW5jaG9yLm9mZnNldCArIDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAvLyBNYXJrZG93biBpcyBub3QgYXZhaWxhYmxlIGluc2lkZSBjb2RlXG4gICAgICBpZiAoYW5jaG9yTm9kZS5oYXNGb3JtYXQoJ2NvZGUnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJlbnROb2RlID0gYW5jaG9yTm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgIGlmIChwYXJlbnROb2RlID09PSBudWxsIHx8ICRpc0NvZGVOb2RlKHBhcmVudE5vZGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgICR0cmFuc2Zvcm0ocGFyZW50Tm9kZSwgYW5jaG9yTm9kZSwgc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBPUkRFUkVEX0xJU1RfUkVHRVggPSAvXihcXHMqKShcXGR7MSx9KVxcLlxccy87XG5jb25zdCBVTk9SREVSRURfTElTVF9SRUdFWCA9IC9eKFxccyopWy0qK11cXHMvO1xuY29uc3QgQ0hFQ0tfTElTVF9SRUdFWCA9IC9eKFxccyopKD86LVxccyk/XFxzPyhcXFsoXFxzfHgpP1xcXSlcXHMvaTtcbmNvbnN0IEhFQURJTkdfUkVHRVggPSAvXigjezEsNn0pXFxzLztcbmNvbnN0IFFVT1RFX1JFR0VYID0gL14+XFxzLztcbmNvbnN0IENPREVfU1RBUlRfUkVHRVggPSAvXlsgXFx0XSpgYGAoXFx3Kyk/LztcbmNvbnN0IENPREVfRU5EX1JFR0VYID0gL1sgXFx0XSpgYGAkLztcbmNvbnN0IENPREVfU0lOR0xFX0xJTkVfUkVHRVggPSAvXlsgXFx0XSpgYGBbXmBdKyg/Oig/OmB7MSwyfXxgezQsfSlbXmBdKykqYGBgKD86W15gXXwkKS87XG5jb25zdCBUQUJMRV9ST1dfUkVHX0VYUCA9IC9eKD86XFx8KSguKykoPzpcXHwpXFxzPyQvO1xuY29uc3QgVEFCTEVfUk9XX0RJVklERVJfUkVHX0VYUCA9IC9eKFxcfCA/Oj8tKjo/ID8pK1xcfFxccz8kLztcbmNvbnN0IGNyZWF0ZUJsb2NrTm9kZSA9IGNyZWF0ZU5vZGUgPT4ge1xuICByZXR1cm4gKHBhcmVudE5vZGUsIGNoaWxkcmVuLCBtYXRjaCkgPT4ge1xuICAgIGNvbnN0IG5vZGUgPSBjcmVhdGVOb2RlKG1hdGNoKTtcbiAgICBub2RlLmFwcGVuZCguLi5jaGlsZHJlbik7XG4gICAgcGFyZW50Tm9kZS5yZXBsYWNlKG5vZGUpO1xuICAgIG5vZGUuc2VsZWN0KDAsIDApO1xuICB9O1xufTtcblxuLy8gQW1vdW50IG9mIHNwYWNlcyB0aGF0IGRlZmluZSBpbmRlbnRhdGlvbiBsZXZlbFxuLy8gVE9ETzogc2hvdWxkIGJlIGFuIG9wdGlvblxuY29uc3QgTElTVF9JTkRFTlRfU0laRSA9IDQ7XG5mdW5jdGlvbiBnZXRJbmRlbnQod2hpdGVzcGFjZXMpIHtcbiAgY29uc3QgdGFicyA9IHdoaXRlc3BhY2VzLm1hdGNoKC9cXHQvZyk7XG4gIGNvbnN0IHNwYWNlcyA9IHdoaXRlc3BhY2VzLm1hdGNoKC8gL2cpO1xuICBsZXQgaW5kZW50ID0gMDtcbiAgaWYgKHRhYnMpIHtcbiAgICBpbmRlbnQgKz0gdGFicy5sZW5ndGg7XG4gIH1cbiAgaWYgKHNwYWNlcykge1xuICAgIGluZGVudCArPSBNYXRoLmZsb29yKHNwYWNlcy5sZW5ndGggLyBMSVNUX0lOREVOVF9TSVpFKTtcbiAgfVxuICByZXR1cm4gaW5kZW50O1xufVxuY29uc3QgbGlzdFJlcGxhY2UgPSBsaXN0VHlwZSA9PiB7XG4gIHJldHVybiAocGFyZW50Tm9kZSwgY2hpbGRyZW4sIG1hdGNoKSA9PiB7XG4gICAgY29uc3QgcHJldmlvdXNOb2RlID0gcGFyZW50Tm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBjb25zdCBuZXh0Tm9kZSA9IHBhcmVudE5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICBjb25zdCBsaXN0SXRlbSA9ICRjcmVhdGVMaXN0SXRlbU5vZGUobGlzdFR5cGUgPT09ICdjaGVjaycgPyBtYXRjaFszXSA9PT0gJ3gnIDogdW5kZWZpbmVkKTtcbiAgICBpZiAoJGlzTGlzdE5vZGUobmV4dE5vZGUpICYmIG5leHROb2RlLmdldExpc3RUeXBlKCkgPT09IGxpc3RUeXBlKSB7XG4gICAgICBjb25zdCBmaXJzdENoaWxkID0gbmV4dE5vZGUuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgICAgaWYgKGZpcnN0Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgZmlyc3RDaGlsZC5pbnNlcnRCZWZvcmUobGlzdEl0ZW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc2hvdWxkIG5ldmVyIGhhcHBlbiwgYnV0IGxldCdzIGhhbmRsZSBncmFjZWZ1bGx5LCBqdXN0IGluIGNhc2UuXG4gICAgICAgIG5leHROb2RlLmFwcGVuZChsaXN0SXRlbSk7XG4gICAgICB9XG4gICAgICBwYXJlbnROb2RlLnJlbW92ZSgpO1xuICAgIH0gZWxzZSBpZiAoJGlzTGlzdE5vZGUocHJldmlvdXNOb2RlKSAmJiBwcmV2aW91c05vZGUuZ2V0TGlzdFR5cGUoKSA9PT0gbGlzdFR5cGUpIHtcbiAgICAgIHByZXZpb3VzTm9kZS5hcHBlbmQobGlzdEl0ZW0pO1xuICAgICAgcGFyZW50Tm9kZS5yZW1vdmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGlzdCA9ICRjcmVhdGVMaXN0Tm9kZShsaXN0VHlwZSwgbGlzdFR5cGUgPT09ICdudW1iZXInID8gTnVtYmVyKG1hdGNoWzJdKSA6IHVuZGVmaW5lZCk7XG4gICAgICBsaXN0LmFwcGVuZChsaXN0SXRlbSk7XG4gICAgICBwYXJlbnROb2RlLnJlcGxhY2UobGlzdCk7XG4gICAgfVxuICAgIGxpc3RJdGVtLmFwcGVuZCguLi5jaGlsZHJlbik7XG4gICAgbGlzdEl0ZW0uc2VsZWN0KDAsIDApO1xuICAgIGNvbnN0IGluZGVudCA9IGdldEluZGVudChtYXRjaFsxXSk7XG4gICAgaWYgKGluZGVudCkge1xuICAgICAgbGlzdEl0ZW0uc2V0SW5kZW50KGluZGVudCk7XG4gICAgfVxuICB9O1xufTtcbmNvbnN0IGxpc3RFeHBvcnQgPSAobGlzdE5vZGUsIGV4cG9ydENoaWxkcmVuLCBkZXB0aCkgPT4ge1xuICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgY29uc3QgY2hpbGRyZW4gPSBsaXN0Tm9kZS5nZXRDaGlsZHJlbigpO1xuICBsZXQgaW5kZXggPSAwO1xuICBmb3IgKGNvbnN0IGxpc3RJdGVtTm9kZSBvZiBjaGlsZHJlbikge1xuICAgIGlmICgkaXNMaXN0SXRlbU5vZGUobGlzdEl0ZW1Ob2RlKSkge1xuICAgICAgaWYgKGxpc3RJdGVtTm9kZS5nZXRDaGlsZHJlblNpemUoKSA9PT0gMSkge1xuICAgICAgICBjb25zdCBmaXJzdENoaWxkID0gbGlzdEl0ZW1Ob2RlLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgICAgaWYgKCRpc0xpc3ROb2RlKGZpcnN0Q2hpbGQpKSB7XG4gICAgICAgICAgb3V0cHV0LnB1c2gobGlzdEV4cG9ydChmaXJzdENoaWxkLCBleHBvcnRDaGlsZHJlbiwgZGVwdGggKyAxKSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGluZGVudCA9ICcgJy5yZXBlYXQoZGVwdGggKiBMSVNUX0lOREVOVF9TSVpFKTtcbiAgICAgIGNvbnN0IGxpc3RUeXBlID0gbGlzdE5vZGUuZ2V0TGlzdFR5cGUoKTtcbiAgICAgIGNvbnN0IHByZWZpeCA9IGxpc3RUeXBlID09PSAnbnVtYmVyJyA/IGAke2xpc3ROb2RlLmdldFN0YXJ0KCkgKyBpbmRleH0uIGAgOiBsaXN0VHlwZSA9PT0gJ2NoZWNrJyA/IGAtIFske2xpc3RJdGVtTm9kZS5nZXRDaGVja2VkKCkgPyAneCcgOiAnICd9XSBgIDogJy0gJztcbiAgICAgIG91dHB1dC5wdXNoKGluZGVudCArIHByZWZpeCArIGV4cG9ydENoaWxkcmVuKGxpc3RJdGVtTm9kZSkpO1xuICAgICAgaW5kZXgrKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCdcXG4nKTtcbn07XG5jb25zdCBIRUFESU5HID0ge1xuICBkZXBlbmRlbmNpZXM6IFtIZWFkaW5nTm9kZV0sXG4gIGV4cG9ydDogKG5vZGUsIGV4cG9ydENoaWxkcmVuKSA9PiB7XG4gICAgaWYgKCEkaXNIZWFkaW5nTm9kZShub2RlKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGxldmVsID0gTnVtYmVyKG5vZGUuZ2V0VGFnKCkuc2xpY2UoMSkpO1xuICAgIHJldHVybiAnIycucmVwZWF0KGxldmVsKSArICcgJyArIGV4cG9ydENoaWxkcmVuKG5vZGUpO1xuICB9LFxuICByZWdFeHA6IEhFQURJTkdfUkVHRVgsXG4gIHJlcGxhY2U6IGNyZWF0ZUJsb2NrTm9kZShtYXRjaCA9PiB7XG4gICAgY29uc3QgdGFnID0gJ2gnICsgbWF0Y2hbMV0ubGVuZ3RoO1xuICAgIHJldHVybiAkY3JlYXRlSGVhZGluZ05vZGUodGFnKTtcbiAgfSksXG4gIHR5cGU6ICdlbGVtZW50J1xufTtcbmNvbnN0IFFVT1RFID0ge1xuICBkZXBlbmRlbmNpZXM6IFtRdW90ZU5vZGVdLFxuICBleHBvcnQ6IChub2RlLCBleHBvcnRDaGlsZHJlbikgPT4ge1xuICAgIGlmICghJGlzUXVvdGVOb2RlKG5vZGUpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbGluZXMgPSBleHBvcnRDaGlsZHJlbihub2RlKS5zcGxpdCgnXFxuJyk7XG4gICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICBvdXRwdXQucHVzaCgnPiAnICsgbGluZSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQuam9pbignXFxuJyk7XG4gIH0sXG4gIHJlZ0V4cDogUVVPVEVfUkVHRVgsXG4gIHJlcGxhY2U6IChwYXJlbnROb2RlLCBjaGlsZHJlbiwgX21hdGNoLCBpc0ltcG9ydCkgPT4ge1xuICAgIGlmIChpc0ltcG9ydCkge1xuICAgICAgY29uc3QgcHJldmlvdXNOb2RlID0gcGFyZW50Tm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICAgIGlmICgkaXNRdW90ZU5vZGUocHJldmlvdXNOb2RlKSkge1xuICAgICAgICBwcmV2aW91c05vZGUuc3BsaWNlKHByZXZpb3VzTm9kZS5nZXRDaGlsZHJlblNpemUoKSwgMCwgWyRjcmVhdGVMaW5lQnJlYWtOb2RlKCksIC4uLmNoaWxkcmVuXSk7XG4gICAgICAgIHByZXZpb3VzTm9kZS5zZWxlY3QoMCwgMCk7XG4gICAgICAgIHBhcmVudE5vZGUucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9ICRjcmVhdGVRdW90ZU5vZGUoKTtcbiAgICBub2RlLmFwcGVuZCguLi5jaGlsZHJlbik7XG4gICAgcGFyZW50Tm9kZS5yZXBsYWNlKG5vZGUpO1xuICAgIG5vZGUuc2VsZWN0KDAsIDApO1xuICB9LFxuICB0eXBlOiAnZWxlbWVudCdcbn07XG5jb25zdCBDT0RFID0ge1xuICBkZXBlbmRlbmNpZXM6IFtDb2RlTm9kZV0sXG4gIGV4cG9ydDogbm9kZSA9PiB7XG4gICAgaWYgKCEkaXNDb2RlTm9kZShub2RlKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHRleHRDb250ZW50ID0gbm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgIHJldHVybiAnYGBgJyArIChub2RlLmdldExhbmd1YWdlKCkgfHwgJycpICsgKHRleHRDb250ZW50ID8gJ1xcbicgKyB0ZXh0Q29udGVudCA6ICcnKSArICdcXG4nICsgJ2BgYCc7XG4gIH0sXG4gIHJlZ0V4cEVuZDoge1xuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIHJlZ0V4cDogQ09ERV9FTkRfUkVHRVhcbiAgfSxcbiAgcmVnRXhwU3RhcnQ6IENPREVfU1RBUlRfUkVHRVgsXG4gIHJlcGxhY2U6IChyb290Tm9kZSwgY2hpbGRyZW4sIHN0YXJ0TWF0Y2gsIGVuZE1hdGNoLCBsaW5lc0luQmV0d2VlbiwgaXNJbXBvcnQpID0+IHtcbiAgICBsZXQgY29kZUJsb2NrTm9kZTtcbiAgICBsZXQgY29kZTtcbiAgICBpZiAoIWNoaWxkcmVuICYmIGxpbmVzSW5CZXR3ZWVuKSB7XG4gICAgICBpZiAobGluZXNJbkJldHdlZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIFNpbmdsZS1saW5lIGNvZGUgYmxvY2tzXG4gICAgICAgIGlmIChlbmRNYXRjaCkge1xuICAgICAgICAgIC8vIEVuZCBtYXRjaCBvbiBzYW1lIGxpbmUuIEV4YW1wbGU6IGBgYG1hcmtkb3duIGhlbGxvYGBgLiBtYXJrZG93biBzaG91bGQgbm90IGJlIGNvbnNpZGVyZWQgdGhlIGxhbmd1YWdlIGhlcmUuXG4gICAgICAgICAgY29kZUJsb2NrTm9kZSA9ICRjcmVhdGVDb2RlTm9kZSgpO1xuICAgICAgICAgIGNvZGUgPSBzdGFydE1hdGNoWzFdICsgbGluZXNJbkJldHdlZW5bMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm8gZW5kIG1hdGNoLiBXZSBzaG91bGQgYXNzdW1lIHRoZSBsYW5ndWFnZSBpcyBuZXh0IHRvIHRoZSBiYWNrdGlja3MgYW5kIHRoYXQgY29kZSB3aWxsIGJlIHR5cGVkIG9uIHRoZSBuZXh0IGxpbmUgaW4gdGhlIGZ1dHVyZVxuICAgICAgICAgIGNvZGVCbG9ja05vZGUgPSAkY3JlYXRlQ29kZU5vZGUoc3RhcnRNYXRjaFsxXSk7XG4gICAgICAgICAgY29kZSA9IGxpbmVzSW5CZXR3ZWVuWzBdLnN0YXJ0c1dpdGgoJyAnKSA/IGxpbmVzSW5CZXR3ZWVuWzBdLnNsaWNlKDEpIDogbGluZXNJbkJldHdlZW5bMF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRyZWF0IG11bHRpLWxpbmUgY29kZSBibG9ja3MgYXMgaWYgdGhleSBhbHdheXMgaGF2ZSBhbiBlbmQgbWF0Y2hcbiAgICAgICAgY29kZUJsb2NrTm9kZSA9ICRjcmVhdGVDb2RlTm9kZShzdGFydE1hdGNoWzFdKTtcbiAgICAgICAgaWYgKGxpbmVzSW5CZXR3ZWVuWzBdLnRyaW0oKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAvLyBGaWx0ZXIgb3V0IGFsbCBzdGFydCBhbmQgZW5kIGxpbmVzIHRoYXQgYXJlIGxlbmd0aCAwIHVudGlsIHdlIGZpbmQgdGhlIGZpcnN0IGxpbmUgd2l0aCBjb250ZW50XG4gICAgICAgICAgd2hpbGUgKGxpbmVzSW5CZXR3ZWVuLmxlbmd0aCA+IDAgJiYgIWxpbmVzSW5CZXR3ZWVuWzBdLmxlbmd0aCkge1xuICAgICAgICAgICAgbGluZXNJbkJldHdlZW4uc2hpZnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhlIGZpcnN0IGxpbmUgYWxyZWFkeSBoYXMgY29udGVudCA9PiBSZW1vdmUgdGhlIGZpcnN0IHNwYWNlIG9mIHRoZSBsaW5lIGlmIGl0IGV4aXN0c1xuICAgICAgICAgIGxpbmVzSW5CZXR3ZWVuWzBdID0gbGluZXNJbkJldHdlZW5bMF0uc3RhcnRzV2l0aCgnICcpID8gbGluZXNJbkJldHdlZW5bMF0uc2xpY2UoMSkgOiBsaW5lc0luQmV0d2VlblswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbHRlciBvdXQgYWxsIGVuZCBsaW5lcyB0aGF0IGFyZSBsZW5ndGggMCB1bnRpbCB3ZSBmaW5kIHRoZSBsYXN0IGxpbmUgd2l0aCBjb250ZW50XG4gICAgICAgIHdoaWxlIChsaW5lc0luQmV0d2Vlbi5sZW5ndGggPiAwICYmICFsaW5lc0luQmV0d2VlbltsaW5lc0luQmV0d2Vlbi5sZW5ndGggLSAxXS5sZW5ndGgpIHtcbiAgICAgICAgICBsaW5lc0luQmV0d2Vlbi5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBjb2RlID0gbGluZXNJbkJldHdlZW4uam9pbignXFxuJyk7XG4gICAgICB9XG4gICAgICBjb25zdCB0ZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZShjb2RlKTtcbiAgICAgIGNvZGVCbG9ja05vZGUuYXBwZW5kKHRleHROb2RlKTtcbiAgICAgIHJvb3ROb2RlLmFwcGVuZChjb2RlQmxvY2tOb2RlKTtcbiAgICB9IGVsc2UgaWYgKGNoaWxkcmVuKSB7XG4gICAgICBjcmVhdGVCbG9ja05vZGUobWF0Y2ggPT4ge1xuICAgICAgICByZXR1cm4gJGNyZWF0ZUNvZGVOb2RlKG1hdGNoID8gbWF0Y2hbMV0gOiB1bmRlZmluZWQpO1xuICAgICAgfSkocm9vdE5vZGUsIGNoaWxkcmVuLCBzdGFydE1hdGNoLCBpc0ltcG9ydCk7XG4gICAgfVxuICB9LFxuICB0eXBlOiAnbXVsdGlsaW5lLWVsZW1lbnQnXG59O1xuY29uc3QgVU5PUkRFUkVEX0xJU1QgPSB7XG4gIGRlcGVuZGVuY2llczogW0xpc3ROb2RlLCBMaXN0SXRlbU5vZGVdLFxuICBleHBvcnQ6IChub2RlLCBleHBvcnRDaGlsZHJlbikgPT4ge1xuICAgIHJldHVybiAkaXNMaXN0Tm9kZShub2RlKSA/IGxpc3RFeHBvcnQobm9kZSwgZXhwb3J0Q2hpbGRyZW4sIDApIDogbnVsbDtcbiAgfSxcbiAgcmVnRXhwOiBVTk9SREVSRURfTElTVF9SRUdFWCxcbiAgcmVwbGFjZTogbGlzdFJlcGxhY2UoJ2J1bGxldCcpLFxuICB0eXBlOiAnZWxlbWVudCdcbn07XG5jb25zdCBDSEVDS19MSVNUID0ge1xuICBkZXBlbmRlbmNpZXM6IFtMaXN0Tm9kZSwgTGlzdEl0ZW1Ob2RlXSxcbiAgZXhwb3J0OiAobm9kZSwgZXhwb3J0Q2hpbGRyZW4pID0+IHtcbiAgICByZXR1cm4gJGlzTGlzdE5vZGUobm9kZSkgPyBsaXN0RXhwb3J0KG5vZGUsIGV4cG9ydENoaWxkcmVuLCAwKSA6IG51bGw7XG4gIH0sXG4gIHJlZ0V4cDogQ0hFQ0tfTElTVF9SRUdFWCxcbiAgcmVwbGFjZTogbGlzdFJlcGxhY2UoJ2NoZWNrJyksXG4gIHR5cGU6ICdlbGVtZW50J1xufTtcbmNvbnN0IE9SREVSRURfTElTVCA9IHtcbiAgZGVwZW5kZW5jaWVzOiBbTGlzdE5vZGUsIExpc3RJdGVtTm9kZV0sXG4gIGV4cG9ydDogKG5vZGUsIGV4cG9ydENoaWxkcmVuKSA9PiB7XG4gICAgcmV0dXJuICRpc0xpc3ROb2RlKG5vZGUpID8gbGlzdEV4cG9ydChub2RlLCBleHBvcnRDaGlsZHJlbiwgMCkgOiBudWxsO1xuICB9LFxuICByZWdFeHA6IE9SREVSRURfTElTVF9SRUdFWCxcbiAgcmVwbGFjZTogbGlzdFJlcGxhY2UoJ251bWJlcicpLFxuICB0eXBlOiAnZWxlbWVudCdcbn07XG5jb25zdCBJTkxJTkVfQ09ERSA9IHtcbiAgZm9ybWF0OiBbJ2NvZGUnXSxcbiAgdGFnOiAnYCcsXG4gIHR5cGU6ICd0ZXh0LWZvcm1hdCdcbn07XG5jb25zdCBISUdITElHSFQgPSB7XG4gIGZvcm1hdDogWydoaWdobGlnaHQnXSxcbiAgdGFnOiAnPT0nLFxuICB0eXBlOiAndGV4dC1mb3JtYXQnXG59O1xuY29uc3QgQk9MRF9JVEFMSUNfU1RBUiA9IHtcbiAgZm9ybWF0OiBbJ2JvbGQnLCAnaXRhbGljJ10sXG4gIHRhZzogJyoqKicsXG4gIHR5cGU6ICd0ZXh0LWZvcm1hdCdcbn07XG5jb25zdCBCT0xEX0lUQUxJQ19VTkRFUlNDT1JFID0ge1xuICBmb3JtYXQ6IFsnYm9sZCcsICdpdGFsaWMnXSxcbiAgaW50cmF3b3JkOiBmYWxzZSxcbiAgdGFnOiAnX19fJyxcbiAgdHlwZTogJ3RleHQtZm9ybWF0J1xufTtcbmNvbnN0IEJPTERfU1RBUiA9IHtcbiAgZm9ybWF0OiBbJ2JvbGQnXSxcbiAgdGFnOiAnKionLFxuICB0eXBlOiAndGV4dC1mb3JtYXQnXG59O1xuY29uc3QgQk9MRF9VTkRFUlNDT1JFID0ge1xuICBmb3JtYXQ6IFsnYm9sZCddLFxuICBpbnRyYXdvcmQ6IGZhbHNlLFxuICB0YWc6ICdfXycsXG4gIHR5cGU6ICd0ZXh0LWZvcm1hdCdcbn07XG5jb25zdCBTVFJJS0VUSFJPVUdIID0ge1xuICBmb3JtYXQ6IFsnc3RyaWtldGhyb3VnaCddLFxuICB0YWc6ICd+ficsXG4gIHR5cGU6ICd0ZXh0LWZvcm1hdCdcbn07XG5jb25zdCBJVEFMSUNfU1RBUiA9IHtcbiAgZm9ybWF0OiBbJ2l0YWxpYyddLFxuICB0YWc6ICcqJyxcbiAgdHlwZTogJ3RleHQtZm9ybWF0J1xufTtcbmNvbnN0IElUQUxJQ19VTkRFUlNDT1JFID0ge1xuICBmb3JtYXQ6IFsnaXRhbGljJ10sXG4gIGludHJhd29yZDogZmFsc2UsXG4gIHRhZzogJ18nLFxuICB0eXBlOiAndGV4dC1mb3JtYXQnXG59O1xuXG4vLyBPcmRlciBvZiB0ZXh0IHRyYW5zZm9ybWVycyBtYXR0ZXJzOlxuLy9cbi8vIC0gY29kZSBzaG91bGQgZ28gZmlyc3QgYXMgaXQgcHJldmVudHMgYW55IHRyYW5zZm9ybWF0aW9ucyBpbnNpZGVcbi8vIC0gdGhlbiBsb25nZXIgdGFncyBtYXRjaCAoZS5nLiAqKiBvciBfXyBzaG91bGQgZ28gYmVmb3JlICogb3IgXylcbmNvbnN0IExJTksgPSB7XG4gIGRlcGVuZGVuY2llczogW0xpbmtOb2RlXSxcbiAgZXhwb3J0OiAobm9kZSwgZXhwb3J0Q2hpbGRyZW4sIGV4cG9ydEZvcm1hdCkgPT4ge1xuICAgIGlmICghJGlzTGlua05vZGUobm9kZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB0aXRsZSA9IG5vZGUuZ2V0VGl0bGUoKTtcbiAgICBjb25zdCBsaW5rQ29udGVudCA9IHRpdGxlID8gYFske25vZGUuZ2V0VGV4dENvbnRlbnQoKX1dKCR7bm9kZS5nZXRVUkwoKX0gXCIke3RpdGxlfVwiKWAgOiBgWyR7bm9kZS5nZXRUZXh0Q29udGVudCgpfV0oJHtub2RlLmdldFVSTCgpfSlgO1xuICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBub2RlLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAvLyBBZGQgdGV4dCBzdHlsZXMgb25seSBpZiBsaW5rIGhhcyBzaW5nbGUgdGV4dCBub2RlIGluc2lkZS4gSWYgaXQncyBtb3JlXG4gICAgLy8gdGhlbiBvbmUgd2UgaWdub3JlIGl0IGFzIG1hcmtkb3duIGRvZXMgbm90IHN1cHBvcnQgbmVzdGVkIHN0eWxlcyBmb3IgbGlua3NcbiAgICBpZiAobm9kZS5nZXRDaGlsZHJlblNpemUoKSA9PT0gMSAmJiAkaXNUZXh0Tm9kZShmaXJzdENoaWxkKSkge1xuICAgICAgcmV0dXJuIGV4cG9ydEZvcm1hdChmaXJzdENoaWxkLCBsaW5rQ29udGVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBsaW5rQ29udGVudDtcbiAgICB9XG4gIH0sXG4gIGltcG9ydFJlZ0V4cDogLyg/OlxcWyhbXltdKylcXF0pKD86XFwoKD86KFteKClcXHNdKykoPzpcXHNcIigoPzpbXlwiXSpcXFxcXCIpKlteXCJdKilcIlxccyopPylcXCkpLyxcbiAgcmVnRXhwOiAvKD86XFxbKFteW10rKVxcXSkoPzpcXCgoPzooW14oKVxcc10rKSg/Olxcc1wiKCg/OlteXCJdKlxcXFxcIikqW15cIl0qKVwiXFxzKik/KVxcKSkkLyxcbiAgcmVwbGFjZTogKHRleHROb2RlLCBtYXRjaCkgPT4ge1xuICAgIGNvbnN0IFssIGxpbmtUZXh0LCBsaW5rVXJsLCBsaW5rVGl0bGVdID0gbWF0Y2g7XG4gICAgY29uc3QgbGlua05vZGUgPSAkY3JlYXRlTGlua05vZGUobGlua1VybCwge1xuICAgICAgdGl0bGU6IGxpbmtUaXRsZVxuICAgIH0pO1xuICAgIGNvbnN0IGxpbmtUZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZShsaW5rVGV4dCk7XG4gICAgbGlua1RleHROb2RlLnNldEZvcm1hdCh0ZXh0Tm9kZS5nZXRGb3JtYXQoKSk7XG4gICAgbGlua05vZGUuYXBwZW5kKGxpbmtUZXh0Tm9kZSk7XG4gICAgdGV4dE5vZGUucmVwbGFjZShsaW5rTm9kZSk7XG4gIH0sXG4gIHRyaWdnZXI6ICcpJyxcbiAgdHlwZTogJ3RleHQtbWF0Y2gnXG59O1xuZnVuY3Rpb24gbm9ybWFsaXplTWFya2Rvd24oaW5wdXQsIHNob3VsZE1lcmdlQWRqYWNlbnRMaW5lcyA9IGZhbHNlKSB7XG4gIGNvbnN0IGxpbmVzID0gaW5wdXQuc3BsaXQoJ1xcbicpO1xuICBsZXQgaW5Db2RlQmxvY2sgPSBmYWxzZTtcbiAgY29uc3Qgc2FuaXRpemVkTGluZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXTtcbiAgICBjb25zdCBsYXN0TGluZSA9IHNhbml0aXplZExpbmVzW3Nhbml0aXplZExpbmVzLmxlbmd0aCAtIDFdO1xuXG4gICAgLy8gQ29kZSBibG9ja3Mgb2YgYGBgc2luZ2xlIGxpbmVgYGAgZG9uJ3QgdG9nZ2xlIHRoZSBpbkNvZGVCbG9jayBmbGFnXG4gICAgaWYgKENPREVfU0lOR0xFX0xJTkVfUkVHRVgudGVzdChsaW5lKSkge1xuICAgICAgc2FuaXRpemVkTGluZXMucHVzaChsaW5lKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIERldGVjdCB0aGUgc3RhcnQgb3IgZW5kIG9mIGEgY29kZSBibG9ja1xuICAgIGlmIChDT0RFX1NUQVJUX1JFR0VYLnRlc3QobGluZSkgfHwgQ09ERV9FTkRfUkVHRVgudGVzdChsaW5lKSkge1xuICAgICAgaW5Db2RlQmxvY2sgPSAhaW5Db2RlQmxvY2s7XG4gICAgICBzYW5pdGl6ZWRMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgYXJlIGluc2lkZSBhIGNvZGUgYmxvY2ssIGtlZXAgdGhlIGxpbmUgdW5jaGFuZ2VkXG4gICAgaWYgKGluQ29kZUJsb2NrKSB7XG4gICAgICBzYW5pdGl6ZWRMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gSW4gbWFya2Rvd24gdGhlIGNvbmNlcHQgb2YgXCJlbXB0eSBwYXJhZ3JhcGhzXCIgZG9lcyBub3QgZXhpc3QuXG4gICAgLy8gQmxvY2tzIG11c3QgYmUgc2VwYXJhdGVkIGJ5IGFuIGVtcHR5IGxpbmUuIE5vbi1lbXB0eSBhZGphY2VudCBsaW5lcyBtdXN0IGJlIG1lcmdlZC5cbiAgICBpZiAobGluZSA9PT0gJycgfHwgbGFzdExpbmUgPT09ICcnIHx8ICFsYXN0TGluZSB8fCBIRUFESU5HX1JFR0VYLnRlc3QobGFzdExpbmUpIHx8IEhFQURJTkdfUkVHRVgudGVzdChsaW5lKSB8fCBRVU9URV9SRUdFWC50ZXN0KGxpbmUpIHx8IE9SREVSRURfTElTVF9SRUdFWC50ZXN0KGxpbmUpIHx8IFVOT1JERVJFRF9MSVNUX1JFR0VYLnRlc3QobGluZSkgfHwgQ0hFQ0tfTElTVF9SRUdFWC50ZXN0KGxpbmUpIHx8IFRBQkxFX1JPV19SRUdfRVhQLnRlc3QobGluZSkgfHwgVEFCTEVfUk9XX0RJVklERVJfUkVHX0VYUC50ZXN0KGxpbmUpIHx8ICFzaG91bGRNZXJnZUFkamFjZW50TGluZXMpIHtcbiAgICAgIHNhbml0aXplZExpbmVzLnB1c2gobGluZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNhbml0aXplZExpbmVzW3Nhbml0aXplZExpbmVzLmxlbmd0aCAtIDFdID0gbGFzdExpbmUgKyBsaW5lO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2FuaXRpemVkTGluZXMuam9pbignXFxuJyk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgRUxFTUVOVF9UUkFOU0ZPUk1FUlMgPSBbSEVBRElORywgUVVPVEUsIFVOT1JERVJFRF9MSVNULCBPUkRFUkVEX0xJU1RdO1xuY29uc3QgTVVMVElMSU5FX0VMRU1FTlRfVFJBTlNGT1JNRVJTID0gW0NPREVdO1xuXG4vLyBPcmRlciBvZiB0ZXh0IGZvcm1hdCB0cmFuc2Zvcm1lcnMgbWF0dGVyczpcbi8vXG4vLyAtIGNvZGUgc2hvdWxkIGdvIGZpcnN0IGFzIGl0IHByZXZlbnRzIGFueSB0cmFuc2Zvcm1hdGlvbnMgaW5zaWRlXG4vLyAtIHRoZW4gbG9uZ2VyIHRhZ3MgbWF0Y2ggKGUuZy4gKiogb3IgX18gc2hvdWxkIGdvIGJlZm9yZSAqIG9yIF8pXG5jb25zdCBURVhUX0ZPUk1BVF9UUkFOU0ZPUk1FUlMgPSBbSU5MSU5FX0NPREUsIEJPTERfSVRBTElDX1NUQVIsIEJPTERfSVRBTElDX1VOREVSU0NPUkUsIEJPTERfU1RBUiwgQk9MRF9VTkRFUlNDT1JFLCBISUdITElHSFQsIElUQUxJQ19TVEFSLCBJVEFMSUNfVU5ERVJTQ09SRSwgU1RSSUtFVEhST1VHSF07XG5jb25zdCBURVhUX01BVENIX1RSQU5TRk9STUVSUyA9IFtMSU5LXTtcbmNvbnN0IFRSQU5TRk9STUVSUyA9IFsuLi5FTEVNRU5UX1RSQU5TRk9STUVSUywgLi4uTVVMVElMSU5FX0VMRU1FTlRfVFJBTlNGT1JNRVJTLCAuLi5URVhUX0ZPUk1BVF9UUkFOU0ZPUk1FUlMsIC4uLlRFWFRfTUFUQ0hfVFJBTlNGT1JNRVJTXTtcblxuLyoqXG4gKiBSZW5kZXJzIG1hcmtkb3duIGZyb20gYSBzdHJpbmcuIFRoZSBzZWxlY3Rpb24gaXMgbW92ZWQgdG8gdGhlIHN0YXJ0IGFmdGVyIHRoZSBvcGVyYXRpb24uXG4gKlxuICogIEBwYXJhbSB7Ym9vbGVhbn0gW3Nob3VsZFByZXNlcnZlTmV3TGluZXNdIEJ5IHNldHRpbmcgdGhpcyB0byB0cnVlLCBuZXcgbGluZXMgd2lsbCBiZSBwcmVzZXJ2ZWQgYmV0d2VlbiBjb252ZXJzaW9uc1xuICogIEBwYXJhbSB7Ym9vbGVhbn0gW3Nob3VsZE1lcmdlQWRqYWNlbnRMaW5lc10gQnkgc2V0dGluZyB0aGlzIHRvIHRydWUsIGFkamFjZW50IG5vbiBlbXB0eSBsaW5lcyB3aWxsIGJlIG1lcmdlZCBhY2NvcmRpbmcgdG8gY29tbW9ubWFyayBzcGVjOiBodHRwczovL3NwZWMuY29tbW9ubWFyay5vcmcvMC4yNC8jZXhhbXBsZS0xNzcuIE5vdCBhcHBsaWNhYmxlIGlmIHNob3VsZFByZXNlcnZlTmV3TGluZXMgPSB0cnVlLlxuICovXG5mdW5jdGlvbiAkY29udmVydEZyb21NYXJrZG93blN0cmluZyhtYXJrZG93biwgdHJhbnNmb3JtZXJzID0gVFJBTlNGT1JNRVJTLCBub2RlLCBzaG91bGRQcmVzZXJ2ZU5ld0xpbmVzID0gZmFsc2UsIHNob3VsZE1lcmdlQWRqYWNlbnRMaW5lcyA9IGZhbHNlKSB7XG4gIGNvbnN0IHNhbml0aXplZE1hcmtkb3duID0gc2hvdWxkUHJlc2VydmVOZXdMaW5lcyA/IG1hcmtkb3duIDogbm9ybWFsaXplTWFya2Rvd24obWFya2Rvd24sIHNob3VsZE1lcmdlQWRqYWNlbnRMaW5lcyk7XG4gIGNvbnN0IGltcG9ydE1hcmtkb3duID0gY3JlYXRlTWFya2Rvd25JbXBvcnQodHJhbnNmb3JtZXJzLCBzaG91bGRQcmVzZXJ2ZU5ld0xpbmVzKTtcbiAgcmV0dXJuIGltcG9ydE1hcmtkb3duKHNhbml0aXplZE1hcmtkb3duLCBub2RlKTtcbn1cblxuLyoqXG4gKiBSZW5kZXJzIHN0cmluZyBmcm9tIG1hcmtkb3duLiBUaGUgc2VsZWN0aW9uIGlzIG1vdmVkIHRvIHRoZSBzdGFydCBhZnRlciB0aGUgb3BlcmF0aW9uLlxuICovXG5mdW5jdGlvbiAkY29udmVydFRvTWFya2Rvd25TdHJpbmcodHJhbnNmb3JtZXJzID0gVFJBTlNGT1JNRVJTLCBub2RlLCBzaG91bGRQcmVzZXJ2ZU5ld0xpbmVzID0gZmFsc2UpIHtcbiAgY29uc3QgZXhwb3J0TWFya2Rvd24gPSBjcmVhdGVNYXJrZG93bkV4cG9ydCh0cmFuc2Zvcm1lcnMsIHNob3VsZFByZXNlcnZlTmV3TGluZXMpO1xuICByZXR1cm4gZXhwb3J0TWFya2Rvd24obm9kZSk7XG59XG5cbmV4cG9ydCB7ICRjb252ZXJ0RnJvbU1hcmtkb3duU3RyaW5nLCAkY29udmVydFRvTWFya2Rvd25TdHJpbmcsIEJPTERfSVRBTElDX1NUQVIsIEJPTERfSVRBTElDX1VOREVSU0NPUkUsIEJPTERfU1RBUiwgQk9MRF9VTkRFUlNDT1JFLCBDSEVDS19MSVNULCBDT0RFLCBFTEVNRU5UX1RSQU5TRk9STUVSUywgSEVBRElORywgSElHSExJR0hULCBJTkxJTkVfQ09ERSwgSVRBTElDX1NUQVIsIElUQUxJQ19VTkRFUlNDT1JFLCBMSU5LLCBNVUxUSUxJTkVfRUxFTUVOVF9UUkFOU0ZPUk1FUlMsIE9SREVSRURfTElTVCwgUVVPVEUsIFNUUklLRVRIUk9VR0gsIFRFWFRfRk9STUFUX1RSQU5TRk9STUVSUywgVEVYVF9NQVRDSF9UUkFOU0ZPUk1FUlMsIFRSQU5TRk9STUVSUywgVU5PUkRFUkVEX0xJU1QsIHJlZ2lzdGVyTWFya2Rvd25TaG9ydGN1dHMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@lexical+markdown@0.20.0/node_modules/@lexical/markdown/LexicalMarkdown.dev.mjs\n");

/***/ })

};
;
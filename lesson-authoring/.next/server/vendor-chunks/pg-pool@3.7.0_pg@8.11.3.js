"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pg-pool@3.7.0_pg@8.11.3";
exports.ids = ["vendor-chunks/pg-pool@3.7.0_pg@8.11.3"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/pg-pool@3.7.0_pg@8.11.3/node_modules/pg-pool/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/.pnpm/pg-pool@3.7.0_pg@8.11.3/node_modules/pg-pool/index.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter)\n\nconst NOOP = function () {}\n\nconst removeWhere = (list, predicate) => {\n  const i = list.findIndex(predicate)\n\n  return i === -1 ? undefined : list.splice(i, 1)[0]\n}\n\nclass IdleItem {\n  constructor(client, idleListener, timeoutId) {\n    this.client = client\n    this.idleListener = idleListener\n    this.timeoutId = timeoutId\n  }\n}\n\nclass PendingItem {\n  constructor(callback) {\n    this.callback = callback\n  }\n}\n\nfunction throwOnDoubleRelease() {\n  throw new Error('Release called on client which has already been released to the pool.')\n}\n\nfunction promisify(Promise, callback) {\n  if (callback) {\n    return { callback: callback, result: undefined }\n  }\n  let rej\n  let res\n  const cb = function (err, client) {\n    err ? rej(err) : res(client)\n  }\n  const result = new Promise(function (resolve, reject) {\n    res = resolve\n    rej = reject\n  }).catch((err) => {\n    // replace the stack trace that leads to `TCP.onStreamRead` with one that leads back to the\n    // application that created the query\n    Error.captureStackTrace(err)\n    throw err\n  })\n  return { callback: cb, result: result }\n}\n\nfunction makeIdleListener(pool, client) {\n  return function idleListener(err) {\n    err.client = client\n\n    client.removeListener('error', idleListener)\n    client.on('error', () => {\n      pool.log('additional client error after disconnection due to error', err)\n    })\n    pool._remove(client)\n    // TODO - document that once the pool emits an error\n    // the client has already been closed & purged and is unusable\n    pool.emit('error', err, client)\n  }\n}\n\nclass Pool extends EventEmitter {\n  constructor(options, Client) {\n    super()\n    this.options = Object.assign({}, options)\n\n    if (options != null && 'password' in options) {\n      // \"hiding\" the password so it doesn't show up in stack traces\n      // or if the client is console.logged\n      Object.defineProperty(this.options, 'password', {\n        configurable: true,\n        enumerable: false,\n        writable: true,\n        value: options.password,\n      })\n    }\n    if (options != null && options.ssl && options.ssl.key) {\n      // \"hiding\" the ssl->key so it doesn't show up in stack traces\n      // or if the client is console.logged\n      Object.defineProperty(this.options.ssl, 'key', {\n        enumerable: false,\n      })\n    }\n\n    this.options.max = this.options.max || this.options.poolSize || 10\n    this.options.maxUses = this.options.maxUses || Infinity\n    this.options.allowExitOnIdle = this.options.allowExitOnIdle || false\n    this.options.maxLifetimeSeconds = this.options.maxLifetimeSeconds || 0\n    this.log = this.options.log || function () {}\n    this.Client = this.options.Client || Client || (__webpack_require__(/*! pg */ \"(rsc)/./node_modules/.pnpm/pg@8.11.3/node_modules/pg/lib/index.js\").Client)\n    this.Promise = this.options.Promise || global.Promise\n\n    if (typeof this.options.idleTimeoutMillis === 'undefined') {\n      this.options.idleTimeoutMillis = 10000\n    }\n\n    this._clients = []\n    this._idle = []\n    this._expired = new WeakSet()\n    this._pendingQueue = []\n    this._endCallback = undefined\n    this.ending = false\n    this.ended = false\n  }\n\n  _isFull() {\n    return this._clients.length >= this.options.max\n  }\n\n  _pulseQueue() {\n    this.log('pulse queue')\n    if (this.ended) {\n      this.log('pulse queue ended')\n      return\n    }\n    if (this.ending) {\n      this.log('pulse queue on ending')\n      if (this._idle.length) {\n        this._idle.slice().map((item) => {\n          this._remove(item.client)\n        })\n      }\n      if (!this._clients.length) {\n        this.ended = true\n        this._endCallback()\n      }\n      return\n    }\n\n    // if we don't have any waiting, do nothing\n    if (!this._pendingQueue.length) {\n      this.log('no queued requests')\n      return\n    }\n    // if we don't have any idle clients and we have no more room do nothing\n    if (!this._idle.length && this._isFull()) {\n      return\n    }\n    const pendingItem = this._pendingQueue.shift()\n    if (this._idle.length) {\n      const idleItem = this._idle.pop()\n      clearTimeout(idleItem.timeoutId)\n      const client = idleItem.client\n      client.ref && client.ref()\n      const idleListener = idleItem.idleListener\n\n      return this._acquireClient(client, pendingItem, idleListener, false)\n    }\n    if (!this._isFull()) {\n      return this.newClient(pendingItem)\n    }\n    throw new Error('unexpected condition')\n  }\n\n  _remove(client) {\n    const removed = removeWhere(this._idle, (item) => item.client === client)\n\n    if (removed !== undefined) {\n      clearTimeout(removed.timeoutId)\n    }\n\n    this._clients = this._clients.filter((c) => c !== client)\n    client.end()\n    this.emit('remove', client)\n  }\n\n  connect(cb) {\n    if (this.ending) {\n      const err = new Error('Cannot use a pool after calling end on the pool')\n      return cb ? cb(err) : this.Promise.reject(err)\n    }\n\n    const response = promisify(this.Promise, cb)\n    const result = response.result\n\n    // if we don't have to connect a new client, don't do so\n    if (this._isFull() || this._idle.length) {\n      // if we have idle clients schedule a pulse immediately\n      if (this._idle.length) {\n        process.nextTick(() => this._pulseQueue())\n      }\n\n      if (!this.options.connectionTimeoutMillis) {\n        this._pendingQueue.push(new PendingItem(response.callback))\n        return result\n      }\n\n      const queueCallback = (err, res, done) => {\n        clearTimeout(tid)\n        response.callback(err, res, done)\n      }\n\n      const pendingItem = new PendingItem(queueCallback)\n\n      // set connection timeout on checking out an existing client\n      const tid = setTimeout(() => {\n        // remove the callback from pending waiters because\n        // we're going to call it with a timeout error\n        removeWhere(this._pendingQueue, (i) => i.callback === queueCallback)\n        pendingItem.timedOut = true\n        response.callback(new Error('timeout exceeded when trying to connect'))\n      }, this.options.connectionTimeoutMillis)\n\n      this._pendingQueue.push(pendingItem)\n      return result\n    }\n\n    this.newClient(new PendingItem(response.callback))\n\n    return result\n  }\n\n  newClient(pendingItem) {\n    const client = new this.Client(this.options)\n    this._clients.push(client)\n    const idleListener = makeIdleListener(this, client)\n\n    this.log('checking client timeout')\n\n    // connection timeout logic\n    let tid\n    let timeoutHit = false\n    if (this.options.connectionTimeoutMillis) {\n      tid = setTimeout(() => {\n        this.log('ending client due to timeout')\n        timeoutHit = true\n        // force kill the node driver, and let libpq do its teardown\n        client.connection ? client.connection.stream.destroy() : client.end()\n      }, this.options.connectionTimeoutMillis)\n    }\n\n    this.log('connecting new client')\n    client.connect((err) => {\n      if (tid) {\n        clearTimeout(tid)\n      }\n      client.on('error', idleListener)\n      if (err) {\n        this.log('client failed to connect', err)\n        // remove the dead client from our list of clients\n        this._clients = this._clients.filter((c) => c !== client)\n        if (timeoutHit) {\n          err.message = 'Connection terminated due to connection timeout'\n        }\n\n        // this client wonâ€™t be released, so move on immediately\n        this._pulseQueue()\n\n        if (!pendingItem.timedOut) {\n          pendingItem.callback(err, undefined, NOOP)\n        }\n      } else {\n        this.log('new client connected')\n\n        if (this.options.maxLifetimeSeconds !== 0) {\n          const maxLifetimeTimeout = setTimeout(() => {\n            this.log('ending client due to expired lifetime')\n            this._expired.add(client)\n            const idleIndex = this._idle.findIndex((idleItem) => idleItem.client === client)\n            if (idleIndex !== -1) {\n              this._acquireClient(\n                client,\n                new PendingItem((err, client, clientRelease) => clientRelease()),\n                idleListener,\n                false\n              )\n            }\n          }, this.options.maxLifetimeSeconds * 1000)\n\n          maxLifetimeTimeout.unref()\n          client.once('end', () => clearTimeout(maxLifetimeTimeout))\n        }\n\n        return this._acquireClient(client, pendingItem, idleListener, true)\n      }\n    })\n  }\n\n  // acquire a client for a pending work item\n  _acquireClient(client, pendingItem, idleListener, isNew) {\n    if (isNew) {\n      this.emit('connect', client)\n    }\n\n    this.emit('acquire', client)\n\n    client.release = this._releaseOnce(client, idleListener)\n\n    client.removeListener('error', idleListener)\n\n    if (!pendingItem.timedOut) {\n      if (isNew && this.options.verify) {\n        this.options.verify(client, (err) => {\n          if (err) {\n            client.release(err)\n            return pendingItem.callback(err, undefined, NOOP)\n          }\n\n          pendingItem.callback(undefined, client, client.release)\n        })\n      } else {\n        pendingItem.callback(undefined, client, client.release)\n      }\n    } else {\n      if (isNew && this.options.verify) {\n        this.options.verify(client, client.release)\n      } else {\n        client.release()\n      }\n    }\n  }\n\n  // returns a function that wraps _release and throws if called more than once\n  _releaseOnce(client, idleListener) {\n    let released = false\n\n    return (err) => {\n      if (released) {\n        throwOnDoubleRelease()\n      }\n\n      released = true\n      this._release(client, idleListener, err)\n    }\n  }\n\n  // release a client back to the poll, include an error\n  // to remove it from the pool\n  _release(client, idleListener, err) {\n    client.on('error', idleListener)\n\n    client._poolUseCount = (client._poolUseCount || 0) + 1\n\n    this.emit('release', err, client)\n\n    // TODO(bmc): expose a proper, public interface _queryable and _ending\n    if (err || this.ending || !client._queryable || client._ending || client._poolUseCount >= this.options.maxUses) {\n      if (client._poolUseCount >= this.options.maxUses) {\n        this.log('remove expended client')\n      }\n      this._remove(client)\n      this._pulseQueue()\n      return\n    }\n\n    const isExpired = this._expired.has(client)\n    if (isExpired) {\n      this.log('remove expired client')\n      this._expired.delete(client)\n      this._remove(client)\n      this._pulseQueue()\n      return\n    }\n\n    // idle timeout\n    let tid\n    if (this.options.idleTimeoutMillis) {\n      tid = setTimeout(() => {\n        this.log('remove idle client')\n        this._remove(client)\n      }, this.options.idleTimeoutMillis)\n\n      if (this.options.allowExitOnIdle) {\n        // allow Node to exit if this is all that's left\n        tid.unref()\n      }\n    }\n\n    if (this.options.allowExitOnIdle) {\n      client.unref()\n    }\n\n    this._idle.push(new IdleItem(client, idleListener, tid))\n    this._pulseQueue()\n  }\n\n  query(text, values, cb) {\n    // guard clause against passing a function as the first parameter\n    if (typeof text === 'function') {\n      const response = promisify(this.Promise, text)\n      setImmediate(function () {\n        return response.callback(new Error('Passing a function as the first parameter to pool.query is not supported'))\n      })\n      return response.result\n    }\n\n    // allow plain text query without values\n    if (typeof values === 'function') {\n      cb = values\n      values = undefined\n    }\n    const response = promisify(this.Promise, cb)\n    cb = response.callback\n\n    this.connect((err, client) => {\n      if (err) {\n        return cb(err)\n      }\n\n      let clientReleased = false\n      const onError = (err) => {\n        if (clientReleased) {\n          return\n        }\n        clientReleased = true\n        client.release(err)\n        cb(err)\n      }\n\n      client.once('error', onError)\n      this.log('dispatching query')\n      try {\n        client.query(text, values, (err, res) => {\n          this.log('query dispatched')\n          client.removeListener('error', onError)\n          if (clientReleased) {\n            return\n          }\n          clientReleased = true\n          client.release(err)\n          if (err) {\n            return cb(err)\n          }\n          return cb(undefined, res)\n        })\n      } catch (err) {\n        client.release(err)\n        return cb(err)\n      }\n    })\n    return response.result\n  }\n\n  end(cb) {\n    this.log('ending')\n    if (this.ending) {\n      const err = new Error('Called end on pool more than once')\n      return cb ? cb(err) : this.Promise.reject(err)\n    }\n    this.ending = true\n    const promised = promisify(this.Promise, cb)\n    this._endCallback = promised.callback\n    this._pulseQueue()\n    return promised.result\n  }\n\n  get waitingCount() {\n    return this._pendingQueue.length\n  }\n\n  get idleCount() {\n    return this._idle.length\n  }\n\n  get expiredCount() {\n    return this._clients.reduce((acc, client) => acc + (this._expired.has(client) ? 1 : 0), 0)\n  }\n\n  get totalCount() {\n    return this._clients.length\n  }\n}\nmodule.exports = Pool\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vcGctcG9vbEAzLjcuMF9wZ0A4LjExLjMvbm9kZV9tb2R1bGVzL3BnLXBvb2wvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWixxQkFBcUIsMERBQThCOztBQUVuRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCwyR0FBb0I7QUFDdkU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVzc29uLWF1dGhvcmluZy8uL25vZGVfbW9kdWxlcy8ucG5wbS9wZy1wb29sQDMuNy4wX3BnQDguMTEuMy9ub2RlX21vZHVsZXMvcGctcG9vbC9pbmRleC5qcz8zYzYxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG5cbmNvbnN0IE5PT1AgPSBmdW5jdGlvbiAoKSB7fVxuXG5jb25zdCByZW1vdmVXaGVyZSA9IChsaXN0LCBwcmVkaWNhdGUpID0+IHtcbiAgY29uc3QgaSA9IGxpc3QuZmluZEluZGV4KHByZWRpY2F0ZSlcblxuICByZXR1cm4gaSA9PT0gLTEgPyB1bmRlZmluZWQgOiBsaXN0LnNwbGljZShpLCAxKVswXVxufVxuXG5jbGFzcyBJZGxlSXRlbSB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgaWRsZUxpc3RlbmVyLCB0aW1lb3V0SWQpIHtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudFxuICAgIHRoaXMuaWRsZUxpc3RlbmVyID0gaWRsZUxpc3RlbmVyXG4gICAgdGhpcy50aW1lb3V0SWQgPSB0aW1lb3V0SWRcbiAgfVxufVxuXG5jbGFzcyBQZW5kaW5nSXRlbSB7XG4gIGNvbnN0cnVjdG9yKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrXG4gIH1cbn1cblxuZnVuY3Rpb24gdGhyb3dPbkRvdWJsZVJlbGVhc2UoKSB7XG4gIHRocm93IG5ldyBFcnJvcignUmVsZWFzZSBjYWxsZWQgb24gY2xpZW50IHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gcmVsZWFzZWQgdG8gdGhlIHBvb2wuJylcbn1cblxuZnVuY3Rpb24gcHJvbWlzaWZ5KFByb21pc2UsIGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIHJldHVybiB7IGNhbGxiYWNrOiBjYWxsYmFjaywgcmVzdWx0OiB1bmRlZmluZWQgfVxuICB9XG4gIGxldCByZWpcbiAgbGV0IHJlc1xuICBjb25zdCBjYiA9IGZ1bmN0aW9uIChlcnIsIGNsaWVudCkge1xuICAgIGVyciA/IHJlaihlcnIpIDogcmVzKGNsaWVudClcbiAgfVxuICBjb25zdCByZXN1bHQgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmVzID0gcmVzb2x2ZVxuICAgIHJlaiA9IHJlamVjdFxuICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgLy8gcmVwbGFjZSB0aGUgc3RhY2sgdHJhY2UgdGhhdCBsZWFkcyB0byBgVENQLm9uU3RyZWFtUmVhZGAgd2l0aCBvbmUgdGhhdCBsZWFkcyBiYWNrIHRvIHRoZVxuICAgIC8vIGFwcGxpY2F0aW9uIHRoYXQgY3JlYXRlZCB0aGUgcXVlcnlcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIpXG4gICAgdGhyb3cgZXJyXG4gIH0pXG4gIHJldHVybiB7IGNhbGxiYWNrOiBjYiwgcmVzdWx0OiByZXN1bHQgfVxufVxuXG5mdW5jdGlvbiBtYWtlSWRsZUxpc3RlbmVyKHBvb2wsIGNsaWVudCkge1xuICByZXR1cm4gZnVuY3Rpb24gaWRsZUxpc3RlbmVyKGVycikge1xuICAgIGVyci5jbGllbnQgPSBjbGllbnRcblxuICAgIGNsaWVudC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBpZGxlTGlzdGVuZXIpXG4gICAgY2xpZW50Lm9uKCdlcnJvcicsICgpID0+IHtcbiAgICAgIHBvb2wubG9nKCdhZGRpdGlvbmFsIGNsaWVudCBlcnJvciBhZnRlciBkaXNjb25uZWN0aW9uIGR1ZSB0byBlcnJvcicsIGVycilcbiAgICB9KVxuICAgIHBvb2wuX3JlbW92ZShjbGllbnQpXG4gICAgLy8gVE9ETyAtIGRvY3VtZW50IHRoYXQgb25jZSB0aGUgcG9vbCBlbWl0cyBhbiBlcnJvclxuICAgIC8vIHRoZSBjbGllbnQgaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQgJiBwdXJnZWQgYW5kIGlzIHVudXNhYmxlXG4gICAgcG9vbC5lbWl0KCdlcnJvcicsIGVyciwgY2xpZW50KVxuICB9XG59XG5cbmNsYXNzIFBvb2wgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBDbGllbnQpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucylcblxuICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgJ3Bhc3N3b3JkJyBpbiBvcHRpb25zKSB7XG4gICAgICAvLyBcImhpZGluZ1wiIHRoZSBwYXNzd29yZCBzbyBpdCBkb2Vzbid0IHNob3cgdXAgaW4gc3RhY2sgdHJhY2VzXG4gICAgICAvLyBvciBpZiB0aGUgY2xpZW50IGlzIGNvbnNvbGUubG9nZ2VkXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5vcHRpb25zLCAncGFzc3dvcmQnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogb3B0aW9ucy5wYXNzd29yZCxcbiAgICAgIH0pXG4gICAgfVxuICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5zc2wgJiYgb3B0aW9ucy5zc2wua2V5KSB7XG4gICAgICAvLyBcImhpZGluZ1wiIHRoZSBzc2wtPmtleSBzbyBpdCBkb2Vzbid0IHNob3cgdXAgaW4gc3RhY2sgdHJhY2VzXG4gICAgICAvLyBvciBpZiB0aGUgY2xpZW50IGlzIGNvbnNvbGUubG9nZ2VkXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5vcHRpb25zLnNzbCwgJ2tleScsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucy5tYXggPSB0aGlzLm9wdGlvbnMubWF4IHx8IHRoaXMub3B0aW9ucy5wb29sU2l6ZSB8fCAxMFxuICAgIHRoaXMub3B0aW9ucy5tYXhVc2VzID0gdGhpcy5vcHRpb25zLm1heFVzZXMgfHwgSW5maW5pdHlcbiAgICB0aGlzLm9wdGlvbnMuYWxsb3dFeGl0T25JZGxlID0gdGhpcy5vcHRpb25zLmFsbG93RXhpdE9uSWRsZSB8fCBmYWxzZVxuICAgIHRoaXMub3B0aW9ucy5tYXhMaWZldGltZVNlY29uZHMgPSB0aGlzLm9wdGlvbnMubWF4TGlmZXRpbWVTZWNvbmRzIHx8IDBcbiAgICB0aGlzLmxvZyA9IHRoaXMub3B0aW9ucy5sb2cgfHwgZnVuY3Rpb24gKCkge31cbiAgICB0aGlzLkNsaWVudCA9IHRoaXMub3B0aW9ucy5DbGllbnQgfHwgQ2xpZW50IHx8IHJlcXVpcmUoJ3BnJykuQ2xpZW50XG4gICAgdGhpcy5Qcm9taXNlID0gdGhpcy5vcHRpb25zLlByb21pc2UgfHwgZ2xvYmFsLlByb21pc2VcblxuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmlkbGVUaW1lb3V0TWlsbGlzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5vcHRpb25zLmlkbGVUaW1lb3V0TWlsbGlzID0gMTAwMDBcbiAgICB9XG5cbiAgICB0aGlzLl9jbGllbnRzID0gW11cbiAgICB0aGlzLl9pZGxlID0gW11cbiAgICB0aGlzLl9leHBpcmVkID0gbmV3IFdlYWtTZXQoKVxuICAgIHRoaXMuX3BlbmRpbmdRdWV1ZSA9IFtdXG4gICAgdGhpcy5fZW5kQ2FsbGJhY2sgPSB1bmRlZmluZWRcbiAgICB0aGlzLmVuZGluZyA9IGZhbHNlXG4gICAgdGhpcy5lbmRlZCA9IGZhbHNlXG4gIH1cblxuICBfaXNGdWxsKCkge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnRzLmxlbmd0aCA+PSB0aGlzLm9wdGlvbnMubWF4XG4gIH1cblxuICBfcHVsc2VRdWV1ZSgpIHtcbiAgICB0aGlzLmxvZygncHVsc2UgcXVldWUnKVxuICAgIGlmICh0aGlzLmVuZGVkKSB7XG4gICAgICB0aGlzLmxvZygncHVsc2UgcXVldWUgZW5kZWQnKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICh0aGlzLmVuZGluZykge1xuICAgICAgdGhpcy5sb2coJ3B1bHNlIHF1ZXVlIG9uIGVuZGluZycpXG4gICAgICBpZiAodGhpcy5faWRsZS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5faWRsZS5zbGljZSgpLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgIHRoaXMuX3JlbW92ZShpdGVtLmNsaWVudClcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fY2xpZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5lbmRlZCA9IHRydWVcbiAgICAgICAgdGhpcy5fZW5kQ2FsbGJhY2soKVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gaWYgd2UgZG9uJ3QgaGF2ZSBhbnkgd2FpdGluZywgZG8gbm90aGluZ1xuICAgIGlmICghdGhpcy5fcGVuZGluZ1F1ZXVlLmxlbmd0aCkge1xuICAgICAgdGhpcy5sb2coJ25vIHF1ZXVlZCByZXF1ZXN0cycpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gaWYgd2UgZG9uJ3QgaGF2ZSBhbnkgaWRsZSBjbGllbnRzIGFuZCB3ZSBoYXZlIG5vIG1vcmUgcm9vbSBkbyBub3RoaW5nXG4gICAgaWYgKCF0aGlzLl9pZGxlLmxlbmd0aCAmJiB0aGlzLl9pc0Z1bGwoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmdJdGVtID0gdGhpcy5fcGVuZGluZ1F1ZXVlLnNoaWZ0KClcbiAgICBpZiAodGhpcy5faWRsZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGlkbGVJdGVtID0gdGhpcy5faWRsZS5wb3AoKVxuICAgICAgY2xlYXJUaW1lb3V0KGlkbGVJdGVtLnRpbWVvdXRJZClcbiAgICAgIGNvbnN0IGNsaWVudCA9IGlkbGVJdGVtLmNsaWVudFxuICAgICAgY2xpZW50LnJlZiAmJiBjbGllbnQucmVmKClcbiAgICAgIGNvbnN0IGlkbGVMaXN0ZW5lciA9IGlkbGVJdGVtLmlkbGVMaXN0ZW5lclxuXG4gICAgICByZXR1cm4gdGhpcy5fYWNxdWlyZUNsaWVudChjbGllbnQsIHBlbmRpbmdJdGVtLCBpZGxlTGlzdGVuZXIsIGZhbHNlKVxuICAgIH1cbiAgICBpZiAoIXRoaXMuX2lzRnVsbCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5uZXdDbGllbnQocGVuZGluZ0l0ZW0pXG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBjb25kaXRpb24nKVxuICB9XG5cbiAgX3JlbW92ZShjbGllbnQpIHtcbiAgICBjb25zdCByZW1vdmVkID0gcmVtb3ZlV2hlcmUodGhpcy5faWRsZSwgKGl0ZW0pID0+IGl0ZW0uY2xpZW50ID09PSBjbGllbnQpXG5cbiAgICBpZiAocmVtb3ZlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbGVhclRpbWVvdXQocmVtb3ZlZC50aW1lb3V0SWQpXG4gICAgfVxuXG4gICAgdGhpcy5fY2xpZW50cyA9IHRoaXMuX2NsaWVudHMuZmlsdGVyKChjKSA9PiBjICE9PSBjbGllbnQpXG4gICAgY2xpZW50LmVuZCgpXG4gICAgdGhpcy5lbWl0KCdyZW1vdmUnLCBjbGllbnQpXG4gIH1cblxuICBjb25uZWN0KGNiKSB7XG4gICAgaWYgKHRoaXMuZW5kaW5nKSB7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ0Nhbm5vdCB1c2UgYSBwb29sIGFmdGVyIGNhbGxpbmcgZW5kIG9uIHRoZSBwb29sJylcbiAgICAgIHJldHVybiBjYiA/IGNiKGVycikgOiB0aGlzLlByb21pc2UucmVqZWN0KGVycilcbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZSA9IHByb21pc2lmeSh0aGlzLlByb21pc2UsIGNiKVxuICAgIGNvbnN0IHJlc3VsdCA9IHJlc3BvbnNlLnJlc3VsdFxuXG4gICAgLy8gaWYgd2UgZG9uJ3QgaGF2ZSB0byBjb25uZWN0IGEgbmV3IGNsaWVudCwgZG9uJ3QgZG8gc29cbiAgICBpZiAodGhpcy5faXNGdWxsKCkgfHwgdGhpcy5faWRsZS5sZW5ndGgpIHtcbiAgICAgIC8vIGlmIHdlIGhhdmUgaWRsZSBjbGllbnRzIHNjaGVkdWxlIGEgcHVsc2UgaW1tZWRpYXRlbHlcbiAgICAgIGlmICh0aGlzLl9pZGxlLmxlbmd0aCkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHRoaXMuX3B1bHNlUXVldWUoKSlcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuY29ubmVjdGlvblRpbWVvdXRNaWxsaXMpIHtcbiAgICAgICAgdGhpcy5fcGVuZGluZ1F1ZXVlLnB1c2gobmV3IFBlbmRpbmdJdGVtKHJlc3BvbnNlLmNhbGxiYWNrKSlcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfVxuXG4gICAgICBjb25zdCBxdWV1ZUNhbGxiYWNrID0gKGVyciwgcmVzLCBkb25lKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aWQpXG4gICAgICAgIHJlc3BvbnNlLmNhbGxiYWNrKGVyciwgcmVzLCBkb25lKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBwZW5kaW5nSXRlbSA9IG5ldyBQZW5kaW5nSXRlbShxdWV1ZUNhbGxiYWNrKVxuXG4gICAgICAvLyBzZXQgY29ubmVjdGlvbiB0aW1lb3V0IG9uIGNoZWNraW5nIG91dCBhbiBleGlzdGluZyBjbGllbnRcbiAgICAgIGNvbnN0IHRpZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAvLyByZW1vdmUgdGhlIGNhbGxiYWNrIGZyb20gcGVuZGluZyB3YWl0ZXJzIGJlY2F1c2VcbiAgICAgICAgLy8gd2UncmUgZ29pbmcgdG8gY2FsbCBpdCB3aXRoIGEgdGltZW91dCBlcnJvclxuICAgICAgICByZW1vdmVXaGVyZSh0aGlzLl9wZW5kaW5nUXVldWUsIChpKSA9PiBpLmNhbGxiYWNrID09PSBxdWV1ZUNhbGxiYWNrKVxuICAgICAgICBwZW5kaW5nSXRlbS50aW1lZE91dCA9IHRydWVcbiAgICAgICAgcmVzcG9uc2UuY2FsbGJhY2sobmV3IEVycm9yKCd0aW1lb3V0IGV4Y2VlZGVkIHdoZW4gdHJ5aW5nIHRvIGNvbm5lY3QnKSlcbiAgICAgIH0sIHRoaXMub3B0aW9ucy5jb25uZWN0aW9uVGltZW91dE1pbGxpcylcblxuICAgICAgdGhpcy5fcGVuZGluZ1F1ZXVlLnB1c2gocGVuZGluZ0l0ZW0pXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuXG4gICAgdGhpcy5uZXdDbGllbnQobmV3IFBlbmRpbmdJdGVtKHJlc3BvbnNlLmNhbGxiYWNrKSlcblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIG5ld0NsaWVudChwZW5kaW5nSXRlbSkge1xuICAgIGNvbnN0IGNsaWVudCA9IG5ldyB0aGlzLkNsaWVudCh0aGlzLm9wdGlvbnMpXG4gICAgdGhpcy5fY2xpZW50cy5wdXNoKGNsaWVudClcbiAgICBjb25zdCBpZGxlTGlzdGVuZXIgPSBtYWtlSWRsZUxpc3RlbmVyKHRoaXMsIGNsaWVudClcblxuICAgIHRoaXMubG9nKCdjaGVja2luZyBjbGllbnQgdGltZW91dCcpXG5cbiAgICAvLyBjb25uZWN0aW9uIHRpbWVvdXQgbG9naWNcbiAgICBsZXQgdGlkXG4gICAgbGV0IHRpbWVvdXRIaXQgPSBmYWxzZVxuICAgIGlmICh0aGlzLm9wdGlvbnMuY29ubmVjdGlvblRpbWVvdXRNaWxsaXMpIHtcbiAgICAgIHRpZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmxvZygnZW5kaW5nIGNsaWVudCBkdWUgdG8gdGltZW91dCcpXG4gICAgICAgIHRpbWVvdXRIaXQgPSB0cnVlXG4gICAgICAgIC8vIGZvcmNlIGtpbGwgdGhlIG5vZGUgZHJpdmVyLCBhbmQgbGV0IGxpYnBxIGRvIGl0cyB0ZWFyZG93blxuICAgICAgICBjbGllbnQuY29ubmVjdGlvbiA/IGNsaWVudC5jb25uZWN0aW9uLnN0cmVhbS5kZXN0cm95KCkgOiBjbGllbnQuZW5kKClcbiAgICAgIH0sIHRoaXMub3B0aW9ucy5jb25uZWN0aW9uVGltZW91dE1pbGxpcylcbiAgICB9XG5cbiAgICB0aGlzLmxvZygnY29ubmVjdGluZyBuZXcgY2xpZW50JylcbiAgICBjbGllbnQuY29ubmVjdCgoZXJyKSA9PiB7XG4gICAgICBpZiAodGlkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aWQpXG4gICAgICB9XG4gICAgICBjbGllbnQub24oJ2Vycm9yJywgaWRsZUxpc3RlbmVyKVxuICAgICAgaWYgKGVycikge1xuICAgICAgICB0aGlzLmxvZygnY2xpZW50IGZhaWxlZCB0byBjb25uZWN0JywgZXJyKVxuICAgICAgICAvLyByZW1vdmUgdGhlIGRlYWQgY2xpZW50IGZyb20gb3VyIGxpc3Qgb2YgY2xpZW50c1xuICAgICAgICB0aGlzLl9jbGllbnRzID0gdGhpcy5fY2xpZW50cy5maWx0ZXIoKGMpID0+IGMgIT09IGNsaWVudClcbiAgICAgICAgaWYgKHRpbWVvdXRIaXQpIHtcbiAgICAgICAgICBlcnIubWVzc2FnZSA9ICdDb25uZWN0aW9uIHRlcm1pbmF0ZWQgZHVlIHRvIGNvbm5lY3Rpb24gdGltZW91dCdcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoaXMgY2xpZW50IHdvbuKAmXQgYmUgcmVsZWFzZWQsIHNvIG1vdmUgb24gaW1tZWRpYXRlbHlcbiAgICAgICAgdGhpcy5fcHVsc2VRdWV1ZSgpXG5cbiAgICAgICAgaWYgKCFwZW5kaW5nSXRlbS50aW1lZE91dCkge1xuICAgICAgICAgIHBlbmRpbmdJdGVtLmNhbGxiYWNrKGVyciwgdW5kZWZpbmVkLCBOT09QKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZygnbmV3IGNsaWVudCBjb25uZWN0ZWQnKVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubWF4TGlmZXRpbWVTZWNvbmRzICE9PSAwKSB7XG4gICAgICAgICAgY29uc3QgbWF4TGlmZXRpbWVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvZygnZW5kaW5nIGNsaWVudCBkdWUgdG8gZXhwaXJlZCBsaWZldGltZScpXG4gICAgICAgICAgICB0aGlzLl9leHBpcmVkLmFkZChjbGllbnQpXG4gICAgICAgICAgICBjb25zdCBpZGxlSW5kZXggPSB0aGlzLl9pZGxlLmZpbmRJbmRleCgoaWRsZUl0ZW0pID0+IGlkbGVJdGVtLmNsaWVudCA9PT0gY2xpZW50KVxuICAgICAgICAgICAgaWYgKGlkbGVJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgdGhpcy5fYWNxdWlyZUNsaWVudChcbiAgICAgICAgICAgICAgICBjbGllbnQsXG4gICAgICAgICAgICAgICAgbmV3IFBlbmRpbmdJdGVtKChlcnIsIGNsaWVudCwgY2xpZW50UmVsZWFzZSkgPT4gY2xpZW50UmVsZWFzZSgpKSxcbiAgICAgICAgICAgICAgICBpZGxlTGlzdGVuZXIsXG4gICAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRoaXMub3B0aW9ucy5tYXhMaWZldGltZVNlY29uZHMgKiAxMDAwKVxuXG4gICAgICAgICAgbWF4TGlmZXRpbWVUaW1lb3V0LnVucmVmKClcbiAgICAgICAgICBjbGllbnQub25jZSgnZW5kJywgKCkgPT4gY2xlYXJUaW1lb3V0KG1heExpZmV0aW1lVGltZW91dCkpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fYWNxdWlyZUNsaWVudChjbGllbnQsIHBlbmRpbmdJdGVtLCBpZGxlTGlzdGVuZXIsIHRydWUpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8vIGFjcXVpcmUgYSBjbGllbnQgZm9yIGEgcGVuZGluZyB3b3JrIGl0ZW1cbiAgX2FjcXVpcmVDbGllbnQoY2xpZW50LCBwZW5kaW5nSXRlbSwgaWRsZUxpc3RlbmVyLCBpc05ldykge1xuICAgIGlmIChpc05ldykge1xuICAgICAgdGhpcy5lbWl0KCdjb25uZWN0JywgY2xpZW50KVxuICAgIH1cblxuICAgIHRoaXMuZW1pdCgnYWNxdWlyZScsIGNsaWVudClcblxuICAgIGNsaWVudC5yZWxlYXNlID0gdGhpcy5fcmVsZWFzZU9uY2UoY2xpZW50LCBpZGxlTGlzdGVuZXIpXG5cbiAgICBjbGllbnQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgaWRsZUxpc3RlbmVyKVxuXG4gICAgaWYgKCFwZW5kaW5nSXRlbS50aW1lZE91dCkge1xuICAgICAgaWYgKGlzTmV3ICYmIHRoaXMub3B0aW9ucy52ZXJpZnkpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnZlcmlmeShjbGllbnQsIChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBjbGllbnQucmVsZWFzZShlcnIpXG4gICAgICAgICAgICByZXR1cm4gcGVuZGluZ0l0ZW0uY2FsbGJhY2soZXJyLCB1bmRlZmluZWQsIE5PT1ApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGVuZGluZ0l0ZW0uY2FsbGJhY2sodW5kZWZpbmVkLCBjbGllbnQsIGNsaWVudC5yZWxlYXNlKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVuZGluZ0l0ZW0uY2FsbGJhY2sodW5kZWZpbmVkLCBjbGllbnQsIGNsaWVudC5yZWxlYXNlKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNOZXcgJiYgdGhpcy5vcHRpb25zLnZlcmlmeSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMudmVyaWZ5KGNsaWVudCwgY2xpZW50LnJlbGVhc2UpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGllbnQucmVsZWFzZSgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgX3JlbGVhc2UgYW5kIHRocm93cyBpZiBjYWxsZWQgbW9yZSB0aGFuIG9uY2VcbiAgX3JlbGVhc2VPbmNlKGNsaWVudCwgaWRsZUxpc3RlbmVyKSB7XG4gICAgbGV0IHJlbGVhc2VkID0gZmFsc2VcblxuICAgIHJldHVybiAoZXJyKSA9PiB7XG4gICAgICBpZiAocmVsZWFzZWQpIHtcbiAgICAgICAgdGhyb3dPbkRvdWJsZVJlbGVhc2UoKVxuICAgICAgfVxuXG4gICAgICByZWxlYXNlZCA9IHRydWVcbiAgICAgIHRoaXMuX3JlbGVhc2UoY2xpZW50LCBpZGxlTGlzdGVuZXIsIGVycilcbiAgICB9XG4gIH1cblxuICAvLyByZWxlYXNlIGEgY2xpZW50IGJhY2sgdG8gdGhlIHBvbGwsIGluY2x1ZGUgYW4gZXJyb3JcbiAgLy8gdG8gcmVtb3ZlIGl0IGZyb20gdGhlIHBvb2xcbiAgX3JlbGVhc2UoY2xpZW50LCBpZGxlTGlzdGVuZXIsIGVycikge1xuICAgIGNsaWVudC5vbignZXJyb3InLCBpZGxlTGlzdGVuZXIpXG5cbiAgICBjbGllbnQuX3Bvb2xVc2VDb3VudCA9IChjbGllbnQuX3Bvb2xVc2VDb3VudCB8fCAwKSArIDFcblxuICAgIHRoaXMuZW1pdCgncmVsZWFzZScsIGVyciwgY2xpZW50KVxuXG4gICAgLy8gVE9ETyhibWMpOiBleHBvc2UgYSBwcm9wZXIsIHB1YmxpYyBpbnRlcmZhY2UgX3F1ZXJ5YWJsZSBhbmQgX2VuZGluZ1xuICAgIGlmIChlcnIgfHwgdGhpcy5lbmRpbmcgfHwgIWNsaWVudC5fcXVlcnlhYmxlIHx8IGNsaWVudC5fZW5kaW5nIHx8IGNsaWVudC5fcG9vbFVzZUNvdW50ID49IHRoaXMub3B0aW9ucy5tYXhVc2VzKSB7XG4gICAgICBpZiAoY2xpZW50Ll9wb29sVXNlQ291bnQgPj0gdGhpcy5vcHRpb25zLm1heFVzZXMpIHtcbiAgICAgICAgdGhpcy5sb2coJ3JlbW92ZSBleHBlbmRlZCBjbGllbnQnKVxuICAgICAgfVxuICAgICAgdGhpcy5fcmVtb3ZlKGNsaWVudClcbiAgICAgIHRoaXMuX3B1bHNlUXVldWUoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgaXNFeHBpcmVkID0gdGhpcy5fZXhwaXJlZC5oYXMoY2xpZW50KVxuICAgIGlmIChpc0V4cGlyZWQpIHtcbiAgICAgIHRoaXMubG9nKCdyZW1vdmUgZXhwaXJlZCBjbGllbnQnKVxuICAgICAgdGhpcy5fZXhwaXJlZC5kZWxldGUoY2xpZW50KVxuICAgICAgdGhpcy5fcmVtb3ZlKGNsaWVudClcbiAgICAgIHRoaXMuX3B1bHNlUXVldWUoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gaWRsZSB0aW1lb3V0XG4gICAgbGV0IHRpZFxuICAgIGlmICh0aGlzLm9wdGlvbnMuaWRsZVRpbWVvdXRNaWxsaXMpIHtcbiAgICAgIHRpZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmxvZygncmVtb3ZlIGlkbGUgY2xpZW50JylcbiAgICAgICAgdGhpcy5fcmVtb3ZlKGNsaWVudClcbiAgICAgIH0sIHRoaXMub3B0aW9ucy5pZGxlVGltZW91dE1pbGxpcylcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbGxvd0V4aXRPbklkbGUpIHtcbiAgICAgICAgLy8gYWxsb3cgTm9kZSB0byBleGl0IGlmIHRoaXMgaXMgYWxsIHRoYXQncyBsZWZ0XG4gICAgICAgIHRpZC51bnJlZigpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5hbGxvd0V4aXRPbklkbGUpIHtcbiAgICAgIGNsaWVudC51bnJlZigpXG4gICAgfVxuXG4gICAgdGhpcy5faWRsZS5wdXNoKG5ldyBJZGxlSXRlbShjbGllbnQsIGlkbGVMaXN0ZW5lciwgdGlkKSlcbiAgICB0aGlzLl9wdWxzZVF1ZXVlKClcbiAgfVxuXG4gIHF1ZXJ5KHRleHQsIHZhbHVlcywgY2IpIHtcbiAgICAvLyBndWFyZCBjbGF1c2UgYWdhaW5zdCBwYXNzaW5nIGEgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IHBhcmFtZXRlclxuICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBwcm9taXNpZnkodGhpcy5Qcm9taXNlLCB0ZXh0KVxuICAgICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmNhbGxiYWNrKG5ldyBFcnJvcignUGFzc2luZyBhIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIgdG8gcG9vbC5xdWVyeSBpcyBub3Qgc3VwcG9ydGVkJykpXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHJlc3BvbnNlLnJlc3VsdFxuICAgIH1cblxuICAgIC8vIGFsbG93IHBsYWluIHRleHQgcXVlcnkgd2l0aG91dCB2YWx1ZXNcbiAgICBpZiAodHlwZW9mIHZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSB2YWx1ZXNcbiAgICAgIHZhbHVlcyA9IHVuZGVmaW5lZFxuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IHByb21pc2lmeSh0aGlzLlByb21pc2UsIGNiKVxuICAgIGNiID0gcmVzcG9uc2UuY2FsbGJhY2tcblxuICAgIHRoaXMuY29ubmVjdCgoZXJyLCBjbGllbnQpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNiKGVycilcbiAgICAgIH1cblxuICAgICAgbGV0IGNsaWVudFJlbGVhc2VkID0gZmFsc2VcbiAgICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICAgIGlmIChjbGllbnRSZWxlYXNlZCkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGNsaWVudFJlbGVhc2VkID0gdHJ1ZVxuICAgICAgICBjbGllbnQucmVsZWFzZShlcnIpXG4gICAgICAgIGNiKGVycilcbiAgICAgIH1cblxuICAgICAgY2xpZW50Lm9uY2UoJ2Vycm9yJywgb25FcnJvcilcbiAgICAgIHRoaXMubG9nKCdkaXNwYXRjaGluZyBxdWVyeScpXG4gICAgICB0cnkge1xuICAgICAgICBjbGllbnQucXVlcnkodGV4dCwgdmFsdWVzLCAoZXJyLCByZXMpID0+IHtcbiAgICAgICAgICB0aGlzLmxvZygncXVlcnkgZGlzcGF0Y2hlZCcpXG4gICAgICAgICAgY2xpZW50LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpXG4gICAgICAgICAgaWYgKGNsaWVudFJlbGVhc2VkKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgY2xpZW50UmVsZWFzZWQgPSB0cnVlXG4gICAgICAgICAgY2xpZW50LnJlbGVhc2UoZXJyKVxuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjYih1bmRlZmluZWQsIHJlcylcbiAgICAgICAgfSlcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjbGllbnQucmVsZWFzZShlcnIpXG4gICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gcmVzcG9uc2UucmVzdWx0XG4gIH1cblxuICBlbmQoY2IpIHtcbiAgICB0aGlzLmxvZygnZW5kaW5nJylcbiAgICBpZiAodGhpcy5lbmRpbmcpIHtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignQ2FsbGVkIGVuZCBvbiBwb29sIG1vcmUgdGhhbiBvbmNlJylcbiAgICAgIHJldHVybiBjYiA/IGNiKGVycikgOiB0aGlzLlByb21pc2UucmVqZWN0KGVycilcbiAgICB9XG4gICAgdGhpcy5lbmRpbmcgPSB0cnVlXG4gICAgY29uc3QgcHJvbWlzZWQgPSBwcm9taXNpZnkodGhpcy5Qcm9taXNlLCBjYilcbiAgICB0aGlzLl9lbmRDYWxsYmFjayA9IHByb21pc2VkLmNhbGxiYWNrXG4gICAgdGhpcy5fcHVsc2VRdWV1ZSgpXG4gICAgcmV0dXJuIHByb21pc2VkLnJlc3VsdFxuICB9XG5cbiAgZ2V0IHdhaXRpbmdDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGVuZGluZ1F1ZXVlLmxlbmd0aFxuICB9XG5cbiAgZ2V0IGlkbGVDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5faWRsZS5sZW5ndGhcbiAgfVxuXG4gIGdldCBleHBpcmVkQ291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudHMucmVkdWNlKChhY2MsIGNsaWVudCkgPT4gYWNjICsgKHRoaXMuX2V4cGlyZWQuaGFzKGNsaWVudCkgPyAxIDogMCksIDApXG4gIH1cblxuICBnZXQgdG90YWxDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50cy5sZW5ndGhcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBQb29sXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/pg-pool@3.7.0_pg@8.11.3/node_modules/pg-pool/index.js\n");

/***/ })

};
;
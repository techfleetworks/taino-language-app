"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lexical+code@0.20.0";
exports.ids = ["vendor-chunks/@lexical+code@0.20.0"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/@lexical+code@0.20.0/node_modules/@lexical/code/LexicalCode.dev.mjs":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@lexical+code@0.20.0/node_modules/@lexical/code/LexicalCode.dev.mjs ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $createCodeHighlightNode: () => (/* binding */ $createCodeHighlightNode),\n/* harmony export */   $createCodeNode: () => (/* binding */ $createCodeNode),\n/* harmony export */   $isCodeHighlightNode: () => (/* binding */ $isCodeHighlightNode),\n/* harmony export */   $isCodeNode: () => (/* binding */ $isCodeNode),\n/* harmony export */   CODE_LANGUAGE_FRIENDLY_NAME_MAP: () => (/* binding */ CODE_LANGUAGE_FRIENDLY_NAME_MAP),\n/* harmony export */   CODE_LANGUAGE_MAP: () => (/* binding */ CODE_LANGUAGE_MAP),\n/* harmony export */   CodeHighlightNode: () => (/* binding */ CodeHighlightNode),\n/* harmony export */   CodeNode: () => (/* binding */ CodeNode),\n/* harmony export */   DEFAULT_CODE_LANGUAGE: () => (/* binding */ DEFAULT_CODE_LANGUAGE),\n/* harmony export */   PrismTokenizer: () => (/* binding */ PrismTokenizer),\n/* harmony export */   getCodeLanguages: () => (/* binding */ getCodeLanguages),\n/* harmony export */   getDefaultCodeLanguage: () => (/* binding */ getDefaultCodeLanguage),\n/* harmony export */   getEndOfCodeInLine: () => (/* binding */ getEndOfCodeInLine),\n/* harmony export */   getFirstCodeNodeOfLine: () => (/* binding */ getFirstCodeNodeOfLine),\n/* harmony export */   getLanguageFriendlyName: () => (/* binding */ getLanguageFriendlyName),\n/* harmony export */   getLastCodeNodeOfLine: () => (/* binding */ getLastCodeNodeOfLine),\n/* harmony export */   getStartOfCodeInLine: () => (/* binding */ getStartOfCodeInLine),\n/* harmony export */   normalizeCodeLang: () => (/* binding */ normalizeCodeLang),\n/* harmony export */   registerCodeHighlighting: () => (/* binding */ registerCodeHighlighting)\n/* harmony export */ });\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! lexical */ \"(rsc)/./node_modules/.pnpm/lexical@0.20.0/node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @lexical/utils */ \"(rsc)/./node_modules/.pnpm/@lexical+utils@0.20.0/node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prismjs */ \"(rsc)/./node_modules/.pnpm/prismjs@1.29.0/node_modules/prismjs/prism.js\");\n/* harmony import */ var prismjs_components_prism_clike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prismjs/components/prism-clike.js */ \"(rsc)/./node_modules/.pnpm/prismjs@1.29.0/node_modules/prismjs/components/prism-clike.js\");\n/* harmony import */ var prismjs_components_prism_javascript_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prismjs/components/prism-javascript.js */ \"(rsc)/./node_modules/.pnpm/prismjs@1.29.0/node_modules/prismjs/components/prism-javascript.js\");\n/* harmony import */ var prismjs_components_prism_markup_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prismjs/components/prism-markup.js */ \"(rsc)/./node_modules/.pnpm/prismjs@1.29.0/node_modules/prismjs/components/prism-markup.js\");\n/* harmony import */ var prismjs_components_prism_markdown_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! prismjs/components/prism-markdown.js */ \"(rsc)/./node_modules/.pnpm/prismjs@1.29.0/node_modules/prismjs/components/prism-markdown.js\");\n/* harmony import */ var prismjs_components_prism_c_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! prismjs/components/prism-c.js */ \"(rsc)/./node_modules/.pnpm/prismjs@1.29.0/node_modules/prismjs/components/prism-c.js\");\n/* harmony import */ var prismjs_components_prism_css_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! prismjs/components/prism-css.js */ \"(rsc)/./node_modules/.pnpm/prismjs@1.29.0/node_modules/prismjs/components/prism-css.js\");\n/* harmony import */ var prismjs_components_prism_objectivec_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! prismjs/components/prism-objectivec.js */ \"(rsc)/./node_modules/.pnpm/prismjs@1.29.0/node_modules/prismjs/components/prism-objectivec.js\");\n/* harmony import */ var prismjs_components_prism_sql_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! prismjs/components/prism-sql.js */ \"(rsc)/./node_modules/.pnpm/prismjs@1.29.0/node_modules/prismjs/components/prism-sql.js\");\n/* harmony import */ var prismjs_components_prism_powershell_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! prismjs/components/prism-powershell.js */ \"(rsc)/./node_modules/.pnpm/prismjs@1.29.0/node_modules/prismjs/components/prism-powershell.js\");\n/* harmony import */ var prismjs_components_prism_python_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! prismjs/components/prism-python.js */ \"(rsc)/./node_modules/.pnpm/prismjs@1.29.0/node_modules/prismjs/components/prism-python.js\");\n/* harmony import */ var prismjs_components_prism_rust_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! prismjs/components/prism-rust.js */ \"(rsc)/./node_modules/.pnpm/prismjs@1.29.0/node_modules/prismjs/components/prism-rust.js\");\n/* harmony import */ var prismjs_components_prism_swift_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! prismjs/components/prism-swift.js */ \"(rsc)/./node_modules/.pnpm/prismjs@1.29.0/node_modules/prismjs/components/prism-swift.js\");\n/* harmony import */ var prismjs_components_prism_typescript_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! prismjs/components/prism-typescript.js */ \"(rsc)/./node_modules/.pnpm/prismjs@1.29.0/node_modules/prismjs/components/prism-typescript.js\");\n/* harmony import */ var prismjs_components_prism_java_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! prismjs/components/prism-java.js */ \"(rsc)/./node_modules/.pnpm/prismjs@1.29.0/node_modules/prismjs/components/prism-java.js\");\n/* harmony import */ var prismjs_components_prism_cpp_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! prismjs/components/prism-cpp.js */ \"(rsc)/./node_modules/.pnpm/prismjs@1.29.0/node_modules/prismjs/components/prism-cpp.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// invariant(condition, message) will refine types based on \"condition\", and\n// if \"condition\" is false will throw an error. This function is special-cased\n// in flow itself, so we can't name it anything else.\nfunction invariant(cond, message, ...args) {\n  if (cond) {\n    return;\n  }\n  throw new Error('Internal Lexical error: invariant() is meant to be replaced at compile ' + 'time. There is no runtime version. Error: ' + message);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst Prism = globalThis.Prism || window.Prism;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst isLanguageSupportedByPrism = language => {\n  try {\n    // eslint-disable-next-line no-prototype-builtins\n    return language ? Prism.languages.hasOwnProperty(language) : false;\n  } catch (_unused) {\n    return false;\n  }\n};\nfunction hasChildDOMNodeTag(node, tagName) {\n  for (const child of node.childNodes) {\n    if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.isHTMLElement)(child) && child.tagName === tagName) {\n      return true;\n    }\n    hasChildDOMNodeTag(child, tagName);\n  }\n  return false;\n}\nconst LANGUAGE_DATA_ATTRIBUTE = 'data-language';\nconst HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE = 'data-highlight-language';\n\n/** @noInheritDoc */\nclass CodeNode extends _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'code';\n  }\n  static clone(node) {\n    return new CodeNode(node.__language, node.__key);\n  }\n  constructor(language, key) {\n    super(key);\n    this.__language = language;\n    this.__isSyntaxHighlightSupported = isLanguageSupportedByPrism(language);\n  }\n\n  // View\n  createDOM(config) {\n    const element = document.createElement('code');\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_17__.addClassNamesToElement)(element, config.theme.code);\n    element.setAttribute('spellcheck', 'false');\n    const language = this.getLanguage();\n    if (language) {\n      element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n      if (this.getIsSyntaxHighlightSupported()) {\n        element.setAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE, language);\n      }\n    }\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const language = this.__language;\n    const prevLanguage = prevNode.__language;\n    if (language) {\n      if (language !== prevLanguage) {\n        dom.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n        if (this.__isSyntaxHighlightSupported) {\n          dom.setAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE, language);\n        }\n      }\n    } else if (prevLanguage) {\n      dom.removeAttribute(LANGUAGE_DATA_ATTRIBUTE);\n      if (prevNode.__isSyntaxHighlightSupported) {\n        dom.removeAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE);\n      }\n    }\n    return false;\n  }\n  exportDOM(editor) {\n    const element = document.createElement('pre');\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_17__.addClassNamesToElement)(element, editor._config.theme.code);\n    element.setAttribute('spellcheck', 'false');\n    const language = this.getLanguage();\n    if (language) {\n      element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n      if (this.getIsSyntaxHighlightSupported()) {\n        element.setAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE, language);\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importDOM() {\n    return {\n      // Typically <pre> is used for code blocks, and <code> for inline code styles\n      // but if it's a multi line <code> we'll create a block. Pass through to\n      // inline format handled by TextNode otherwise.\n      code: node => {\n        const isMultiLine = node.textContent != null && (/\\r?\\n/.test(node.textContent) || hasChildDOMNodeTag(node, 'BR'));\n        return isMultiLine ? {\n          conversion: $convertPreElement,\n          priority: 1\n        } : null;\n      },\n      div: () => ({\n        conversion: $convertDivElement,\n        priority: 1\n      }),\n      pre: () => ({\n        conversion: $convertPreElement,\n        priority: 0\n      }),\n      table: node => {\n        const table = node;\n        // domNode is a <table> since we matched it by nodeName\n        if (isGitHubCodeTable(table)) {\n          return {\n            conversion: $convertTableElement,\n            priority: 3\n          };\n        }\n        return null;\n      },\n      td: node => {\n        // element is a <td> since we matched it by nodeName\n        const td = node;\n        const table = td.closest('table');\n        if (isGitHubCodeCell(td) || table && isGitHubCodeTable(table)) {\n          // Return a no-op if it's a table cell in a code table, but not a code line.\n          // Otherwise it'll fall back to the T\n          return {\n            conversion: convertCodeNoop,\n            priority: 3\n          };\n        }\n        return null;\n      },\n      tr: node => {\n        // element is a <tr> since we matched it by nodeName\n        const tr = node;\n        const table = tr.closest('table');\n        if (table && isGitHubCodeTable(table)) {\n          return {\n            conversion: convertCodeNoop,\n            priority: 3\n          };\n        }\n        return null;\n      }\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createCodeNode(serializedNode.language);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      language: this.getLanguage(),\n      type: 'code',\n      version: 1\n    };\n  }\n\n  // Mutation\n  insertNewAfter(selection, restoreSelection = true) {\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    if (childrenLength >= 2 && children[childrenLength - 1].getTextContent() === '\\n' && children[childrenLength - 2].getTextContent() === '\\n' && selection.isCollapsed() && selection.anchor.key === this.__key && selection.anchor.offset === childrenLength) {\n      children[childrenLength - 1].remove();\n      children[childrenLength - 2].remove();\n      const newElement = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createParagraphNode)();\n      this.insertAfter(newElement, restoreSelection);\n      return newElement;\n    }\n\n    // If the selection is within the codeblock, find all leading tabs and\n    // spaces of the current line. Create a new line that has all those\n    // tabs and spaces, such that leading indentation is preserved.\n    const {\n      anchor,\n      focus\n    } = selection;\n    const firstPoint = anchor.isBefore(focus) ? anchor : focus;\n    const firstSelectionNode = firstPoint.getNode();\n    if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTextNode)(firstSelectionNode)) {\n      let node = getFirstCodeNodeOfLine(firstSelectionNode);\n      const insertNodes = [];\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(node)) {\n          insertNodes.push((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createTabNode)());\n          node = node.getNextSibling();\n        } else if ($isCodeHighlightNode(node)) {\n          let spaces = 0;\n          const text = node.getTextContent();\n          const textSize = node.getTextContentSize();\n          while (spaces < textSize && text[spaces] === ' ') {\n            spaces++;\n          }\n          if (spaces !== 0) {\n            insertNodes.push($createCodeHighlightNode(' '.repeat(spaces)));\n          }\n          if (spaces !== textSize) {\n            break;\n          }\n          node = node.getNextSibling();\n        } else {\n          break;\n        }\n      }\n      const split = firstSelectionNode.splitText(anchor.offset)[0];\n      const x = anchor.offset === 0 ? 0 : 1;\n      const index = split.getIndexWithinParent() + x;\n      const codeNode = firstSelectionNode.getParentOrThrow();\n      const nodesToInsert = [(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createLineBreakNode)(), ...insertNodes];\n      codeNode.splice(index, 0, nodesToInsert);\n      const last = insertNodes[insertNodes.length - 1];\n      if (last) {\n        last.select();\n      } else if (anchor.offset === 0) {\n        split.selectPrevious();\n      } else {\n        split.getNextSibling().selectNext(0, 0);\n      }\n    }\n    if ($isCodeNode(firstSelectionNode)) {\n      const {\n        offset\n      } = selection.anchor;\n      firstSelectionNode.splice(offset, 0, [(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createLineBreakNode)()]);\n      firstSelectionNode.select(offset + 1, offset + 1);\n    }\n    return null;\n  }\n  canIndent() {\n    return false;\n  }\n  collapseAtStart() {\n    const paragraph = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createParagraphNode)();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n  setLanguage(language) {\n    const writable = this.getWritable();\n    writable.__language = language;\n    writable.__isSyntaxHighlightSupported = isLanguageSupportedByPrism(language);\n  }\n  getLanguage() {\n    return this.getLatest().__language;\n  }\n  getIsSyntaxHighlightSupported() {\n    return this.getLatest().__isSyntaxHighlightSupported;\n  }\n}\nfunction $createCodeNode(language) {\n  return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$applyNodeReplacement)(new CodeNode(language));\n}\nfunction $isCodeNode(node) {\n  return node instanceof CodeNode;\n}\nfunction $convertPreElement(domNode) {\n  const language = domNode.getAttribute(LANGUAGE_DATA_ATTRIBUTE);\n  return {\n    node: $createCodeNode(language)\n  };\n}\nfunction $convertDivElement(domNode) {\n  // domNode is a <div> since we matched it by nodeName\n  const div = domNode;\n  const isCode = isCodeElement(div);\n  if (!isCode && !isCodeChildElement(div)) {\n    return {\n      node: null\n    };\n  }\n  return {\n    node: isCode ? $createCodeNode() : null\n  };\n}\nfunction $convertTableElement() {\n  return {\n    node: $createCodeNode()\n  };\n}\nfunction convertCodeNoop() {\n  return {\n    node: null\n  };\n}\nfunction isCodeElement(div) {\n  return div.style.fontFamily.match('monospace') !== null;\n}\nfunction isCodeChildElement(node) {\n  let parent = node.parentElement;\n  while (parent !== null) {\n    if (isCodeElement(parent)) {\n      return true;\n    }\n    parent = parent.parentElement;\n  }\n  return false;\n}\nfunction isGitHubCodeCell(cell) {\n  return cell.classList.contains('js-file-line');\n}\nfunction isGitHubCodeTable(table) {\n  return table.classList.contains('js-file-line-container');\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst DEFAULT_CODE_LANGUAGE = 'javascript';\nconst CODE_LANGUAGE_FRIENDLY_NAME_MAP = {\n  c: 'C',\n  clike: 'C-like',\n  cpp: 'C++',\n  css: 'CSS',\n  html: 'HTML',\n  java: 'Java',\n  js: 'JavaScript',\n  markdown: 'Markdown',\n  objc: 'Objective-C',\n  plain: 'Plain Text',\n  powershell: 'PowerShell',\n  py: 'Python',\n  rust: 'Rust',\n  sql: 'SQL',\n  swift: 'Swift',\n  typescript: 'TypeScript',\n  xml: 'XML'\n};\nconst CODE_LANGUAGE_MAP = {\n  cpp: 'cpp',\n  java: 'java',\n  javascript: 'js',\n  md: 'markdown',\n  plaintext: 'plain',\n  python: 'py',\n  text: 'plain',\n  ts: 'typescript'\n};\nfunction normalizeCodeLang(lang) {\n  return CODE_LANGUAGE_MAP[lang] || lang;\n}\nfunction getLanguageFriendlyName(lang) {\n  const _lang = normalizeCodeLang(lang);\n  return CODE_LANGUAGE_FRIENDLY_NAME_MAP[_lang] || _lang;\n}\nconst getDefaultCodeLanguage = () => DEFAULT_CODE_LANGUAGE;\nconst getCodeLanguages = () => Object.keys(Prism.languages).filter(\n// Prism has several language helpers mixed into languages object\n// so filtering them out here to get langs list\nlanguage => typeof Prism.languages[language] !== 'function').sort();\n\n/** @noInheritDoc */\nclass CodeHighlightNode extends _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.TextNode {\n  /** @internal */\n\n  constructor(text, highlightType, key) {\n    super(text, key);\n    this.__highlightType = highlightType;\n  }\n  static getType() {\n    return 'code-highlight';\n  }\n  static clone(node) {\n    return new CodeHighlightNode(node.__text, node.__highlightType || undefined, node.__key);\n  }\n  getHighlightType() {\n    const self = this.getLatest();\n    return self.__highlightType;\n  }\n  canHaveFormat() {\n    return false;\n  }\n  createDOM(config) {\n    const element = super.createDOM(config);\n    const className = getHighlightThemeClass(config.theme, this.__highlightType);\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_17__.addClassNamesToElement)(element, className);\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const update = super.updateDOM(prevNode, dom, config);\n    const prevClassName = getHighlightThemeClass(config.theme, prevNode.__highlightType);\n    const nextClassName = getHighlightThemeClass(config.theme, this.__highlightType);\n    if (prevClassName !== nextClassName) {\n      if (prevClassName) {\n        (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_17__.removeClassNamesFromElement)(dom, prevClassName);\n      }\n      if (nextClassName) {\n        (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_17__.addClassNamesToElement)(dom, nextClassName);\n      }\n    }\n    return update;\n  }\n  static importJSON(serializedNode) {\n    const node = $createCodeHighlightNode(serializedNode.text, serializedNode.highlightType);\n    node.setFormat(serializedNode.format);\n    node.setDetail(serializedNode.detail);\n    node.setMode(serializedNode.mode);\n    node.setStyle(serializedNode.style);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      highlightType: this.getHighlightType(),\n      type: 'code-highlight',\n      version: 1\n    };\n  }\n\n  // Prevent formatting (bold, underline, etc)\n  setFormat(format) {\n    return this;\n  }\n  isParentRequired() {\n    return true;\n  }\n  createParentElementNode() {\n    return $createCodeNode();\n  }\n}\nfunction getHighlightThemeClass(theme, highlightType) {\n  return highlightType && theme && theme.codeHighlight && theme.codeHighlight[highlightType];\n}\nfunction $createCodeHighlightNode(text, highlightType) {\n  return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$applyNodeReplacement)(new CodeHighlightNode(text, highlightType));\n}\nfunction $isCodeHighlightNode(node) {\n  return node instanceof CodeHighlightNode;\n}\nfunction getFirstCodeNodeOfLine(anchor) {\n  let previousNode = anchor;\n  let node = anchor;\n  while ($isCodeHighlightNode(node) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(node)) {\n    previousNode = node;\n    node = node.getPreviousSibling();\n  }\n  return previousNode;\n}\nfunction getLastCodeNodeOfLine(anchor) {\n  let nextNode = anchor;\n  let node = anchor;\n  while ($isCodeHighlightNode(node) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(node)) {\n    nextNode = node;\n    node = node.getNextSibling();\n  }\n  return nextNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst PrismTokenizer = {\n  defaultLanguage: DEFAULT_CODE_LANGUAGE,\n  tokenize(code, language) {\n    return Prism.tokenize(code, Prism.languages[language || ''] || Prism.languages[this.defaultLanguage]);\n  }\n};\nfunction getStartOfCodeInLine(anchor, offset) {\n  let last = null;\n  let lastNonBlank = null;\n  let node = anchor;\n  let nodeOffset = offset;\n  let nodeTextContent = anchor.getTextContent();\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    if (nodeOffset === 0) {\n      node = node.getPreviousSibling();\n      if (node === null) {\n        break;\n      }\n      if (!($isCodeHighlightNode(node) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(node) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(node))) {\n        throw Error(`Expected a valid Code Node: CodeHighlightNode, TabNode, LineBreakNode`);\n      }\n      if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(node)) {\n        last = {\n          node,\n          offset: 1\n        };\n        break;\n      }\n      nodeOffset = Math.max(0, node.getTextContentSize() - 1);\n      nodeTextContent = node.getTextContent();\n    } else {\n      nodeOffset--;\n    }\n    const character = nodeTextContent[nodeOffset];\n    if ($isCodeHighlightNode(node) && character !== ' ') {\n      lastNonBlank = {\n        node,\n        offset: nodeOffset\n      };\n    }\n  }\n  // lastNonBlank !== null: anchor in the middle of code; move to line beginning\n  if (lastNonBlank !== null) {\n    return lastNonBlank;\n  }\n  // Spaces, tabs or nothing ahead of anchor\n  let codeCharacterAtAnchorOffset = null;\n  if (offset < anchor.getTextContentSize()) {\n    if ($isCodeHighlightNode(anchor)) {\n      codeCharacterAtAnchorOffset = anchor.getTextContent()[offset];\n    }\n  } else {\n    const nextSibling = anchor.getNextSibling();\n    if ($isCodeHighlightNode(nextSibling)) {\n      codeCharacterAtAnchorOffset = nextSibling.getTextContent()[0];\n    }\n  }\n  if (codeCharacterAtAnchorOffset !== null && codeCharacterAtAnchorOffset !== ' ') {\n    // Borderline whitespace and code, move to line beginning\n    return last;\n  } else {\n    const nextNonBlank = findNextNonBlankInLine(anchor, offset);\n    if (nextNonBlank !== null) {\n      return nextNonBlank;\n    } else {\n      return last;\n    }\n  }\n}\nfunction findNextNonBlankInLine(anchor, offset) {\n  let node = anchor;\n  let nodeOffset = offset;\n  let nodeTextContent = anchor.getTextContent();\n  let nodeTextContentSize = anchor.getTextContentSize();\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    if (!$isCodeHighlightNode(node) || nodeOffset === nodeTextContentSize) {\n      node = node.getNextSibling();\n      if (node === null || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(node)) {\n        return null;\n      }\n      if ($isCodeHighlightNode(node)) {\n        nodeOffset = 0;\n        nodeTextContent = node.getTextContent();\n        nodeTextContentSize = node.getTextContentSize();\n      }\n    }\n    if ($isCodeHighlightNode(node)) {\n      if (nodeTextContent[nodeOffset] !== ' ') {\n        return {\n          node,\n          offset: nodeOffset\n        };\n      }\n      nodeOffset++;\n    }\n  }\n}\nfunction getEndOfCodeInLine(anchor) {\n  const lastNode = getLastCodeNodeOfLine(anchor);\n  if (!!(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(lastNode)) {\n    throw Error(`Unexpected lineBreakNode in getEndOfCodeInLine`);\n  }\n  return lastNode;\n}\nfunction $textNodeTransform(node, editor, tokenizer) {\n  // Since CodeNode has flat children structure we only need to check\n  // if node's parent is a code node and run highlighting if so\n  const parentNode = node.getParent();\n  if ($isCodeNode(parentNode)) {\n    codeNodeTransform(parentNode, editor, tokenizer);\n  } else if ($isCodeHighlightNode(node)) {\n    // When code block converted into paragraph or other element\n    // code highlight nodes converted back to normal text\n    node.replace((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createTextNode)(node.__text));\n  }\n}\nfunction updateCodeGutter(node, editor) {\n  const codeElement = editor.getElementByKey(node.getKey());\n  if (codeElement === null) {\n    return;\n  }\n  const children = node.getChildren();\n  const childrenLength = children.length;\n  // @ts-ignore: internal field\n  if (childrenLength === codeElement.__cachedChildrenLength) {\n    // Avoid updating the attribute if the children length hasn't changed.\n    return;\n  }\n  // @ts-ignore:: internal field\n  codeElement.__cachedChildrenLength = childrenLength;\n  let gutter = '1';\n  let count = 1;\n  for (let i = 0; i < childrenLength; i++) {\n    if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(children[i])) {\n      gutter += '\\n' + ++count;\n    }\n  }\n  codeElement.setAttribute('data-gutter', gutter);\n}\n\n// Using `skipTransforms` to prevent extra transforms since reformatting the code\n// will not affect code block content itself.\n//\n// Using extra cache (`nodesCurrentlyHighlighting`) since both CodeNode and CodeHighlightNode\n// transforms might be called at the same time (e.g. new CodeHighlight node inserted) and\n// in both cases we'll rerun whole reformatting over CodeNode, which is redundant.\n// Especially when pasting code into CodeBlock.\n\nconst nodesCurrentlyHighlighting = new Set();\nfunction codeNodeTransform(node, editor, tokenizer) {\n  const nodeKey = node.getKey();\n  if (nodesCurrentlyHighlighting.has(nodeKey)) {\n    return;\n  }\n  nodesCurrentlyHighlighting.add(nodeKey);\n\n  // When new code block inserted it might not have language selected\n  if (node.getLanguage() === undefined) {\n    node.setLanguage(tokenizer.defaultLanguage);\n  }\n\n  // Using nested update call to pass `skipTransforms` since we don't want\n  // each individual codehighlight node to be transformed again as it's already\n  // in its final state\n  editor.update(() => {\n    $updateAndRetainSelection(nodeKey, () => {\n      const currentNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$getNodeByKey)(nodeKey);\n      if (!$isCodeNode(currentNode) || !currentNode.isAttached()) {\n        return false;\n      }\n      const code = currentNode.getTextContent();\n      const tokens = tokenizer.tokenize(code, currentNode.getLanguage() || tokenizer.defaultLanguage);\n      const highlightNodes = $getHighlightNodes(tokens);\n      const diffRange = getDiffRange(currentNode.getChildren(), highlightNodes);\n      const {\n        from,\n        to,\n        nodesForReplacement\n      } = diffRange;\n      if (from !== to || nodesForReplacement.length) {\n        node.splice(from, to - from, nodesForReplacement);\n        return true;\n      }\n      return false;\n    });\n  }, {\n    onUpdate: () => {\n      nodesCurrentlyHighlighting.delete(nodeKey);\n    },\n    skipTransforms: true\n  });\n}\nfunction $getHighlightNodes(tokens, type) {\n  const nodes = [];\n  for (const token of tokens) {\n    if (typeof token === 'string') {\n      const partials = token.split(/(\\n|\\t)/);\n      const partialsLength = partials.length;\n      for (let i = 0; i < partialsLength; i++) {\n        const part = partials[i];\n        if (part === '\\n' || part === '\\r\\n') {\n          nodes.push((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createLineBreakNode)());\n        } else if (part === '\\t') {\n          nodes.push((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createTabNode)());\n        } else if (part.length > 0) {\n          nodes.push($createCodeHighlightNode(part, type));\n        }\n      }\n    } else {\n      const {\n        content\n      } = token;\n      if (typeof content === 'string') {\n        nodes.push(...$getHighlightNodes([content], token.type));\n      } else if (Array.isArray(content)) {\n        nodes.push(...$getHighlightNodes(content, token.type));\n      }\n    }\n  }\n  return nodes;\n}\n\n// Wrapping update function into selection retainer, that tries to keep cursor at the same\n// position as before.\nfunction $updateAndRetainSelection(nodeKey, updateFn) {\n  const node = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$getNodeByKey)(nodeKey);\n  if (!$isCodeNode(node) || !node.isAttached()) {\n    return;\n  }\n  const selection = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$getSelection)();\n  // If it's not range selection (or null selection) there's no need to change it,\n  // but we can still run highlighting logic\n  if (!(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isRangeSelection)(selection)) {\n    updateFn();\n    return;\n  }\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const isNewLineAnchor = anchor.type === 'element' && (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(node.getChildAtIndex(anchor.offset - 1));\n  let textOffset = 0;\n\n  // Calculating previous text offset (all text node prior to anchor + anchor own text offset)\n  if (!isNewLineAnchor) {\n    const anchorNode = anchor.getNode();\n    textOffset = anchorOffset + anchorNode.getPreviousSiblings().reduce((offset, _node) => {\n      return offset + _node.getTextContentSize();\n    }, 0);\n  }\n  const hasChanges = updateFn();\n  if (!hasChanges) {\n    return;\n  }\n\n  // Non-text anchors only happen for line breaks, otherwise\n  // selection will be within text node (code highlight node)\n  if (isNewLineAnchor) {\n    anchor.getNode().select(anchorOffset, anchorOffset);\n    return;\n  }\n\n  // If it was non-element anchor then we walk through child nodes\n  // and looking for a position of original text offset\n  node.getChildren().some(_node => {\n    const isText = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTextNode)(_node);\n    if (isText || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(_node)) {\n      const textContentSize = _node.getTextContentSize();\n      if (isText && textContentSize >= textOffset) {\n        _node.select(textOffset, textOffset);\n        return true;\n      }\n      textOffset -= textContentSize;\n    }\n    return false;\n  });\n}\n\n// Finds minimal diff range between two nodes lists. It returns from/to range boundaries of prevNodes\n// that needs to be replaced with `nodes` (subset of nextNodes) to make prevNodes equal to nextNodes.\nfunction getDiffRange(prevNodes, nextNodes) {\n  let leadingMatch = 0;\n  while (leadingMatch < prevNodes.length) {\n    if (!isEqual(prevNodes[leadingMatch], nextNodes[leadingMatch])) {\n      break;\n    }\n    leadingMatch++;\n  }\n  const prevNodesLength = prevNodes.length;\n  const nextNodesLength = nextNodes.length;\n  const maxTrailingMatch = Math.min(prevNodesLength, nextNodesLength) - leadingMatch;\n  let trailingMatch = 0;\n  while (trailingMatch < maxTrailingMatch) {\n    trailingMatch++;\n    if (!isEqual(prevNodes[prevNodesLength - trailingMatch], nextNodes[nextNodesLength - trailingMatch])) {\n      trailingMatch--;\n      break;\n    }\n  }\n  const from = leadingMatch;\n  const to = prevNodesLength - trailingMatch;\n  const nodesForReplacement = nextNodes.slice(leadingMatch, nextNodesLength - trailingMatch);\n  return {\n    from,\n    nodesForReplacement,\n    to\n  };\n}\nfunction isEqual(nodeA, nodeB) {\n  // Only checking for code higlight nodes, tabs and linebreaks. If it's regular text node\n  // returning false so that it's transformed into code highlight node\n  return $isCodeHighlightNode(nodeA) && $isCodeHighlightNode(nodeB) && nodeA.__text === nodeB.__text && nodeA.__highlightType === nodeB.__highlightType || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(nodeA) && (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(nodeB) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(nodeA) && (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(nodeB);\n}\nfunction $isSelectionInCode(selection) {\n  if (!(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isRangeSelection)(selection)) {\n    return false;\n  }\n  const anchorNode = selection.anchor.getNode();\n  const focusNode = selection.focus.getNode();\n  if (anchorNode.is(focusNode) && $isCodeNode(anchorNode)) {\n    return true;\n  }\n  const anchorParent = anchorNode.getParent();\n  return $isCodeNode(anchorParent) && anchorParent.is(focusNode.getParent());\n}\nfunction $getCodeLines(selection) {\n  const nodes = selection.getNodes();\n  const lines = [[]];\n  if (nodes.length === 1 && $isCodeNode(nodes[0])) {\n    return lines;\n  }\n  let lastLine = lines[0];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!($isCodeHighlightNode(node) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(node) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(node))) {\n      throw Error(`Expected selection to be inside CodeBlock and consisting of CodeHighlightNode, TabNode and LineBreakNode`);\n    }\n    if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(node)) {\n      if (i !== 0 && lastLine.length > 0) {\n        lastLine = [];\n        lines.push(lastLine);\n      }\n    } else {\n      lastLine.push(node);\n    }\n  }\n  return lines;\n}\nfunction $handleTab(shiftKey) {\n  const selection = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$getSelection)();\n  if (!(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isRangeSelection)(selection) || !$isSelectionInCode(selection)) {\n    return null;\n  }\n  const indentOrOutdent = !shiftKey ? _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.INDENT_CONTENT_COMMAND : _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.OUTDENT_CONTENT_COMMAND;\n  const tabOrOutdent = !shiftKey ? _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.INSERT_TAB_COMMAND : _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.OUTDENT_CONTENT_COMMAND;\n  // 1. If multiple lines selected: indent/outdent\n  const codeLines = $getCodeLines(selection);\n  if (codeLines.length > 1) {\n    return indentOrOutdent;\n  }\n  // 2. If entire line selected: indent/outdent\n  const selectionNodes = selection.getNodes();\n  const firstNode = selectionNodes[0];\n  if (!($isCodeNode(firstNode) || $isCodeHighlightNode(firstNode) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(firstNode) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(firstNode))) {\n    throw Error(`Expected selection firstNode to be CodeHighlightNode or TabNode`);\n  }\n  if ($isCodeNode(firstNode)) {\n    return indentOrOutdent;\n  }\n  const firstOfLine = getFirstCodeNodeOfLine(firstNode);\n  const lastOfLine = getLastCodeNodeOfLine(firstNode);\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  let selectionFirst;\n  let selectionLast;\n  if (focus.isBefore(anchor)) {\n    selectionFirst = focus;\n    selectionLast = anchor;\n  } else {\n    selectionFirst = anchor;\n    selectionLast = focus;\n  }\n  if (firstOfLine !== null && lastOfLine !== null && selectionFirst.key === firstOfLine.getKey() && selectionFirst.offset === 0 && selectionLast.key === lastOfLine.getKey() && selectionLast.offset === lastOfLine.getTextContentSize()) {\n    return indentOrOutdent;\n  }\n  // 3. Else: tab/outdent\n  return tabOrOutdent;\n}\nfunction $handleMultilineIndent(type) {\n  const selection = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$getSelection)();\n  if (!(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isRangeSelection)(selection) || !$isSelectionInCode(selection)) {\n    return false;\n  }\n  const codeLines = $getCodeLines(selection);\n  const codeLinesLength = codeLines.length;\n  // Multiple lines selection\n  if (codeLines.length > 1) {\n    for (let i = 0; i < codeLinesLength; i++) {\n      const line = codeLines[i];\n      if (line.length > 0) {\n        let firstOfLine = line[0];\n        // First and last lines might not be complete\n        if (i === 0) {\n          firstOfLine = getFirstCodeNodeOfLine(firstOfLine);\n        }\n        if (firstOfLine !== null) {\n          if (type === _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.INDENT_CONTENT_COMMAND) {\n            firstOfLine.insertBefore((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createTabNode)());\n          } else if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(firstOfLine)) {\n            firstOfLine.remove();\n          }\n        }\n      }\n    }\n    return true;\n  }\n  // Just one line\n  const selectionNodes = selection.getNodes();\n  const firstNode = selectionNodes[0];\n  if (!($isCodeNode(firstNode) || $isCodeHighlightNode(firstNode) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(firstNode) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(firstNode))) {\n    throw Error(`Expected selection firstNode to be CodeHighlightNode or CodeTabNode`);\n  }\n  if ($isCodeNode(firstNode)) {\n    // CodeNode is empty\n    if (type === _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.INDENT_CONTENT_COMMAND) {\n      selection.insertNodes([(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createTabNode)()]);\n    }\n    return true;\n  }\n  const firstOfLine = getFirstCodeNodeOfLine(firstNode);\n  if (!(firstOfLine !== null)) {\n    throw Error(`Expected getFirstCodeNodeOfLine to return a valid Code Node`);\n  }\n  if (type === _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.INDENT_CONTENT_COMMAND) {\n    if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(firstOfLine)) {\n      firstOfLine.insertAfter((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createTabNode)());\n    } else {\n      firstOfLine.insertBefore((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createTabNode)());\n    }\n  } else if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(firstOfLine)) {\n    firstOfLine.remove();\n  }\n  return true;\n}\nfunction $handleShiftLines(type, event) {\n  // We only care about the alt+arrow keys\n  const selection = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$getSelection)();\n  if (!(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isRangeSelection)(selection)) {\n    return false;\n  }\n\n  // I'm not quite sure why, but it seems like calling anchor.getNode() collapses the selection here\n  // So first, get the anchor and the focus, then get their nodes\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorOffset = anchor.offset;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  const arrowIsUp = type === _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.KEY_ARROW_UP_COMMAND;\n\n  // Ensure the selection is within the codeblock\n  if (!$isSelectionInCode(selection) || !($isCodeHighlightNode(anchorNode) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(anchorNode)) || !($isCodeHighlightNode(focusNode) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(focusNode))) {\n    return false;\n  }\n  if (!event.altKey) {\n    // Handle moving selection out of the code block, given there are no\n    // sibling thats can natively take the selection.\n    if (selection.isCollapsed()) {\n      const codeNode = anchorNode.getParentOrThrow();\n      if (arrowIsUp && anchorOffset === 0 && anchorNode.getPreviousSibling() === null) {\n        const codeNodeSibling = codeNode.getPreviousSibling();\n        if (codeNodeSibling === null) {\n          codeNode.selectPrevious();\n          event.preventDefault();\n          return true;\n        }\n      } else if (!arrowIsUp && anchorOffset === anchorNode.getTextContentSize() && anchorNode.getNextSibling() === null) {\n        const codeNodeSibling = codeNode.getNextSibling();\n        if (codeNodeSibling === null) {\n          codeNode.selectNext();\n          event.preventDefault();\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  let start;\n  let end;\n  if (anchorNode.isBefore(focusNode)) {\n    start = getFirstCodeNodeOfLine(anchorNode);\n    end = getLastCodeNodeOfLine(focusNode);\n  } else {\n    start = getFirstCodeNodeOfLine(focusNode);\n    end = getLastCodeNodeOfLine(anchorNode);\n  }\n  if (start == null || end == null) {\n    return false;\n  }\n  const range = start.getNodesBetween(end);\n  for (let i = 0; i < range.length; i++) {\n    const node = range[i];\n    if (!$isCodeHighlightNode(node) && !(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(node) && !(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(node)) {\n      return false;\n    }\n  }\n\n  // After this point, we know the selection is within the codeblock. We may not be able to\n  // actually move the lines around, but we want to return true either way to prevent\n  // the event's default behavior\n  event.preventDefault();\n  event.stopPropagation(); // required to stop cursor movement under Firefox\n\n  const linebreak = arrowIsUp ? start.getPreviousSibling() : end.getNextSibling();\n  if (!(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(linebreak)) {\n    return true;\n  }\n  const sibling = arrowIsUp ? linebreak.getPreviousSibling() : linebreak.getNextSibling();\n  if (sibling == null) {\n    return true;\n  }\n  const maybeInsertionPoint = $isCodeHighlightNode(sibling) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(sibling) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(sibling) ? arrowIsUp ? getFirstCodeNodeOfLine(sibling) : getLastCodeNodeOfLine(sibling) : null;\n  let insertionPoint = maybeInsertionPoint != null ? maybeInsertionPoint : sibling;\n  linebreak.remove();\n  range.forEach(node => node.remove());\n  if (type === _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.KEY_ARROW_UP_COMMAND) {\n    range.forEach(node => insertionPoint.insertBefore(node));\n    insertionPoint.insertBefore(linebreak);\n  } else {\n    insertionPoint.insertAfter(linebreak);\n    insertionPoint = linebreak;\n    range.forEach(node => {\n      insertionPoint.insertAfter(node);\n      insertionPoint = node;\n    });\n  }\n  selection.setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset);\n  return true;\n}\nfunction $handleMoveTo(type, event) {\n  const selection = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$getSelection)();\n  if (!(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isRangeSelection)(selection)) {\n    return false;\n  }\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  const isMoveToStart = type === _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.MOVE_TO_START;\n\n  // Ensure the selection is within the codeblock\n  if (!$isSelectionInCode(selection) || !($isCodeHighlightNode(anchorNode) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(anchorNode)) || !($isCodeHighlightNode(focusNode) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isTabNode)(focusNode))) {\n    return false;\n  }\n  if (isMoveToStart) {\n    const start = getStartOfCodeInLine(focusNode, focus.offset);\n    if (start !== null) {\n      const {\n        node,\n        offset\n      } = start;\n      if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$isLineBreakNode)(node)) {\n        node.selectNext(0, 0);\n      } else {\n        selection.setTextNodeRange(node, offset, node, offset);\n      }\n    } else {\n      focusNode.getParentOrThrow().selectStart();\n    }\n  } else {\n    const node = getEndOfCodeInLine(focusNode);\n    node.select();\n  }\n  event.preventDefault();\n  event.stopPropagation();\n  return true;\n}\nfunction registerCodeHighlighting(editor, tokenizer) {\n  if (!editor.hasNodes([CodeNode, CodeHighlightNode])) {\n    throw new Error('CodeHighlightPlugin: CodeNode or CodeHighlightNode not registered on editor');\n  }\n  if (tokenizer == null) {\n    tokenizer = PrismTokenizer;\n  }\n  return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_17__.mergeRegister)(editor.registerMutationListener(CodeNode, mutations => {\n    editor.update(() => {\n      for (const [key, type] of mutations) {\n        if (type !== 'destroyed') {\n          const node = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$getNodeByKey)(key);\n          if (node !== null) {\n            updateCodeGutter(node, editor);\n          }\n        }\n      }\n    });\n  }, {\n    skipInitialization: false\n  }), editor.registerNodeTransform(CodeNode, node => codeNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.TextNode, node => $textNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(CodeHighlightNode, node => $textNodeTransform(node, editor, tokenizer)), editor.registerCommand(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.KEY_TAB_COMMAND, event => {\n    const command = $handleTab(event.shiftKey);\n    if (command === null) {\n      return false;\n    }\n    event.preventDefault();\n    editor.dispatchCommand(command, undefined);\n    return true;\n  }, _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.COMMAND_PRIORITY_LOW), editor.registerCommand(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.INSERT_TAB_COMMAND, () => {\n    const selection = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$getSelection)();\n    if (!$isSelectionInCode(selection)) {\n      return false;\n    }\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$insertNodes)([(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.$createTabNode)()]);\n    return true;\n  }, _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.COMMAND_PRIORITY_LOW), editor.registerCommand(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.INDENT_CONTENT_COMMAND, payload => $handleMultilineIndent(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.INDENT_CONTENT_COMMAND), _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.COMMAND_PRIORITY_LOW), editor.registerCommand(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.OUTDENT_CONTENT_COMMAND, payload => $handleMultilineIndent(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.OUTDENT_CONTENT_COMMAND), _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.COMMAND_PRIORITY_LOW), editor.registerCommand(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.KEY_ARROW_UP_COMMAND, payload => $handleShiftLines(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.KEY_ARROW_UP_COMMAND, payload), _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.COMMAND_PRIORITY_LOW), editor.registerCommand(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.KEY_ARROW_DOWN_COMMAND, payload => $handleShiftLines(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.KEY_ARROW_DOWN_COMMAND, payload), _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.COMMAND_PRIORITY_LOW), editor.registerCommand(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.MOVE_TO_END, payload => $handleMoveTo(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.MOVE_TO_END, payload), _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.COMMAND_PRIORITY_LOW), editor.registerCommand(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.MOVE_TO_START, payload => $handleMoveTo(_lexical_utils__WEBPACK_IMPORTED_MODULE_16__.MOVE_TO_START, payload), _lexical_utils__WEBPACK_IMPORTED_MODULE_16__.COMMAND_PRIORITY_LOW));\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxleGljYWwrY29kZUAwLjIwLjAvbm9kZV9tb2R1bGVzL0BsZXhpY2FsL2NvZGUvTGV4aWNhbENvZGUuZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW1IO0FBQ2lVO0FBQ25hO0FBQzBCO0FBQ0s7QUFDSjtBQUNFO0FBQ1A7QUFDRTtBQUNPO0FBQ1A7QUFDTztBQUNKO0FBQ0Y7QUFDQztBQUNLO0FBQ047QUFDRDs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDhEQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsd0RBQVc7QUFDbEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVFQUFzQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksdUVBQXNCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscUVBQW9CO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVEsNERBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJEQUFVO0FBQ3RCLDJCQUEyQiwrREFBYztBQUN6QztBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixxRUFBb0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDRDQUE0QyxxRUFBb0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxRUFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxzRUFBcUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLHFEQUFRO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVFQUFzQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0RUFBMkI7QUFDbkM7QUFDQTtBQUNBLFFBQVEsdUVBQXNCO0FBQzlCO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSxpRUFBb0IsMEJBQTBCLCtEQUFrQjtBQUNyRSxzQkFBc0IsOERBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsSUFBSSw2REFBWSxFQUFFLCtEQUFjO0FBQ2hDO0FBQ0EsR0FBRyxFQUFFLGlFQUFvQiwwQkFBMEIsbUVBQXNCLG9DQUFvQyxtRUFBc0IsR0FBRyxpRUFBb0IsMEJBQTBCLG9FQUF1QixvQ0FBb0Msb0VBQXVCLEdBQUcsaUVBQW9CLDBCQUEwQixpRUFBb0IsK0JBQStCLGlFQUFvQixZQUFZLGlFQUFvQiwwQkFBMEIsbUVBQXNCLCtCQUErQixtRUFBc0IsWUFBWSxpRUFBb0IsMEJBQTBCLHdEQUFXLDJCQUEyQix3REFBVyxZQUFZLGlFQUFvQiwwQkFBMEIsMERBQWEsMkJBQTJCLDBEQUFhLFlBQVksaUVBQW9CO0FBQzd2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFeVoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZXNzb24tYXV0aG9yaW5nLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BsZXhpY2FsK2NvZGVAMC4yMC4wL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9jb2RlL0xleGljYWxDb2RlLmRldi5tanM/OWYwZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQsIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQsIHJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudCwgbWVyZ2VSZWdpc3RlciB9IGZyb20gJ0BsZXhpY2FsL3V0aWxzJztcbmltcG9ydCB7IEVsZW1lbnROb2RlLCAkY3JlYXRlUGFyYWdyYXBoTm9kZSwgJGlzVGV4dE5vZGUsICRpc1RhYk5vZGUsICRjcmVhdGVUYWJOb2RlLCAkY3JlYXRlTGluZUJyZWFrTm9kZSwgJGFwcGx5Tm9kZVJlcGxhY2VtZW50LCBUZXh0Tm9kZSwgJGlzTGluZUJyZWFrTm9kZSwgJGNyZWF0ZVRleHROb2RlLCAkZ2V0Tm9kZUJ5S2V5LCAkZ2V0U2VsZWN0aW9uLCAkaXNSYW5nZVNlbGVjdGlvbiwgSU5ERU5UX0NPTlRFTlRfQ09NTUFORCwgT1VUREVOVF9DT05URU5UX0NPTU1BTkQsIElOU0VSVF9UQUJfQ09NTUFORCwgS0VZX0FSUk9XX1VQX0NPTU1BTkQsIE1PVkVfVE9fU1RBUlQsIEtFWV9UQUJfQ09NTUFORCwgQ09NTUFORF9QUklPUklUWV9MT1csICRpbnNlcnROb2RlcywgS0VZX0FSUk9XX0RPV05fQ09NTUFORCwgTU9WRV9UT19FTkQgfSBmcm9tICdsZXhpY2FsJztcbmltcG9ydCAncHJpc21qcyc7XG5pbXBvcnQgJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1jbGlrZS5qcyc7XG5pbXBvcnQgJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1qYXZhc2NyaXB0LmpzJztcbmltcG9ydCAncHJpc21qcy9jb21wb25lbnRzL3ByaXNtLW1hcmt1cC5qcyc7XG5pbXBvcnQgJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1tYXJrZG93bi5qcyc7XG5pbXBvcnQgJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1jLmpzJztcbmltcG9ydCAncHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWNzcy5qcyc7XG5pbXBvcnQgJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1vYmplY3RpdmVjLmpzJztcbmltcG9ydCAncHJpc21qcy9jb21wb25lbnRzL3ByaXNtLXNxbC5qcyc7XG5pbXBvcnQgJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1wb3dlcnNoZWxsLmpzJztcbmltcG9ydCAncHJpc21qcy9jb21wb25lbnRzL3ByaXNtLXB5dGhvbi5qcyc7XG5pbXBvcnQgJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1ydXN0LmpzJztcbmltcG9ydCAncHJpc21qcy9jb21wb25lbnRzL3ByaXNtLXN3aWZ0LmpzJztcbmltcG9ydCAncHJpc21qcy9jb21wb25lbnRzL3ByaXNtLXR5cGVzY3JpcHQuanMnO1xuaW1wb3J0ICdwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tamF2YS5qcyc7XG5pbXBvcnQgJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1jcHAuanMnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8vIGludmFyaWFudChjb25kaXRpb24sIG1lc3NhZ2UpIHdpbGwgcmVmaW5lIHR5cGVzIGJhc2VkIG9uIFwiY29uZGl0aW9uXCIsIGFuZFxuLy8gaWYgXCJjb25kaXRpb25cIiBpcyBmYWxzZSB3aWxsIHRocm93IGFuIGVycm9yLiBUaGlzIGZ1bmN0aW9uIGlzIHNwZWNpYWwtY2FzZWRcbi8vIGluIGZsb3cgaXRzZWxmLCBzbyB3ZSBjYW4ndCBuYW1lIGl0IGFueXRoaW5nIGVsc2UuXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZCwgbWVzc2FnZSwgLi4uYXJncykge1xuICBpZiAoY29uZCkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ0ludGVybmFsIExleGljYWwgZXJyb3I6IGludmFyaWFudCgpIGlzIG1lYW50IHRvIGJlIHJlcGxhY2VkIGF0IGNvbXBpbGUgJyArICd0aW1lLiBUaGVyZSBpcyBubyBydW50aW1lIHZlcnNpb24uIEVycm9yOiAnICsgbWVzc2FnZSk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgUHJpc20gPSBnbG9iYWxUaGlzLlByaXNtIHx8IHdpbmRvdy5QcmlzbTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBpc0xhbmd1YWdlU3VwcG9ydGVkQnlQcmlzbSA9IGxhbmd1YWdlID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgcmV0dXJuIGxhbmd1YWdlID8gUHJpc20ubGFuZ3VhZ2VzLmhhc093blByb3BlcnR5KGxhbmd1YWdlKSA6IGZhbHNlO1xuICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuZnVuY3Rpb24gaGFzQ2hpbGRET01Ob2RlVGFnKG5vZGUsIHRhZ05hbWUpIHtcbiAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkTm9kZXMpIHtcbiAgICBpZiAoaXNIVE1MRWxlbWVudChjaGlsZCkgJiYgY2hpbGQudGFnTmFtZSA9PT0gdGFnTmFtZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGhhc0NoaWxkRE9NTm9kZVRhZyhjaGlsZCwgdGFnTmFtZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuY29uc3QgTEFOR1VBR0VfREFUQV9BVFRSSUJVVEUgPSAnZGF0YS1sYW5ndWFnZSc7XG5jb25zdCBISUdITElHSFRfTEFOR1VBR0VfREFUQV9BVFRSSUJVVEUgPSAnZGF0YS1oaWdobGlnaHQtbGFuZ3VhZ2UnO1xuXG4vKiogQG5vSW5oZXJpdERvYyAqL1xuY2xhc3MgQ29kZU5vZGUgZXh0ZW5kcyBFbGVtZW50Tm9kZSB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICdjb2RlJztcbiAgfVxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgQ29kZU5vZGUobm9kZS5fX2xhbmd1YWdlLCBub2RlLl9fa2V5KTtcbiAgfVxuICBjb25zdHJ1Y3RvcihsYW5ndWFnZSwga2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICB0aGlzLl9fbGFuZ3VhZ2UgPSBsYW5ndWFnZTtcbiAgICB0aGlzLl9faXNTeW50YXhIaWdobGlnaHRTdXBwb3J0ZWQgPSBpc0xhbmd1YWdlU3VwcG9ydGVkQnlQcmlzbShsYW5ndWFnZSk7XG4gIH1cblxuICAvLyBWaWV3XG4gIGNyZWF0ZURPTShjb25maWcpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY29kZScpO1xuICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgY29uZmlnLnRoZW1lLmNvZGUpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdzcGVsbGNoZWNrJywgJ2ZhbHNlJyk7XG4gICAgY29uc3QgbGFuZ3VhZ2UgPSB0aGlzLmdldExhbmd1YWdlKCk7XG4gICAgaWYgKGxhbmd1YWdlKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShMQU5HVUFHRV9EQVRBX0FUVFJJQlVURSwgbGFuZ3VhZ2UpO1xuICAgICAgaWYgKHRoaXMuZ2V0SXNTeW50YXhIaWdobGlnaHRTdXBwb3J0ZWQoKSkge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShISUdITElHSFRfTEFOR1VBR0VfREFUQV9BVFRSSUJVVEUsIGxhbmd1YWdlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgdXBkYXRlRE9NKHByZXZOb2RlLCBkb20sIGNvbmZpZykge1xuICAgIGNvbnN0IGxhbmd1YWdlID0gdGhpcy5fX2xhbmd1YWdlO1xuICAgIGNvbnN0IHByZXZMYW5ndWFnZSA9IHByZXZOb2RlLl9fbGFuZ3VhZ2U7XG4gICAgaWYgKGxhbmd1YWdlKSB7XG4gICAgICBpZiAobGFuZ3VhZ2UgIT09IHByZXZMYW5ndWFnZSkge1xuICAgICAgICBkb20uc2V0QXR0cmlidXRlKExBTkdVQUdFX0RBVEFfQVRUUklCVVRFLCBsYW5ndWFnZSk7XG4gICAgICAgIGlmICh0aGlzLl9faXNTeW50YXhIaWdobGlnaHRTdXBwb3J0ZWQpIHtcbiAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKEhJR0hMSUdIVF9MQU5HVUFHRV9EQVRBX0FUVFJJQlVURSwgbGFuZ3VhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcmV2TGFuZ3VhZ2UpIHtcbiAgICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUoTEFOR1VBR0VfREFUQV9BVFRSSUJVVEUpO1xuICAgICAgaWYgKHByZXZOb2RlLl9faXNTeW50YXhIaWdobGlnaHRTdXBwb3J0ZWQpIHtcbiAgICAgICAgZG9tLnJlbW92ZUF0dHJpYnV0ZShISUdITElHSFRfTEFOR1VBR0VfREFUQV9BVFRSSUJVVEUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZXhwb3J0RE9NKGVkaXRvcikge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwcmUnKTtcbiAgICBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIGVkaXRvci5fY29uZmlnLnRoZW1lLmNvZGUpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdzcGVsbGNoZWNrJywgJ2ZhbHNlJyk7XG4gICAgY29uc3QgbGFuZ3VhZ2UgPSB0aGlzLmdldExhbmd1YWdlKCk7XG4gICAgaWYgKGxhbmd1YWdlKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShMQU5HVUFHRV9EQVRBX0FUVFJJQlVURSwgbGFuZ3VhZ2UpO1xuICAgICAgaWYgKHRoaXMuZ2V0SXNTeW50YXhIaWdobGlnaHRTdXBwb3J0ZWQoKSkge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShISUdITElHSFRfTEFOR1VBR0VfREFUQV9BVFRSSUJVVEUsIGxhbmd1YWdlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnRcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBpbXBvcnRET00oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFR5cGljYWxseSA8cHJlPiBpcyB1c2VkIGZvciBjb2RlIGJsb2NrcywgYW5kIDxjb2RlPiBmb3IgaW5saW5lIGNvZGUgc3R5bGVzXG4gICAgICAvLyBidXQgaWYgaXQncyBhIG11bHRpIGxpbmUgPGNvZGU+IHdlJ2xsIGNyZWF0ZSBhIGJsb2NrLiBQYXNzIHRocm91Z2ggdG9cbiAgICAgIC8vIGlubGluZSBmb3JtYXQgaGFuZGxlZCBieSBUZXh0Tm9kZSBvdGhlcndpc2UuXG4gICAgICBjb2RlOiBub2RlID0+IHtcbiAgICAgICAgY29uc3QgaXNNdWx0aUxpbmUgPSBub2RlLnRleHRDb250ZW50ICE9IG51bGwgJiYgKC9cXHI/XFxuLy50ZXN0KG5vZGUudGV4dENvbnRlbnQpIHx8IGhhc0NoaWxkRE9NTm9kZVRhZyhub2RlLCAnQlInKSk7XG4gICAgICAgIHJldHVybiBpc011bHRpTGluZSA/IHtcbiAgICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydFByZUVsZW1lbnQsXG4gICAgICAgICAgcHJpb3JpdHk6IDFcbiAgICAgICAgfSA6IG51bGw7XG4gICAgICB9LFxuICAgICAgZGl2OiAoKSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydERpdkVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAxXG4gICAgICB9KSxcbiAgICAgIHByZTogKCkgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogJGNvbnZlcnRQcmVFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICB0YWJsZTogbm9kZSA9PiB7XG4gICAgICAgIGNvbnN0IHRhYmxlID0gbm9kZTtcbiAgICAgICAgLy8gZG9tTm9kZSBpcyBhIDx0YWJsZT4gc2luY2Ugd2UgbWF0Y2hlZCBpdCBieSBub2RlTmFtZVxuICAgICAgICBpZiAoaXNHaXRIdWJDb2RlVGFibGUodGFibGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnZlcnNpb246ICRjb252ZXJ0VGFibGVFbGVtZW50LFxuICAgICAgICAgICAgcHJpb3JpdHk6IDNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSxcbiAgICAgIHRkOiBub2RlID0+IHtcbiAgICAgICAgLy8gZWxlbWVudCBpcyBhIDx0ZD4gc2luY2Ugd2UgbWF0Y2hlZCBpdCBieSBub2RlTmFtZVxuICAgICAgICBjb25zdCB0ZCA9IG5vZGU7XG4gICAgICAgIGNvbnN0IHRhYmxlID0gdGQuY2xvc2VzdCgndGFibGUnKTtcbiAgICAgICAgaWYgKGlzR2l0SHViQ29kZUNlbGwodGQpIHx8IHRhYmxlICYmIGlzR2l0SHViQ29kZVRhYmxlKHRhYmxlKSkge1xuICAgICAgICAgIC8vIFJldHVybiBhIG5vLW9wIGlmIGl0J3MgYSB0YWJsZSBjZWxsIGluIGEgY29kZSB0YWJsZSwgYnV0IG5vdCBhIGNvZGUgbGluZS5cbiAgICAgICAgICAvLyBPdGhlcndpc2UgaXQnbGwgZmFsbCBiYWNrIHRvIHRoZSBUXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRDb2RlTm9vcCxcbiAgICAgICAgICAgIHByaW9yaXR5OiAzXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sXG4gICAgICB0cjogbm9kZSA9PiB7XG4gICAgICAgIC8vIGVsZW1lbnQgaXMgYSA8dHI+IHNpbmNlIHdlIG1hdGNoZWQgaXQgYnkgbm9kZU5hbWVcbiAgICAgICAgY29uc3QgdHIgPSBub2RlO1xuICAgICAgICBjb25zdCB0YWJsZSA9IHRyLmNsb3Nlc3QoJ3RhYmxlJyk7XG4gICAgICAgIGlmICh0YWJsZSAmJiBpc0dpdEh1YkNvZGVUYWJsZSh0YWJsZSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udmVyc2lvbjogY29udmVydENvZGVOb29wLFxuICAgICAgICAgICAgcHJpb3JpdHk6IDNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICBjb25zdCBub2RlID0gJGNyZWF0ZUNvZGVOb2RlKHNlcmlhbGl6ZWROb2RlLmxhbmd1YWdlKTtcbiAgICBub2RlLnNldEZvcm1hdChzZXJpYWxpemVkTm9kZS5mb3JtYXQpO1xuICAgIG5vZGUuc2V0SW5kZW50KHNlcmlhbGl6ZWROb2RlLmluZGVudCk7XG4gICAgbm9kZS5zZXREaXJlY3Rpb24oc2VyaWFsaXplZE5vZGUuZGlyZWN0aW9uKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5leHBvcnRKU09OKCksXG4gICAgICBsYW5ndWFnZTogdGhpcy5nZXRMYW5ndWFnZSgpLFxuICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgdmVyc2lvbjogMVxuICAgIH07XG4gIH1cblxuICAvLyBNdXRhdGlvblxuICBpbnNlcnROZXdBZnRlcihzZWxlY3Rpb24sIHJlc3RvcmVTZWxlY3Rpb24gPSB0cnVlKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKCk7XG4gICAgY29uc3QgY2hpbGRyZW5MZW5ndGggPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgaWYgKGNoaWxkcmVuTGVuZ3RoID49IDIgJiYgY2hpbGRyZW5bY2hpbGRyZW5MZW5ndGggLSAxXS5nZXRUZXh0Q29udGVudCgpID09PSAnXFxuJyAmJiBjaGlsZHJlbltjaGlsZHJlbkxlbmd0aCAtIDJdLmdldFRleHRDb250ZW50KCkgPT09ICdcXG4nICYmIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpICYmIHNlbGVjdGlvbi5hbmNob3Iua2V5ID09PSB0aGlzLl9fa2V5ICYmIHNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0ID09PSBjaGlsZHJlbkxlbmd0aCkge1xuICAgICAgY2hpbGRyZW5bY2hpbGRyZW5MZW5ndGggLSAxXS5yZW1vdmUoKTtcbiAgICAgIGNoaWxkcmVuW2NoaWxkcmVuTGVuZ3RoIC0gMl0ucmVtb3ZlKCk7XG4gICAgICBjb25zdCBuZXdFbGVtZW50ID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICAgIHRoaXMuaW5zZXJ0QWZ0ZXIobmV3RWxlbWVudCwgcmVzdG9yZVNlbGVjdGlvbik7XG4gICAgICByZXR1cm4gbmV3RWxlbWVudDtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgc2VsZWN0aW9uIGlzIHdpdGhpbiB0aGUgY29kZWJsb2NrLCBmaW5kIGFsbCBsZWFkaW5nIHRhYnMgYW5kXG4gICAgLy8gc3BhY2VzIG9mIHRoZSBjdXJyZW50IGxpbmUuIENyZWF0ZSBhIG5ldyBsaW5lIHRoYXQgaGFzIGFsbCB0aG9zZVxuICAgIC8vIHRhYnMgYW5kIHNwYWNlcywgc3VjaCB0aGF0IGxlYWRpbmcgaW5kZW50YXRpb24gaXMgcHJlc2VydmVkLlxuICAgIGNvbnN0IHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfSA9IHNlbGVjdGlvbjtcbiAgICBjb25zdCBmaXJzdFBvaW50ID0gYW5jaG9yLmlzQmVmb3JlKGZvY3VzKSA/IGFuY2hvciA6IGZvY3VzO1xuICAgIGNvbnN0IGZpcnN0U2VsZWN0aW9uTm9kZSA9IGZpcnN0UG9pbnQuZ2V0Tm9kZSgpO1xuICAgIGlmICgkaXNUZXh0Tm9kZShmaXJzdFNlbGVjdGlvbk5vZGUpKSB7XG4gICAgICBsZXQgbm9kZSA9IGdldEZpcnN0Q29kZU5vZGVPZkxpbmUoZmlyc3RTZWxlY3Rpb25Ob2RlKTtcbiAgICAgIGNvbnN0IGluc2VydE5vZGVzID0gW107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAoJGlzVGFiTm9kZShub2RlKSkge1xuICAgICAgICAgIGluc2VydE5vZGVzLnB1c2goJGNyZWF0ZVRhYk5vZGUoKSk7XG4gICAgICAgICAgbm9kZSA9IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmICgkaXNDb2RlSGlnaGxpZ2h0Tm9kZShub2RlKSkge1xuICAgICAgICAgIGxldCBzcGFjZXMgPSAwO1xuICAgICAgICAgIGNvbnN0IHRleHQgPSBub2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgICAgICAgY29uc3QgdGV4dFNpemUgPSBub2RlLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICAgICAgICAgIHdoaWxlIChzcGFjZXMgPCB0ZXh0U2l6ZSAmJiB0ZXh0W3NwYWNlc10gPT09ICcgJykge1xuICAgICAgICAgICAgc3BhY2VzKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzcGFjZXMgIT09IDApIHtcbiAgICAgICAgICAgIGluc2VydE5vZGVzLnB1c2goJGNyZWF0ZUNvZGVIaWdobGlnaHROb2RlKCcgJy5yZXBlYXQoc3BhY2VzKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3BhY2VzICE9PSB0ZXh0U2l6ZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUgPSBub2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHNwbGl0ID0gZmlyc3RTZWxlY3Rpb25Ob2RlLnNwbGl0VGV4dChhbmNob3Iub2Zmc2V0KVswXTtcbiAgICAgIGNvbnN0IHggPSBhbmNob3Iub2Zmc2V0ID09PSAwID8gMCA6IDE7XG4gICAgICBjb25zdCBpbmRleCA9IHNwbGl0LmdldEluZGV4V2l0aGluUGFyZW50KCkgKyB4O1xuICAgICAgY29uc3QgY29kZU5vZGUgPSBmaXJzdFNlbGVjdGlvbk5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgY29uc3Qgbm9kZXNUb0luc2VydCA9IFskY3JlYXRlTGluZUJyZWFrTm9kZSgpLCAuLi5pbnNlcnROb2Rlc107XG4gICAgICBjb2RlTm9kZS5zcGxpY2UoaW5kZXgsIDAsIG5vZGVzVG9JbnNlcnQpO1xuICAgICAgY29uc3QgbGFzdCA9IGluc2VydE5vZGVzW2luc2VydE5vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgbGFzdC5zZWxlY3QoKTtcbiAgICAgIH0gZWxzZSBpZiAoYW5jaG9yLm9mZnNldCA9PT0gMCkge1xuICAgICAgICBzcGxpdC5zZWxlY3RQcmV2aW91cygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BsaXQuZ2V0TmV4dFNpYmxpbmcoKS5zZWxlY3ROZXh0KDAsIDApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoJGlzQ29kZU5vZGUoZmlyc3RTZWxlY3Rpb25Ob2RlKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBvZmZzZXRcbiAgICAgIH0gPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgICAgZmlyc3RTZWxlY3Rpb25Ob2RlLnNwbGljZShvZmZzZXQsIDAsIFskY3JlYXRlTGluZUJyZWFrTm9kZSgpXSk7XG4gICAgICBmaXJzdFNlbGVjdGlvbk5vZGUuc2VsZWN0KG9mZnNldCArIDEsIG9mZnNldCArIDEpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjYW5JbmRlbnQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbGxhcHNlQXRTdGFydCgpIHtcbiAgICBjb25zdCBwYXJhZ3JhcGggPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbigpO1xuICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gcGFyYWdyYXBoLmFwcGVuZChjaGlsZCkpO1xuICAgIHRoaXMucmVwbGFjZShwYXJhZ3JhcGgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHNldExhbmd1YWdlKGxhbmd1YWdlKSB7XG4gICAgY29uc3Qgd3JpdGFibGUgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgd3JpdGFibGUuX19sYW5ndWFnZSA9IGxhbmd1YWdlO1xuICAgIHdyaXRhYmxlLl9faXNTeW50YXhIaWdobGlnaHRTdXBwb3J0ZWQgPSBpc0xhbmd1YWdlU3VwcG9ydGVkQnlQcmlzbShsYW5ndWFnZSk7XG4gIH1cbiAgZ2V0TGFuZ3VhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX19sYW5ndWFnZTtcbiAgfVxuICBnZXRJc1N5bnRheEhpZ2hsaWdodFN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX2lzU3ludGF4SGlnaGxpZ2h0U3VwcG9ydGVkO1xuICB9XG59XG5mdW5jdGlvbiAkY3JlYXRlQ29kZU5vZGUobGFuZ3VhZ2UpIHtcbiAgcmV0dXJuICRhcHBseU5vZGVSZXBsYWNlbWVudChuZXcgQ29kZU5vZGUobGFuZ3VhZ2UpKTtcbn1cbmZ1bmN0aW9uICRpc0NvZGVOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBDb2RlTm9kZTtcbn1cbmZ1bmN0aW9uICRjb252ZXJ0UHJlRWxlbWVudChkb21Ob2RlKSB7XG4gIGNvbnN0IGxhbmd1YWdlID0gZG9tTm9kZS5nZXRBdHRyaWJ1dGUoTEFOR1VBR0VfREFUQV9BVFRSSUJVVEUpO1xuICByZXR1cm4ge1xuICAgIG5vZGU6ICRjcmVhdGVDb2RlTm9kZShsYW5ndWFnZSlcbiAgfTtcbn1cbmZ1bmN0aW9uICRjb252ZXJ0RGl2RWxlbWVudChkb21Ob2RlKSB7XG4gIC8vIGRvbU5vZGUgaXMgYSA8ZGl2PiBzaW5jZSB3ZSBtYXRjaGVkIGl0IGJ5IG5vZGVOYW1lXG4gIGNvbnN0IGRpdiA9IGRvbU5vZGU7XG4gIGNvbnN0IGlzQ29kZSA9IGlzQ29kZUVsZW1lbnQoZGl2KTtcbiAgaWYgKCFpc0NvZGUgJiYgIWlzQ29kZUNoaWxkRWxlbWVudChkaXYpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vZGU6IG51bGxcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbm9kZTogaXNDb2RlID8gJGNyZWF0ZUNvZGVOb2RlKCkgOiBudWxsXG4gIH07XG59XG5mdW5jdGlvbiAkY29udmVydFRhYmxlRWxlbWVudCgpIHtcbiAgcmV0dXJuIHtcbiAgICBub2RlOiAkY3JlYXRlQ29kZU5vZGUoKVxuICB9O1xufVxuZnVuY3Rpb24gY29udmVydENvZGVOb29wKCkge1xuICByZXR1cm4ge1xuICAgIG5vZGU6IG51bGxcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQ29kZUVsZW1lbnQoZGl2KSB7XG4gIHJldHVybiBkaXYuc3R5bGUuZm9udEZhbWlseS5tYXRjaCgnbW9ub3NwYWNlJykgIT09IG51bGw7XG59XG5mdW5jdGlvbiBpc0NvZGVDaGlsZEVsZW1lbnQobm9kZSkge1xuICBsZXQgcGFyZW50ID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgaWYgKGlzQ29kZUVsZW1lbnQocGFyZW50KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnRFbGVtZW50O1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzR2l0SHViQ29kZUNlbGwoY2VsbCkge1xuICByZXR1cm4gY2VsbC5jbGFzc0xpc3QuY29udGFpbnMoJ2pzLWZpbGUtbGluZScpO1xufVxuZnVuY3Rpb24gaXNHaXRIdWJDb2RlVGFibGUodGFibGUpIHtcbiAgcmV0dXJuIHRhYmxlLmNsYXNzTGlzdC5jb250YWlucygnanMtZmlsZS1saW5lLWNvbnRhaW5lcicpO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IERFRkFVTFRfQ09ERV9MQU5HVUFHRSA9ICdqYXZhc2NyaXB0JztcbmNvbnN0IENPREVfTEFOR1VBR0VfRlJJRU5ETFlfTkFNRV9NQVAgPSB7XG4gIGM6ICdDJyxcbiAgY2xpa2U6ICdDLWxpa2UnLFxuICBjcHA6ICdDKysnLFxuICBjc3M6ICdDU1MnLFxuICBodG1sOiAnSFRNTCcsXG4gIGphdmE6ICdKYXZhJyxcbiAganM6ICdKYXZhU2NyaXB0JyxcbiAgbWFya2Rvd246ICdNYXJrZG93bicsXG4gIG9iamM6ICdPYmplY3RpdmUtQycsXG4gIHBsYWluOiAnUGxhaW4gVGV4dCcsXG4gIHBvd2Vyc2hlbGw6ICdQb3dlclNoZWxsJyxcbiAgcHk6ICdQeXRob24nLFxuICBydXN0OiAnUnVzdCcsXG4gIHNxbDogJ1NRTCcsXG4gIHN3aWZ0OiAnU3dpZnQnLFxuICB0eXBlc2NyaXB0OiAnVHlwZVNjcmlwdCcsXG4gIHhtbDogJ1hNTCdcbn07XG5jb25zdCBDT0RFX0xBTkdVQUdFX01BUCA9IHtcbiAgY3BwOiAnY3BwJyxcbiAgamF2YTogJ2phdmEnLFxuICBqYXZhc2NyaXB0OiAnanMnLFxuICBtZDogJ21hcmtkb3duJyxcbiAgcGxhaW50ZXh0OiAncGxhaW4nLFxuICBweXRob246ICdweScsXG4gIHRleHQ6ICdwbGFpbicsXG4gIHRzOiAndHlwZXNjcmlwdCdcbn07XG5mdW5jdGlvbiBub3JtYWxpemVDb2RlTGFuZyhsYW5nKSB7XG4gIHJldHVybiBDT0RFX0xBTkdVQUdFX01BUFtsYW5nXSB8fCBsYW5nO1xufVxuZnVuY3Rpb24gZ2V0TGFuZ3VhZ2VGcmllbmRseU5hbWUobGFuZykge1xuICBjb25zdCBfbGFuZyA9IG5vcm1hbGl6ZUNvZGVMYW5nKGxhbmcpO1xuICByZXR1cm4gQ09ERV9MQU5HVUFHRV9GUklFTkRMWV9OQU1FX01BUFtfbGFuZ10gfHwgX2xhbmc7XG59XG5jb25zdCBnZXREZWZhdWx0Q29kZUxhbmd1YWdlID0gKCkgPT4gREVGQVVMVF9DT0RFX0xBTkdVQUdFO1xuY29uc3QgZ2V0Q29kZUxhbmd1YWdlcyA9ICgpID0+IE9iamVjdC5rZXlzKFByaXNtLmxhbmd1YWdlcykuZmlsdGVyKFxuLy8gUHJpc20gaGFzIHNldmVyYWwgbGFuZ3VhZ2UgaGVscGVycyBtaXhlZCBpbnRvIGxhbmd1YWdlcyBvYmplY3Rcbi8vIHNvIGZpbHRlcmluZyB0aGVtIG91dCBoZXJlIHRvIGdldCBsYW5ncyBsaXN0XG5sYW5ndWFnZSA9PiB0eXBlb2YgUHJpc20ubGFuZ3VhZ2VzW2xhbmd1YWdlXSAhPT0gJ2Z1bmN0aW9uJykuc29ydCgpO1xuXG4vKiogQG5vSW5oZXJpdERvYyAqL1xuY2xhc3MgQ29kZUhpZ2hsaWdodE5vZGUgZXh0ZW5kcyBUZXh0Tm9kZSB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICBjb25zdHJ1Y3Rvcih0ZXh0LCBoaWdobGlnaHRUeXBlLCBrZXkpIHtcbiAgICBzdXBlcih0ZXh0LCBrZXkpO1xuICAgIHRoaXMuX19oaWdobGlnaHRUeXBlID0gaGlnaGxpZ2h0VHlwZTtcbiAgfVxuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ2NvZGUtaGlnaGxpZ2h0JztcbiAgfVxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgQ29kZUhpZ2hsaWdodE5vZGUobm9kZS5fX3RleHQsIG5vZGUuX19oaWdobGlnaHRUeXBlIHx8IHVuZGVmaW5lZCwgbm9kZS5fX2tleSk7XG4gIH1cbiAgZ2V0SGlnaGxpZ2h0VHlwZSgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gc2VsZi5fX2hpZ2hsaWdodFR5cGU7XG4gIH1cbiAgY2FuSGF2ZUZvcm1hdCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY3JlYXRlRE9NKGNvbmZpZykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBzdXBlci5jcmVhdGVET00oY29uZmlnKTtcbiAgICBjb25zdCBjbGFzc05hbWUgPSBnZXRIaWdobGlnaHRUaGVtZUNsYXNzKGNvbmZpZy50aGVtZSwgdGhpcy5fX2hpZ2hsaWdodFR5cGUpO1xuICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgY2xhc3NOYW1lKTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICB1cGRhdGVET00ocHJldk5vZGUsIGRvbSwgY29uZmlnKSB7XG4gICAgY29uc3QgdXBkYXRlID0gc3VwZXIudXBkYXRlRE9NKHByZXZOb2RlLCBkb20sIGNvbmZpZyk7XG4gICAgY29uc3QgcHJldkNsYXNzTmFtZSA9IGdldEhpZ2hsaWdodFRoZW1lQ2xhc3MoY29uZmlnLnRoZW1lLCBwcmV2Tm9kZS5fX2hpZ2hsaWdodFR5cGUpO1xuICAgIGNvbnN0IG5leHRDbGFzc05hbWUgPSBnZXRIaWdobGlnaHRUaGVtZUNsYXNzKGNvbmZpZy50aGVtZSwgdGhpcy5fX2hpZ2hsaWdodFR5cGUpO1xuICAgIGlmIChwcmV2Q2xhc3NOYW1lICE9PSBuZXh0Q2xhc3NOYW1lKSB7XG4gICAgICBpZiAocHJldkNsYXNzTmFtZSkge1xuICAgICAgICByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQoZG9tLCBwcmV2Q2xhc3NOYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXh0Q2xhc3NOYW1lKSB7XG4gICAgICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZG9tLCBuZXh0Q2xhc3NOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVwZGF0ZTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIGNvbnN0IG5vZGUgPSAkY3JlYXRlQ29kZUhpZ2hsaWdodE5vZGUoc2VyaWFsaXplZE5vZGUudGV4dCwgc2VyaWFsaXplZE5vZGUuaGlnaGxpZ2h0VHlwZSk7XG4gICAgbm9kZS5zZXRGb3JtYXQoc2VyaWFsaXplZE5vZGUuZm9ybWF0KTtcbiAgICBub2RlLnNldERldGFpbChzZXJpYWxpemVkTm9kZS5kZXRhaWwpO1xuICAgIG5vZGUuc2V0TW9kZShzZXJpYWxpemVkTm9kZS5tb2RlKTtcbiAgICBub2RlLnNldFN0eWxlKHNlcmlhbGl6ZWROb2RlLnN0eWxlKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5leHBvcnRKU09OKCksXG4gICAgICBoaWdobGlnaHRUeXBlOiB0aGlzLmdldEhpZ2hsaWdodFR5cGUoKSxcbiAgICAgIHR5cGU6ICdjb2RlLWhpZ2hsaWdodCcsXG4gICAgICB2ZXJzaW9uOiAxXG4gICAgfTtcbiAgfVxuXG4gIC8vIFByZXZlbnQgZm9ybWF0dGluZyAoYm9sZCwgdW5kZXJsaW5lLCBldGMpXG4gIHNldEZvcm1hdChmb3JtYXQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpc1BhcmVudFJlcXVpcmVkKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNyZWF0ZVBhcmVudEVsZW1lbnROb2RlKCkge1xuICAgIHJldHVybiAkY3JlYXRlQ29kZU5vZGUoKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0SGlnaGxpZ2h0VGhlbWVDbGFzcyh0aGVtZSwgaGlnaGxpZ2h0VHlwZSkge1xuICByZXR1cm4gaGlnaGxpZ2h0VHlwZSAmJiB0aGVtZSAmJiB0aGVtZS5jb2RlSGlnaGxpZ2h0ICYmIHRoZW1lLmNvZGVIaWdobGlnaHRbaGlnaGxpZ2h0VHlwZV07XG59XG5mdW5jdGlvbiAkY3JlYXRlQ29kZUhpZ2hsaWdodE5vZGUodGV4dCwgaGlnaGxpZ2h0VHlwZSkge1xuICByZXR1cm4gJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBDb2RlSGlnaGxpZ2h0Tm9kZSh0ZXh0LCBoaWdobGlnaHRUeXBlKSk7XG59XG5mdW5jdGlvbiAkaXNDb2RlSGlnaGxpZ2h0Tm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgQ29kZUhpZ2hsaWdodE5vZGU7XG59XG5mdW5jdGlvbiBnZXRGaXJzdENvZGVOb2RlT2ZMaW5lKGFuY2hvcikge1xuICBsZXQgcHJldmlvdXNOb2RlID0gYW5jaG9yO1xuICBsZXQgbm9kZSA9IGFuY2hvcjtcbiAgd2hpbGUgKCRpc0NvZGVIaWdobGlnaHROb2RlKG5vZGUpIHx8ICRpc1RhYk5vZGUobm9kZSkpIHtcbiAgICBwcmV2aW91c05vZGUgPSBub2RlO1xuICAgIG5vZGUgPSBub2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICB9XG4gIHJldHVybiBwcmV2aW91c05vZGU7XG59XG5mdW5jdGlvbiBnZXRMYXN0Q29kZU5vZGVPZkxpbmUoYW5jaG9yKSB7XG4gIGxldCBuZXh0Tm9kZSA9IGFuY2hvcjtcbiAgbGV0IG5vZGUgPSBhbmNob3I7XG4gIHdoaWxlICgkaXNDb2RlSGlnaGxpZ2h0Tm9kZShub2RlKSB8fCAkaXNUYWJOb2RlKG5vZGUpKSB7XG4gICAgbmV4dE5vZGUgPSBub2RlO1xuICAgIG5vZGUgPSBub2RlLmdldE5leHRTaWJsaW5nKCk7XG4gIH1cbiAgcmV0dXJuIG5leHROb2RlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IFByaXNtVG9rZW5pemVyID0ge1xuICBkZWZhdWx0TGFuZ3VhZ2U6IERFRkFVTFRfQ09ERV9MQU5HVUFHRSxcbiAgdG9rZW5pemUoY29kZSwgbGFuZ3VhZ2UpIHtcbiAgICByZXR1cm4gUHJpc20udG9rZW5pemUoY29kZSwgUHJpc20ubGFuZ3VhZ2VzW2xhbmd1YWdlIHx8ICcnXSB8fCBQcmlzbS5sYW5ndWFnZXNbdGhpcy5kZWZhdWx0TGFuZ3VhZ2VdKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGdldFN0YXJ0T2ZDb2RlSW5MaW5lKGFuY2hvciwgb2Zmc2V0KSB7XG4gIGxldCBsYXN0ID0gbnVsbDtcbiAgbGV0IGxhc3ROb25CbGFuayA9IG51bGw7XG4gIGxldCBub2RlID0gYW5jaG9yO1xuICBsZXQgbm9kZU9mZnNldCA9IG9mZnNldDtcbiAgbGV0IG5vZGVUZXh0Q29udGVudCA9IGFuY2hvci5nZXRUZXh0Q29udGVudCgpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKG5vZGVPZmZzZXQgPT09IDApIHtcbiAgICAgIG5vZGUgPSBub2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgaWYgKG5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoISgkaXNDb2RlSGlnaGxpZ2h0Tm9kZShub2RlKSB8fCAkaXNUYWJOb2RlKG5vZGUpIHx8ICRpc0xpbmVCcmVha05vZGUobm9kZSkpKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBhIHZhbGlkIENvZGUgTm9kZTogQ29kZUhpZ2hsaWdodE5vZGUsIFRhYk5vZGUsIExpbmVCcmVha05vZGVgKTtcbiAgICAgIH1cbiAgICAgIGlmICgkaXNMaW5lQnJlYWtOb2RlKG5vZGUpKSB7XG4gICAgICAgIGxhc3QgPSB7XG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBvZmZzZXQ6IDFcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBub2RlT2Zmc2V0ID0gTWF0aC5tYXgoMCwgbm9kZS5nZXRUZXh0Q29udGVudFNpemUoKSAtIDEpO1xuICAgICAgbm9kZVRleHRDb250ZW50ID0gbm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlT2Zmc2V0LS07XG4gICAgfVxuICAgIGNvbnN0IGNoYXJhY3RlciA9IG5vZGVUZXh0Q29udGVudFtub2RlT2Zmc2V0XTtcbiAgICBpZiAoJGlzQ29kZUhpZ2hsaWdodE5vZGUobm9kZSkgJiYgY2hhcmFjdGVyICE9PSAnICcpIHtcbiAgICAgIGxhc3ROb25CbGFuayA9IHtcbiAgICAgICAgbm9kZSxcbiAgICAgICAgb2Zmc2V0OiBub2RlT2Zmc2V0XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAvLyBsYXN0Tm9uQmxhbmsgIT09IG51bGw6IGFuY2hvciBpbiB0aGUgbWlkZGxlIG9mIGNvZGU7IG1vdmUgdG8gbGluZSBiZWdpbm5pbmdcbiAgaWYgKGxhc3ROb25CbGFuayAhPT0gbnVsbCkge1xuICAgIHJldHVybiBsYXN0Tm9uQmxhbms7XG4gIH1cbiAgLy8gU3BhY2VzLCB0YWJzIG9yIG5vdGhpbmcgYWhlYWQgb2YgYW5jaG9yXG4gIGxldCBjb2RlQ2hhcmFjdGVyQXRBbmNob3JPZmZzZXQgPSBudWxsO1xuICBpZiAob2Zmc2V0IDwgYW5jaG9yLmdldFRleHRDb250ZW50U2l6ZSgpKSB7XG4gICAgaWYgKCRpc0NvZGVIaWdobGlnaHROb2RlKGFuY2hvcikpIHtcbiAgICAgIGNvZGVDaGFyYWN0ZXJBdEFuY2hvck9mZnNldCA9IGFuY2hvci5nZXRUZXh0Q29udGVudCgpW29mZnNldF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IG5leHRTaWJsaW5nID0gYW5jaG9yLmdldE5leHRTaWJsaW5nKCk7XG4gICAgaWYgKCRpc0NvZGVIaWdobGlnaHROb2RlKG5leHRTaWJsaW5nKSkge1xuICAgICAgY29kZUNoYXJhY3RlckF0QW5jaG9yT2Zmc2V0ID0gbmV4dFNpYmxpbmcuZ2V0VGV4dENvbnRlbnQoKVswXTtcbiAgICB9XG4gIH1cbiAgaWYgKGNvZGVDaGFyYWN0ZXJBdEFuY2hvck9mZnNldCAhPT0gbnVsbCAmJiBjb2RlQ2hhcmFjdGVyQXRBbmNob3JPZmZzZXQgIT09ICcgJykge1xuICAgIC8vIEJvcmRlcmxpbmUgd2hpdGVzcGFjZSBhbmQgY29kZSwgbW92ZSB0byBsaW5lIGJlZ2lubmluZ1xuICAgIHJldHVybiBsYXN0O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG5leHROb25CbGFuayA9IGZpbmROZXh0Tm9uQmxhbmtJbkxpbmUoYW5jaG9yLCBvZmZzZXQpO1xuICAgIGlmIChuZXh0Tm9uQmxhbmsgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBuZXh0Tm9uQmxhbms7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBsYXN0O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZmluZE5leHROb25CbGFua0luTGluZShhbmNob3IsIG9mZnNldCkge1xuICBsZXQgbm9kZSA9IGFuY2hvcjtcbiAgbGV0IG5vZGVPZmZzZXQgPSBvZmZzZXQ7XG4gIGxldCBub2RlVGV4dENvbnRlbnQgPSBhbmNob3IuZ2V0VGV4dENvbnRlbnQoKTtcbiAgbGV0IG5vZGVUZXh0Q29udGVudFNpemUgPSBhbmNob3IuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoISRpc0NvZGVIaWdobGlnaHROb2RlKG5vZGUpIHx8IG5vZGVPZmZzZXQgPT09IG5vZGVUZXh0Q29udGVudFNpemUpIHtcbiAgICAgIG5vZGUgPSBub2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgICBpZiAobm9kZSA9PT0gbnVsbCB8fCAkaXNMaW5lQnJlYWtOb2RlKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKCRpc0NvZGVIaWdobGlnaHROb2RlKG5vZGUpKSB7XG4gICAgICAgIG5vZGVPZmZzZXQgPSAwO1xuICAgICAgICBub2RlVGV4dENvbnRlbnQgPSBub2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgICAgIG5vZGVUZXh0Q29udGVudFNpemUgPSBub2RlLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoJGlzQ29kZUhpZ2hsaWdodE5vZGUobm9kZSkpIHtcbiAgICAgIGlmIChub2RlVGV4dENvbnRlbnRbbm9kZU9mZnNldF0gIT09ICcgJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgb2Zmc2V0OiBub2RlT2Zmc2V0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBub2RlT2Zmc2V0Kys7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRFbmRPZkNvZGVJbkxpbmUoYW5jaG9yKSB7XG4gIGNvbnN0IGxhc3ROb2RlID0gZ2V0TGFzdENvZGVOb2RlT2ZMaW5lKGFuY2hvcik7XG4gIGlmICghISRpc0xpbmVCcmVha05vZGUobGFzdE5vZGUpKSB7XG4gICAgdGhyb3cgRXJyb3IoYFVuZXhwZWN0ZWQgbGluZUJyZWFrTm9kZSBpbiBnZXRFbmRPZkNvZGVJbkxpbmVgKTtcbiAgfVxuICByZXR1cm4gbGFzdE5vZGU7XG59XG5mdW5jdGlvbiAkdGV4dE5vZGVUcmFuc2Zvcm0obm9kZSwgZWRpdG9yLCB0b2tlbml6ZXIpIHtcbiAgLy8gU2luY2UgQ29kZU5vZGUgaGFzIGZsYXQgY2hpbGRyZW4gc3RydWN0dXJlIHdlIG9ubHkgbmVlZCB0byBjaGVja1xuICAvLyBpZiBub2RlJ3MgcGFyZW50IGlzIGEgY29kZSBub2RlIGFuZCBydW4gaGlnaGxpZ2h0aW5nIGlmIHNvXG4gIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlLmdldFBhcmVudCgpO1xuICBpZiAoJGlzQ29kZU5vZGUocGFyZW50Tm9kZSkpIHtcbiAgICBjb2RlTm9kZVRyYW5zZm9ybShwYXJlbnROb2RlLCBlZGl0b3IsIHRva2VuaXplcik7XG4gIH0gZWxzZSBpZiAoJGlzQ29kZUhpZ2hsaWdodE5vZGUobm9kZSkpIHtcbiAgICAvLyBXaGVuIGNvZGUgYmxvY2sgY29udmVydGVkIGludG8gcGFyYWdyYXBoIG9yIG90aGVyIGVsZW1lbnRcbiAgICAvLyBjb2RlIGhpZ2hsaWdodCBub2RlcyBjb252ZXJ0ZWQgYmFjayB0byBub3JtYWwgdGV4dFxuICAgIG5vZGUucmVwbGFjZSgkY3JlYXRlVGV4dE5vZGUobm9kZS5fX3RleHQpKTtcbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlQ29kZUd1dHRlcihub2RlLCBlZGl0b3IpIHtcbiAgY29uc3QgY29kZUVsZW1lbnQgPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KG5vZGUuZ2V0S2V5KCkpO1xuICBpZiAoY29kZUVsZW1lbnQgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCk7XG4gIGNvbnN0IGNoaWxkcmVuTGVuZ3RoID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAvLyBAdHMtaWdub3JlOiBpbnRlcm5hbCBmaWVsZFxuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IGNvZGVFbGVtZW50Ll9fY2FjaGVkQ2hpbGRyZW5MZW5ndGgpIHtcbiAgICAvLyBBdm9pZCB1cGRhdGluZyB0aGUgYXR0cmlidXRlIGlmIHRoZSBjaGlsZHJlbiBsZW5ndGggaGFzbid0IGNoYW5nZWQuXG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIEB0cy1pZ25vcmU6OiBpbnRlcm5hbCBmaWVsZFxuICBjb2RlRWxlbWVudC5fX2NhY2hlZENoaWxkcmVuTGVuZ3RoID0gY2hpbGRyZW5MZW5ndGg7XG4gIGxldCBndXR0ZXIgPSAnMSc7XG4gIGxldCBjb3VudCA9IDE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgIGlmICgkaXNMaW5lQnJlYWtOb2RlKGNoaWxkcmVuW2ldKSkge1xuICAgICAgZ3V0dGVyICs9ICdcXG4nICsgKytjb3VudDtcbiAgICB9XG4gIH1cbiAgY29kZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLWd1dHRlcicsIGd1dHRlcik7XG59XG5cbi8vIFVzaW5nIGBza2lwVHJhbnNmb3Jtc2AgdG8gcHJldmVudCBleHRyYSB0cmFuc2Zvcm1zIHNpbmNlIHJlZm9ybWF0dGluZyB0aGUgY29kZVxuLy8gd2lsbCBub3QgYWZmZWN0IGNvZGUgYmxvY2sgY29udGVudCBpdHNlbGYuXG4vL1xuLy8gVXNpbmcgZXh0cmEgY2FjaGUgKGBub2Rlc0N1cnJlbnRseUhpZ2hsaWdodGluZ2ApIHNpbmNlIGJvdGggQ29kZU5vZGUgYW5kIENvZGVIaWdobGlnaHROb2RlXG4vLyB0cmFuc2Zvcm1zIG1pZ2h0IGJlIGNhbGxlZCBhdCB0aGUgc2FtZSB0aW1lIChlLmcuIG5ldyBDb2RlSGlnaGxpZ2h0IG5vZGUgaW5zZXJ0ZWQpIGFuZFxuLy8gaW4gYm90aCBjYXNlcyB3ZSdsbCByZXJ1biB3aG9sZSByZWZvcm1hdHRpbmcgb3ZlciBDb2RlTm9kZSwgd2hpY2ggaXMgcmVkdW5kYW50LlxuLy8gRXNwZWNpYWxseSB3aGVuIHBhc3RpbmcgY29kZSBpbnRvIENvZGVCbG9jay5cblxuY29uc3Qgbm9kZXNDdXJyZW50bHlIaWdobGlnaHRpbmcgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiBjb2RlTm9kZVRyYW5zZm9ybShub2RlLCBlZGl0b3IsIHRva2VuaXplcikge1xuICBjb25zdCBub2RlS2V5ID0gbm9kZS5nZXRLZXkoKTtcbiAgaWYgKG5vZGVzQ3VycmVudGx5SGlnaGxpZ2h0aW5nLmhhcyhub2RlS2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBub2Rlc0N1cnJlbnRseUhpZ2hsaWdodGluZy5hZGQobm9kZUtleSk7XG5cbiAgLy8gV2hlbiBuZXcgY29kZSBibG9jayBpbnNlcnRlZCBpdCBtaWdodCBub3QgaGF2ZSBsYW5ndWFnZSBzZWxlY3RlZFxuICBpZiAobm9kZS5nZXRMYW5ndWFnZSgpID09PSB1bmRlZmluZWQpIHtcbiAgICBub2RlLnNldExhbmd1YWdlKHRva2VuaXplci5kZWZhdWx0TGFuZ3VhZ2UpO1xuICB9XG5cbiAgLy8gVXNpbmcgbmVzdGVkIHVwZGF0ZSBjYWxsIHRvIHBhc3MgYHNraXBUcmFuc2Zvcm1zYCBzaW5jZSB3ZSBkb24ndCB3YW50XG4gIC8vIGVhY2ggaW5kaXZpZHVhbCBjb2RlaGlnaGxpZ2h0IG5vZGUgdG8gYmUgdHJhbnNmb3JtZWQgYWdhaW4gYXMgaXQncyBhbHJlYWR5XG4gIC8vIGluIGl0cyBmaW5hbCBzdGF0ZVxuICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAkdXBkYXRlQW5kUmV0YWluU2VsZWN0aW9uKG5vZGVLZXksICgpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnROb2RlID0gJGdldE5vZGVCeUtleShub2RlS2V5KTtcbiAgICAgIGlmICghJGlzQ29kZU5vZGUoY3VycmVudE5vZGUpIHx8ICFjdXJyZW50Tm9kZS5pc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgY29kZSA9IGN1cnJlbnROb2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgICBjb25zdCB0b2tlbnMgPSB0b2tlbml6ZXIudG9rZW5pemUoY29kZSwgY3VycmVudE5vZGUuZ2V0TGFuZ3VhZ2UoKSB8fCB0b2tlbml6ZXIuZGVmYXVsdExhbmd1YWdlKTtcbiAgICAgIGNvbnN0IGhpZ2hsaWdodE5vZGVzID0gJGdldEhpZ2hsaWdodE5vZGVzKHRva2Vucyk7XG4gICAgICBjb25zdCBkaWZmUmFuZ2UgPSBnZXREaWZmUmFuZ2UoY3VycmVudE5vZGUuZ2V0Q2hpbGRyZW4oKSwgaGlnaGxpZ2h0Tm9kZXMpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBmcm9tLFxuICAgICAgICB0byxcbiAgICAgICAgbm9kZXNGb3JSZXBsYWNlbWVudFxuICAgICAgfSA9IGRpZmZSYW5nZTtcbiAgICAgIGlmIChmcm9tICE9PSB0byB8fCBub2Rlc0ZvclJlcGxhY2VtZW50Lmxlbmd0aCkge1xuICAgICAgICBub2RlLnNwbGljZShmcm9tLCB0byAtIGZyb20sIG5vZGVzRm9yUmVwbGFjZW1lbnQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgfSwge1xuICAgIG9uVXBkYXRlOiAoKSA9PiB7XG4gICAgICBub2Rlc0N1cnJlbnRseUhpZ2hsaWdodGluZy5kZWxldGUobm9kZUtleSk7XG4gICAgfSxcbiAgICBza2lwVHJhbnNmb3JtczogdHJ1ZVxuICB9KTtcbn1cbmZ1bmN0aW9uICRnZXRIaWdobGlnaHROb2Rlcyh0b2tlbnMsIHR5cGUpIHtcbiAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgZm9yIChjb25zdCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgcGFydGlhbHMgPSB0b2tlbi5zcGxpdCgvKFxcbnxcXHQpLyk7XG4gICAgICBjb25zdCBwYXJ0aWFsc0xlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydGlhbHNMZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwYXJ0ID0gcGFydGlhbHNbaV07XG4gICAgICAgIGlmIChwYXJ0ID09PSAnXFxuJyB8fCBwYXJ0ID09PSAnXFxyXFxuJykge1xuICAgICAgICAgIG5vZGVzLnB1c2goJGNyZWF0ZUxpbmVCcmVha05vZGUoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJ1xcdCcpIHtcbiAgICAgICAgICBub2Rlcy5wdXNoKCRjcmVhdGVUYWJOb2RlKCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIG5vZGVzLnB1c2goJGNyZWF0ZUNvZGVIaWdobGlnaHROb2RlKHBhcnQsIHR5cGUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbnRlbnRcbiAgICAgIH0gPSB0b2tlbjtcbiAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbm9kZXMucHVzaCguLi4kZ2V0SGlnaGxpZ2h0Tm9kZXMoW2NvbnRlbnRdLCB0b2tlbi50eXBlKSk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY29udGVudCkpIHtcbiAgICAgICAgbm9kZXMucHVzaCguLi4kZ2V0SGlnaGxpZ2h0Tm9kZXMoY29udGVudCwgdG9rZW4udHlwZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbm9kZXM7XG59XG5cbi8vIFdyYXBwaW5nIHVwZGF0ZSBmdW5jdGlvbiBpbnRvIHNlbGVjdGlvbiByZXRhaW5lciwgdGhhdCB0cmllcyB0byBrZWVwIGN1cnNvciBhdCB0aGUgc2FtZVxuLy8gcG9zaXRpb24gYXMgYmVmb3JlLlxuZnVuY3Rpb24gJHVwZGF0ZUFuZFJldGFpblNlbGVjdGlvbihub2RlS2V5LCB1cGRhdGVGbikge1xuICBjb25zdCBub2RlID0gJGdldE5vZGVCeUtleShub2RlS2V5KTtcbiAgaWYgKCEkaXNDb2RlTm9kZShub2RlKSB8fCAhbm9kZS5pc0F0dGFjaGVkKCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAvLyBJZiBpdCdzIG5vdCByYW5nZSBzZWxlY3Rpb24gKG9yIG51bGwgc2VsZWN0aW9uKSB0aGVyZSdzIG5vIG5lZWQgdG8gY2hhbmdlIGl0LFxuICAvLyBidXQgd2UgY2FuIHN0aWxsIHJ1biBoaWdobGlnaHRpbmcgbG9naWNcbiAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgdXBkYXRlRm4oKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgY29uc3QgYW5jaG9yT2Zmc2V0ID0gYW5jaG9yLm9mZnNldDtcbiAgY29uc3QgaXNOZXdMaW5lQW5jaG9yID0gYW5jaG9yLnR5cGUgPT09ICdlbGVtZW50JyAmJiAkaXNMaW5lQnJlYWtOb2RlKG5vZGUuZ2V0Q2hpbGRBdEluZGV4KGFuY2hvci5vZmZzZXQgLSAxKSk7XG4gIGxldCB0ZXh0T2Zmc2V0ID0gMDtcblxuICAvLyBDYWxjdWxhdGluZyBwcmV2aW91cyB0ZXh0IG9mZnNldCAoYWxsIHRleHQgbm9kZSBwcmlvciB0byBhbmNob3IgKyBhbmNob3Igb3duIHRleHQgb2Zmc2V0KVxuICBpZiAoIWlzTmV3TGluZUFuY2hvcikge1xuICAgIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgIHRleHRPZmZzZXQgPSBhbmNob3JPZmZzZXQgKyBhbmNob3JOb2RlLmdldFByZXZpb3VzU2libGluZ3MoKS5yZWR1Y2UoKG9mZnNldCwgX25vZGUpID0+IHtcbiAgICAgIHJldHVybiBvZmZzZXQgKyBfbm9kZS5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgICB9LCAwKTtcbiAgfVxuICBjb25zdCBoYXNDaGFuZ2VzID0gdXBkYXRlRm4oKTtcbiAgaWYgKCFoYXNDaGFuZ2VzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gTm9uLXRleHQgYW5jaG9ycyBvbmx5IGhhcHBlbiBmb3IgbGluZSBicmVha3MsIG90aGVyd2lzZVxuICAvLyBzZWxlY3Rpb24gd2lsbCBiZSB3aXRoaW4gdGV4dCBub2RlIChjb2RlIGhpZ2hsaWdodCBub2RlKVxuICBpZiAoaXNOZXdMaW5lQW5jaG9yKSB7XG4gICAgYW5jaG9yLmdldE5vZGUoKS5zZWxlY3QoYW5jaG9yT2Zmc2V0LCBhbmNob3JPZmZzZXQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIElmIGl0IHdhcyBub24tZWxlbWVudCBhbmNob3IgdGhlbiB3ZSB3YWxrIHRocm91Z2ggY2hpbGQgbm9kZXNcbiAgLy8gYW5kIGxvb2tpbmcgZm9yIGEgcG9zaXRpb24gb2Ygb3JpZ2luYWwgdGV4dCBvZmZzZXRcbiAgbm9kZS5nZXRDaGlsZHJlbigpLnNvbWUoX25vZGUgPT4ge1xuICAgIGNvbnN0IGlzVGV4dCA9ICRpc1RleHROb2RlKF9ub2RlKTtcbiAgICBpZiAoaXNUZXh0IHx8ICRpc0xpbmVCcmVha05vZGUoX25vZGUpKSB7XG4gICAgICBjb25zdCB0ZXh0Q29udGVudFNpemUgPSBfbm9kZS5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgICAgIGlmIChpc1RleHQgJiYgdGV4dENvbnRlbnRTaXplID49IHRleHRPZmZzZXQpIHtcbiAgICAgICAgX25vZGUuc2VsZWN0KHRleHRPZmZzZXQsIHRleHRPZmZzZXQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRleHRPZmZzZXQgLT0gdGV4dENvbnRlbnRTaXplO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xufVxuXG4vLyBGaW5kcyBtaW5pbWFsIGRpZmYgcmFuZ2UgYmV0d2VlbiB0d28gbm9kZXMgbGlzdHMuIEl0IHJldHVybnMgZnJvbS90byByYW5nZSBib3VuZGFyaWVzIG9mIHByZXZOb2Rlc1xuLy8gdGhhdCBuZWVkcyB0byBiZSByZXBsYWNlZCB3aXRoIGBub2Rlc2AgKHN1YnNldCBvZiBuZXh0Tm9kZXMpIHRvIG1ha2UgcHJldk5vZGVzIGVxdWFsIHRvIG5leHROb2Rlcy5cbmZ1bmN0aW9uIGdldERpZmZSYW5nZShwcmV2Tm9kZXMsIG5leHROb2Rlcykge1xuICBsZXQgbGVhZGluZ01hdGNoID0gMDtcbiAgd2hpbGUgKGxlYWRpbmdNYXRjaCA8IHByZXZOb2Rlcy5sZW5ndGgpIHtcbiAgICBpZiAoIWlzRXF1YWwocHJldk5vZGVzW2xlYWRpbmdNYXRjaF0sIG5leHROb2Rlc1tsZWFkaW5nTWF0Y2hdKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxlYWRpbmdNYXRjaCsrO1xuICB9XG4gIGNvbnN0IHByZXZOb2Rlc0xlbmd0aCA9IHByZXZOb2Rlcy5sZW5ndGg7XG4gIGNvbnN0IG5leHROb2Rlc0xlbmd0aCA9IG5leHROb2Rlcy5sZW5ndGg7XG4gIGNvbnN0IG1heFRyYWlsaW5nTWF0Y2ggPSBNYXRoLm1pbihwcmV2Tm9kZXNMZW5ndGgsIG5leHROb2Rlc0xlbmd0aCkgLSBsZWFkaW5nTWF0Y2g7XG4gIGxldCB0cmFpbGluZ01hdGNoID0gMDtcbiAgd2hpbGUgKHRyYWlsaW5nTWF0Y2ggPCBtYXhUcmFpbGluZ01hdGNoKSB7XG4gICAgdHJhaWxpbmdNYXRjaCsrO1xuICAgIGlmICghaXNFcXVhbChwcmV2Tm9kZXNbcHJldk5vZGVzTGVuZ3RoIC0gdHJhaWxpbmdNYXRjaF0sIG5leHROb2Rlc1tuZXh0Tm9kZXNMZW5ndGggLSB0cmFpbGluZ01hdGNoXSkpIHtcbiAgICAgIHRyYWlsaW5nTWF0Y2gtLTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBjb25zdCBmcm9tID0gbGVhZGluZ01hdGNoO1xuICBjb25zdCB0byA9IHByZXZOb2Rlc0xlbmd0aCAtIHRyYWlsaW5nTWF0Y2g7XG4gIGNvbnN0IG5vZGVzRm9yUmVwbGFjZW1lbnQgPSBuZXh0Tm9kZXMuc2xpY2UobGVhZGluZ01hdGNoLCBuZXh0Tm9kZXNMZW5ndGggLSB0cmFpbGluZ01hdGNoKTtcbiAgcmV0dXJuIHtcbiAgICBmcm9tLFxuICAgIG5vZGVzRm9yUmVwbGFjZW1lbnQsXG4gICAgdG9cbiAgfTtcbn1cbmZ1bmN0aW9uIGlzRXF1YWwobm9kZUEsIG5vZGVCKSB7XG4gIC8vIE9ubHkgY2hlY2tpbmcgZm9yIGNvZGUgaGlnbGlnaHQgbm9kZXMsIHRhYnMgYW5kIGxpbmVicmVha3MuIElmIGl0J3MgcmVndWxhciB0ZXh0IG5vZGVcbiAgLy8gcmV0dXJuaW5nIGZhbHNlIHNvIHRoYXQgaXQncyB0cmFuc2Zvcm1lZCBpbnRvIGNvZGUgaGlnaGxpZ2h0IG5vZGVcbiAgcmV0dXJuICRpc0NvZGVIaWdobGlnaHROb2RlKG5vZGVBKSAmJiAkaXNDb2RlSGlnaGxpZ2h0Tm9kZShub2RlQikgJiYgbm9kZUEuX190ZXh0ID09PSBub2RlQi5fX3RleHQgJiYgbm9kZUEuX19oaWdobGlnaHRUeXBlID09PSBub2RlQi5fX2hpZ2hsaWdodFR5cGUgfHwgJGlzVGFiTm9kZShub2RlQSkgJiYgJGlzVGFiTm9kZShub2RlQikgfHwgJGlzTGluZUJyZWFrTm9kZShub2RlQSkgJiYgJGlzTGluZUJyZWFrTm9kZShub2RlQik7XG59XG5mdW5jdGlvbiAkaXNTZWxlY3Rpb25JbkNvZGUoc2VsZWN0aW9uKSB7XG4gIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCk7XG4gIGlmIChhbmNob3JOb2RlLmlzKGZvY3VzTm9kZSkgJiYgJGlzQ29kZU5vZGUoYW5jaG9yTm9kZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBhbmNob3JQYXJlbnQgPSBhbmNob3JOb2RlLmdldFBhcmVudCgpO1xuICByZXR1cm4gJGlzQ29kZU5vZGUoYW5jaG9yUGFyZW50KSAmJiBhbmNob3JQYXJlbnQuaXMoZm9jdXNOb2RlLmdldFBhcmVudCgpKTtcbn1cbmZ1bmN0aW9uICRnZXRDb2RlTGluZXMoc2VsZWN0aW9uKSB7XG4gIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gIGNvbnN0IGxpbmVzID0gW1tdXTtcbiAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMSAmJiAkaXNDb2RlTm9kZShub2Rlc1swXSkpIHtcbiAgICByZXR1cm4gbGluZXM7XG4gIH1cbiAgbGV0IGxhc3RMaW5lID0gbGluZXNbMF07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgaWYgKCEoJGlzQ29kZUhpZ2hsaWdodE5vZGUobm9kZSkgfHwgJGlzVGFiTm9kZShub2RlKSB8fCAkaXNMaW5lQnJlYWtOb2RlKG5vZGUpKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIHNlbGVjdGlvbiB0byBiZSBpbnNpZGUgQ29kZUJsb2NrIGFuZCBjb25zaXN0aW5nIG9mIENvZGVIaWdobGlnaHROb2RlLCBUYWJOb2RlIGFuZCBMaW5lQnJlYWtOb2RlYCk7XG4gICAgfVxuICAgIGlmICgkaXNMaW5lQnJlYWtOb2RlKG5vZGUpKSB7XG4gICAgICBpZiAoaSAhPT0gMCAmJiBsYXN0TGluZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxhc3RMaW5lID0gW107XG4gICAgICAgIGxpbmVzLnB1c2gobGFzdExpbmUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0TGluZS5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGluZXM7XG59XG5mdW5jdGlvbiAkaGFuZGxlVGFiKHNoaWZ0S2V5KSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICEkaXNTZWxlY3Rpb25JbkNvZGUoc2VsZWN0aW9uKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGluZGVudE9yT3V0ZGVudCA9ICFzaGlmdEtleSA/IElOREVOVF9DT05URU5UX0NPTU1BTkQgOiBPVVRERU5UX0NPTlRFTlRfQ09NTUFORDtcbiAgY29uc3QgdGFiT3JPdXRkZW50ID0gIXNoaWZ0S2V5ID8gSU5TRVJUX1RBQl9DT01NQU5EIDogT1VUREVOVF9DT05URU5UX0NPTU1BTkQ7XG4gIC8vIDEuIElmIG11bHRpcGxlIGxpbmVzIHNlbGVjdGVkOiBpbmRlbnQvb3V0ZGVudFxuICBjb25zdCBjb2RlTGluZXMgPSAkZ2V0Q29kZUxpbmVzKHNlbGVjdGlvbik7XG4gIGlmIChjb2RlTGluZXMubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiBpbmRlbnRPck91dGRlbnQ7XG4gIH1cbiAgLy8gMi4gSWYgZW50aXJlIGxpbmUgc2VsZWN0ZWQ6IGluZGVudC9vdXRkZW50XG4gIGNvbnN0IHNlbGVjdGlvbk5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gIGNvbnN0IGZpcnN0Tm9kZSA9IHNlbGVjdGlvbk5vZGVzWzBdO1xuICBpZiAoISgkaXNDb2RlTm9kZShmaXJzdE5vZGUpIHx8ICRpc0NvZGVIaWdobGlnaHROb2RlKGZpcnN0Tm9kZSkgfHwgJGlzVGFiTm9kZShmaXJzdE5vZGUpIHx8ICRpc0xpbmVCcmVha05vZGUoZmlyc3ROb2RlKSkpIHtcbiAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgc2VsZWN0aW9uIGZpcnN0Tm9kZSB0byBiZSBDb2RlSGlnaGxpZ2h0Tm9kZSBvciBUYWJOb2RlYCk7XG4gIH1cbiAgaWYgKCRpc0NvZGVOb2RlKGZpcnN0Tm9kZSkpIHtcbiAgICByZXR1cm4gaW5kZW50T3JPdXRkZW50O1xuICB9XG4gIGNvbnN0IGZpcnN0T2ZMaW5lID0gZ2V0Rmlyc3RDb2RlTm9kZU9mTGluZShmaXJzdE5vZGUpO1xuICBjb25zdCBsYXN0T2ZMaW5lID0gZ2V0TGFzdENvZGVOb2RlT2ZMaW5lKGZpcnN0Tm9kZSk7XG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICBsZXQgc2VsZWN0aW9uRmlyc3Q7XG4gIGxldCBzZWxlY3Rpb25MYXN0O1xuICBpZiAoZm9jdXMuaXNCZWZvcmUoYW5jaG9yKSkge1xuICAgIHNlbGVjdGlvbkZpcnN0ID0gZm9jdXM7XG4gICAgc2VsZWN0aW9uTGFzdCA9IGFuY2hvcjtcbiAgfSBlbHNlIHtcbiAgICBzZWxlY3Rpb25GaXJzdCA9IGFuY2hvcjtcbiAgICBzZWxlY3Rpb25MYXN0ID0gZm9jdXM7XG4gIH1cbiAgaWYgKGZpcnN0T2ZMaW5lICE9PSBudWxsICYmIGxhc3RPZkxpbmUgIT09IG51bGwgJiYgc2VsZWN0aW9uRmlyc3Qua2V5ID09PSBmaXJzdE9mTGluZS5nZXRLZXkoKSAmJiBzZWxlY3Rpb25GaXJzdC5vZmZzZXQgPT09IDAgJiYgc2VsZWN0aW9uTGFzdC5rZXkgPT09IGxhc3RPZkxpbmUuZ2V0S2V5KCkgJiYgc2VsZWN0aW9uTGFzdC5vZmZzZXQgPT09IGxhc3RPZkxpbmUuZ2V0VGV4dENvbnRlbnRTaXplKCkpIHtcbiAgICByZXR1cm4gaW5kZW50T3JPdXRkZW50O1xuICB9XG4gIC8vIDMuIEVsc2U6IHRhYi9vdXRkZW50XG4gIHJldHVybiB0YWJPck91dGRlbnQ7XG59XG5mdW5jdGlvbiAkaGFuZGxlTXVsdGlsaW5lSW5kZW50KHR5cGUpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgISRpc1NlbGVjdGlvbkluQ29kZShzZWxlY3Rpb24pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGNvZGVMaW5lcyA9ICRnZXRDb2RlTGluZXMoc2VsZWN0aW9uKTtcbiAgY29uc3QgY29kZUxpbmVzTGVuZ3RoID0gY29kZUxpbmVzLmxlbmd0aDtcbiAgLy8gTXVsdGlwbGUgbGluZXMgc2VsZWN0aW9uXG4gIGlmIChjb2RlTGluZXMubGVuZ3RoID4gMSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29kZUxpbmVzTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGxpbmUgPSBjb2RlTGluZXNbaV07XG4gICAgICBpZiAobGluZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxldCBmaXJzdE9mTGluZSA9IGxpbmVbMF07XG4gICAgICAgIC8vIEZpcnN0IGFuZCBsYXN0IGxpbmVzIG1pZ2h0IG5vdCBiZSBjb21wbGV0ZVxuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgIGZpcnN0T2ZMaW5lID0gZ2V0Rmlyc3RDb2RlTm9kZU9mTGluZShmaXJzdE9mTGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpcnN0T2ZMaW5lICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IElOREVOVF9DT05URU5UX0NPTU1BTkQpIHtcbiAgICAgICAgICAgIGZpcnN0T2ZMaW5lLmluc2VydEJlZm9yZSgkY3JlYXRlVGFiTm9kZSgpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCRpc1RhYk5vZGUoZmlyc3RPZkxpbmUpKSB7XG4gICAgICAgICAgICBmaXJzdE9mTGluZS5yZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gSnVzdCBvbmUgbGluZVxuICBjb25zdCBzZWxlY3Rpb25Ob2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICBjb25zdCBmaXJzdE5vZGUgPSBzZWxlY3Rpb25Ob2Rlc1swXTtcbiAgaWYgKCEoJGlzQ29kZU5vZGUoZmlyc3ROb2RlKSB8fCAkaXNDb2RlSGlnaGxpZ2h0Tm9kZShmaXJzdE5vZGUpIHx8ICRpc1RhYk5vZGUoZmlyc3ROb2RlKSB8fCAkaXNMaW5lQnJlYWtOb2RlKGZpcnN0Tm9kZSkpKSB7XG4gICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIHNlbGVjdGlvbiBmaXJzdE5vZGUgdG8gYmUgQ29kZUhpZ2hsaWdodE5vZGUgb3IgQ29kZVRhYk5vZGVgKTtcbiAgfVxuICBpZiAoJGlzQ29kZU5vZGUoZmlyc3ROb2RlKSkge1xuICAgIC8vIENvZGVOb2RlIGlzIGVtcHR5XG4gICAgaWYgKHR5cGUgPT09IElOREVOVF9DT05URU5UX0NPTU1BTkQpIHtcbiAgICAgIHNlbGVjdGlvbi5pbnNlcnROb2RlcyhbJGNyZWF0ZVRhYk5vZGUoKV0pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBmaXJzdE9mTGluZSA9IGdldEZpcnN0Q29kZU5vZGVPZkxpbmUoZmlyc3ROb2RlKTtcbiAgaWYgKCEoZmlyc3RPZkxpbmUgIT09IG51bGwpKSB7XG4gICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIGdldEZpcnN0Q29kZU5vZGVPZkxpbmUgdG8gcmV0dXJuIGEgdmFsaWQgQ29kZSBOb2RlYCk7XG4gIH1cbiAgaWYgKHR5cGUgPT09IElOREVOVF9DT05URU5UX0NPTU1BTkQpIHtcbiAgICBpZiAoJGlzTGluZUJyZWFrTm9kZShmaXJzdE9mTGluZSkpIHtcbiAgICAgIGZpcnN0T2ZMaW5lLmluc2VydEFmdGVyKCRjcmVhdGVUYWJOb2RlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaXJzdE9mTGluZS5pbnNlcnRCZWZvcmUoJGNyZWF0ZVRhYk5vZGUoKSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCRpc1RhYk5vZGUoZmlyc3RPZkxpbmUpKSB7XG4gICAgZmlyc3RPZkxpbmUucmVtb3ZlKCk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiAkaGFuZGxlU2hpZnRMaW5lcyh0eXBlLCBldmVudCkge1xuICAvLyBXZSBvbmx5IGNhcmUgYWJvdXQgdGhlIGFsdCthcnJvdyBrZXlzXG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gSSdtIG5vdCBxdWl0ZSBzdXJlIHdoeSwgYnV0IGl0IHNlZW1zIGxpa2UgY2FsbGluZyBhbmNob3IuZ2V0Tm9kZSgpIGNvbGxhcHNlcyB0aGUgc2VsZWN0aW9uIGhlcmVcbiAgLy8gU28gZmlyc3QsIGdldCB0aGUgYW5jaG9yIGFuZCB0aGUgZm9jdXMsIHRoZW4gZ2V0IHRoZWlyIG5vZGVzXG4gIGNvbnN0IHtcbiAgICBhbmNob3IsXG4gICAgZm9jdXNcbiAgfSA9IHNlbGVjdGlvbjtcbiAgY29uc3QgYW5jaG9yT2Zmc2V0ID0gYW5jaG9yLm9mZnNldDtcbiAgY29uc3QgZm9jdXNPZmZzZXQgPSBmb2N1cy5vZmZzZXQ7XG4gIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICBjb25zdCBmb2N1c05vZGUgPSBmb2N1cy5nZXROb2RlKCk7XG4gIGNvbnN0IGFycm93SXNVcCA9IHR5cGUgPT09IEtFWV9BUlJPV19VUF9DT01NQU5EO1xuXG4gIC8vIEVuc3VyZSB0aGUgc2VsZWN0aW9uIGlzIHdpdGhpbiB0aGUgY29kZWJsb2NrXG4gIGlmICghJGlzU2VsZWN0aW9uSW5Db2RlKHNlbGVjdGlvbikgfHwgISgkaXNDb2RlSGlnaGxpZ2h0Tm9kZShhbmNob3JOb2RlKSB8fCAkaXNUYWJOb2RlKGFuY2hvck5vZGUpKSB8fCAhKCRpc0NvZGVIaWdobGlnaHROb2RlKGZvY3VzTm9kZSkgfHwgJGlzVGFiTm9kZShmb2N1c05vZGUpKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIWV2ZW50LmFsdEtleSkge1xuICAgIC8vIEhhbmRsZSBtb3Zpbmcgc2VsZWN0aW9uIG91dCBvZiB0aGUgY29kZSBibG9jaywgZ2l2ZW4gdGhlcmUgYXJlIG5vXG4gICAgLy8gc2libGluZyB0aGF0cyBjYW4gbmF0aXZlbHkgdGFrZSB0aGUgc2VsZWN0aW9uLlxuICAgIGlmIChzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgY29uc3QgY29kZU5vZGUgPSBhbmNob3JOb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgIGlmIChhcnJvd0lzVXAgJiYgYW5jaG9yT2Zmc2V0ID09PSAwICYmIGFuY2hvck5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCkgPT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY29kZU5vZGVTaWJsaW5nID0gY29kZU5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICAgIGlmIChjb2RlTm9kZVNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgICBjb2RlTm9kZS5zZWxlY3RQcmV2aW91cygpO1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWFycm93SXNVcCAmJiBhbmNob3JPZmZzZXQgPT09IGFuY2hvck5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkgJiYgYW5jaG9yTm9kZS5nZXROZXh0U2libGluZygpID09PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGNvZGVOb2RlU2libGluZyA9IGNvZGVOb2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgICAgIGlmIChjb2RlTm9kZVNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgICBjb2RlTm9kZS5zZWxlY3ROZXh0KCk7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbGV0IHN0YXJ0O1xuICBsZXQgZW5kO1xuICBpZiAoYW5jaG9yTm9kZS5pc0JlZm9yZShmb2N1c05vZGUpKSB7XG4gICAgc3RhcnQgPSBnZXRGaXJzdENvZGVOb2RlT2ZMaW5lKGFuY2hvck5vZGUpO1xuICAgIGVuZCA9IGdldExhc3RDb2RlTm9kZU9mTGluZShmb2N1c05vZGUpO1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0ID0gZ2V0Rmlyc3RDb2RlTm9kZU9mTGluZShmb2N1c05vZGUpO1xuICAgIGVuZCA9IGdldExhc3RDb2RlTm9kZU9mTGluZShhbmNob3JOb2RlKTtcbiAgfVxuICBpZiAoc3RhcnQgPT0gbnVsbCB8fCBlbmQgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCByYW5nZSA9IHN0YXJ0LmdldE5vZGVzQmV0d2VlbihlbmQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IHJhbmdlW2ldO1xuICAgIGlmICghJGlzQ29kZUhpZ2hsaWdodE5vZGUobm9kZSkgJiYgISRpc1RhYk5vZGUobm9kZSkgJiYgISRpc0xpbmVCcmVha05vZGUobm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBBZnRlciB0aGlzIHBvaW50LCB3ZSBrbm93IHRoZSBzZWxlY3Rpb24gaXMgd2l0aGluIHRoZSBjb2RlYmxvY2suIFdlIG1heSBub3QgYmUgYWJsZSB0b1xuICAvLyBhY3R1YWxseSBtb3ZlIHRoZSBsaW5lcyBhcm91bmQsIGJ1dCB3ZSB3YW50IHRvIHJldHVybiB0cnVlIGVpdGhlciB3YXkgdG8gcHJldmVudFxuICAvLyB0aGUgZXZlbnQncyBkZWZhdWx0IGJlaGF2aW9yXG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOyAvLyByZXF1aXJlZCB0byBzdG9wIGN1cnNvciBtb3ZlbWVudCB1bmRlciBGaXJlZm94XG5cbiAgY29uc3QgbGluZWJyZWFrID0gYXJyb3dJc1VwID8gc3RhcnQuZ2V0UHJldmlvdXNTaWJsaW5nKCkgOiBlbmQuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgaWYgKCEkaXNMaW5lQnJlYWtOb2RlKGxpbmVicmVhaykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBzaWJsaW5nID0gYXJyb3dJc1VwID8gbGluZWJyZWFrLmdldFByZXZpb3VzU2libGluZygpIDogbGluZWJyZWFrLmdldE5leHRTaWJsaW5nKCk7XG4gIGlmIChzaWJsaW5nID09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBtYXliZUluc2VydGlvblBvaW50ID0gJGlzQ29kZUhpZ2hsaWdodE5vZGUoc2libGluZykgfHwgJGlzVGFiTm9kZShzaWJsaW5nKSB8fCAkaXNMaW5lQnJlYWtOb2RlKHNpYmxpbmcpID8gYXJyb3dJc1VwID8gZ2V0Rmlyc3RDb2RlTm9kZU9mTGluZShzaWJsaW5nKSA6IGdldExhc3RDb2RlTm9kZU9mTGluZShzaWJsaW5nKSA6IG51bGw7XG4gIGxldCBpbnNlcnRpb25Qb2ludCA9IG1heWJlSW5zZXJ0aW9uUG9pbnQgIT0gbnVsbCA/IG1heWJlSW5zZXJ0aW9uUG9pbnQgOiBzaWJsaW5nO1xuICBsaW5lYnJlYWsucmVtb3ZlKCk7XG4gIHJhbmdlLmZvckVhY2gobm9kZSA9PiBub2RlLnJlbW92ZSgpKTtcbiAgaWYgKHR5cGUgPT09IEtFWV9BUlJPV19VUF9DT01NQU5EKSB7XG4gICAgcmFuZ2UuZm9yRWFjaChub2RlID0+IGluc2VydGlvblBvaW50Lmluc2VydEJlZm9yZShub2RlKSk7XG4gICAgaW5zZXJ0aW9uUG9pbnQuaW5zZXJ0QmVmb3JlKGxpbmVicmVhayk7XG4gIH0gZWxzZSB7XG4gICAgaW5zZXJ0aW9uUG9pbnQuaW5zZXJ0QWZ0ZXIobGluZWJyZWFrKTtcbiAgICBpbnNlcnRpb25Qb2ludCA9IGxpbmVicmVhaztcbiAgICByYW5nZS5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgaW5zZXJ0aW9uUG9pbnQuaW5zZXJ0QWZ0ZXIobm9kZSk7XG4gICAgICBpbnNlcnRpb25Qb2ludCA9IG5vZGU7XG4gICAgfSk7XG4gIH1cbiAgc2VsZWN0aW9uLnNldFRleHROb2RlUmFuZ2UoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiAkaGFuZGxlTW92ZVRvKHR5cGUsIGV2ZW50KSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHtcbiAgICBhbmNob3IsXG4gICAgZm9jdXNcbiAgfSA9IHNlbGVjdGlvbjtcbiAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IGZvY3VzTm9kZSA9IGZvY3VzLmdldE5vZGUoKTtcbiAgY29uc3QgaXNNb3ZlVG9TdGFydCA9IHR5cGUgPT09IE1PVkVfVE9fU1RBUlQ7XG5cbiAgLy8gRW5zdXJlIHRoZSBzZWxlY3Rpb24gaXMgd2l0aGluIHRoZSBjb2RlYmxvY2tcbiAgaWYgKCEkaXNTZWxlY3Rpb25JbkNvZGUoc2VsZWN0aW9uKSB8fCAhKCRpc0NvZGVIaWdobGlnaHROb2RlKGFuY2hvck5vZGUpIHx8ICRpc1RhYk5vZGUoYW5jaG9yTm9kZSkpIHx8ICEoJGlzQ29kZUhpZ2hsaWdodE5vZGUoZm9jdXNOb2RlKSB8fCAkaXNUYWJOb2RlKGZvY3VzTm9kZSkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChpc01vdmVUb1N0YXJ0KSB7XG4gICAgY29uc3Qgc3RhcnQgPSBnZXRTdGFydE9mQ29kZUluTGluZShmb2N1c05vZGUsIGZvY3VzLm9mZnNldCk7XG4gICAgaWYgKHN0YXJ0ICE9PSBudWxsKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5vZGUsXG4gICAgICAgIG9mZnNldFxuICAgICAgfSA9IHN0YXJ0O1xuICAgICAgaWYgKCRpc0xpbmVCcmVha05vZGUobm9kZSkpIHtcbiAgICAgICAgbm9kZS5zZWxlY3ROZXh0KDAsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZWN0aW9uLnNldFRleHROb2RlUmFuZ2Uobm9kZSwgb2Zmc2V0LCBub2RlLCBvZmZzZXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb2N1c05vZGUuZ2V0UGFyZW50T3JUaHJvdygpLnNlbGVjdFN0YXJ0KCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IG5vZGUgPSBnZXRFbmRPZkNvZGVJbkxpbmUoZm9jdXNOb2RlKTtcbiAgICBub2RlLnNlbGVjdCgpO1xuICB9XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyQ29kZUhpZ2hsaWdodGluZyhlZGl0b3IsIHRva2VuaXplcikge1xuICBpZiAoIWVkaXRvci5oYXNOb2RlcyhbQ29kZU5vZGUsIENvZGVIaWdobGlnaHROb2RlXSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVIaWdobGlnaHRQbHVnaW46IENvZGVOb2RlIG9yIENvZGVIaWdobGlnaHROb2RlIG5vdCByZWdpc3RlcmVkIG9uIGVkaXRvcicpO1xuICB9XG4gIGlmICh0b2tlbml6ZXIgPT0gbnVsbCkge1xuICAgIHRva2VuaXplciA9IFByaXNtVG9rZW5pemVyO1xuICB9XG4gIHJldHVybiBtZXJnZVJlZ2lzdGVyKGVkaXRvci5yZWdpc3Rlck11dGF0aW9uTGlzdGVuZXIoQ29kZU5vZGUsIG11dGF0aW9ucyA9PiB7XG4gICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHR5cGVdIG9mIG11dGF0aW9ucykge1xuICAgICAgICBpZiAodHlwZSAhPT0gJ2Rlc3Ryb3llZCcpIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gJGdldE5vZGVCeUtleShrZXkpO1xuICAgICAgICAgIGlmIChub2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB1cGRhdGVDb2RlR3V0dGVyKG5vZGUsIGVkaXRvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIHtcbiAgICBza2lwSW5pdGlhbGl6YXRpb246IGZhbHNlXG4gIH0pLCBlZGl0b3IucmVnaXN0ZXJOb2RlVHJhbnNmb3JtKENvZGVOb2RlLCBub2RlID0+IGNvZGVOb2RlVHJhbnNmb3JtKG5vZGUsIGVkaXRvciwgdG9rZW5pemVyKSksIGVkaXRvci5yZWdpc3Rlck5vZGVUcmFuc2Zvcm0oVGV4dE5vZGUsIG5vZGUgPT4gJHRleHROb2RlVHJhbnNmb3JtKG5vZGUsIGVkaXRvciwgdG9rZW5pemVyKSksIGVkaXRvci5yZWdpc3Rlck5vZGVUcmFuc2Zvcm0oQ29kZUhpZ2hsaWdodE5vZGUsIG5vZGUgPT4gJHRleHROb2RlVHJhbnNmb3JtKG5vZGUsIGVkaXRvciwgdG9rZW5pemVyKSksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoS0VZX1RBQl9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3QgY29tbWFuZCA9ICRoYW5kbGVUYWIoZXZlbnQuc2hpZnRLZXkpO1xuICAgIGlmIChjb21tYW5kID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChjb21tYW5kLCB1bmRlZmluZWQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoSU5TRVJUX1RBQl9DT01NQU5ELCAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzU2VsZWN0aW9uSW5Db2RlKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgJGluc2VydE5vZGVzKFskY3JlYXRlVGFiTm9kZSgpXSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChJTkRFTlRfQ09OVEVOVF9DT01NQU5ELCBwYXlsb2FkID0+ICRoYW5kbGVNdWx0aWxpbmVJbmRlbnQoSU5ERU5UX0NPTlRFTlRfQ09NTUFORCksIENPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChPVVRERU5UX0NPTlRFTlRfQ09NTUFORCwgcGF5bG9hZCA9PiAkaGFuZGxlTXVsdGlsaW5lSW5kZW50KE9VVERFTlRfQ09OVEVOVF9DT01NQU5EKSwgQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9BUlJPV19VUF9DT01NQU5ELCBwYXlsb2FkID0+ICRoYW5kbGVTaGlmdExpbmVzKEtFWV9BUlJPV19VUF9DT01NQU5ELCBwYXlsb2FkKSwgQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9BUlJPV19ET1dOX0NPTU1BTkQsIHBheWxvYWQgPT4gJGhhbmRsZVNoaWZ0TGluZXMoS0VZX0FSUk9XX0RPV05fQ09NTUFORCwgcGF5bG9hZCksIENPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChNT1ZFX1RPX0VORCwgcGF5bG9hZCA9PiAkaGFuZGxlTW92ZVRvKE1PVkVfVE9fRU5ELCBwYXlsb2FkKSwgQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKE1PVkVfVE9fU1RBUlQsIHBheWxvYWQgPT4gJGhhbmRsZU1vdmVUbyhNT1ZFX1RPX1NUQVJULCBwYXlsb2FkKSwgQ09NTUFORF9QUklPUklUWV9MT1cpKTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5leHBvcnQgeyAkY3JlYXRlQ29kZUhpZ2hsaWdodE5vZGUsICRjcmVhdGVDb2RlTm9kZSwgJGlzQ29kZUhpZ2hsaWdodE5vZGUsICRpc0NvZGVOb2RlLCBDT0RFX0xBTkdVQUdFX0ZSSUVORExZX05BTUVfTUFQLCBDT0RFX0xBTkdVQUdFX01BUCwgQ29kZUhpZ2hsaWdodE5vZGUsIENvZGVOb2RlLCBERUZBVUxUX0NPREVfTEFOR1VBR0UsIFByaXNtVG9rZW5pemVyLCBnZXRDb2RlTGFuZ3VhZ2VzLCBnZXREZWZhdWx0Q29kZUxhbmd1YWdlLCBnZXRFbmRPZkNvZGVJbkxpbmUsIGdldEZpcnN0Q29kZU5vZGVPZkxpbmUsIGdldExhbmd1YWdlRnJpZW5kbHlOYW1lLCBnZXRMYXN0Q29kZU5vZGVPZkxpbmUsIGdldFN0YXJ0T2ZDb2RlSW5MaW5lLCBub3JtYWxpemVDb2RlTGFuZywgcmVnaXN0ZXJDb2RlSGlnaGxpZ2h0aW5nIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@lexical+code@0.20.0/node_modules/@lexical/code/LexicalCode.dev.mjs\n");

/***/ })

};
;
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-diff-viewer-continued@3.2.6_react-dom@19.0.0-rc-65a56d0e-20241020_react@19.0.0-rc-65a56_bap3tgyykoeu7fuj346m5txpry";
exports.ids = ["vendor-chunks/react-diff-viewer-continued@3.2.6_react-dom@19.0.0-rc-65a56d0e-20241020_react@19.0.0-rc-65a56_bap3tgyykoeu7fuj346m5txpry"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/react-diff-viewer-continued@3.2.6_react-dom@19.0.0-rc-65a56d0e-20241020_react@19.0.0-rc-65a56_bap3tgyykoeu7fuj346m5txpry/node_modules/react-diff-viewer-continued/lib/compute-lines.js":
/*!*******************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/react-diff-viewer-continued@3.2.6_react-dom@19.0.0-rc-65a56d0e-20241020_react@19.0.0-rc-65a56_bap3tgyykoeu7fuj346m5txpry/node_modules/react-diff-viewer-continued/lib/compute-lines.js ***!
  \*******************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.computeLineInformation = exports.DiffMethod = exports.DiffType = void 0;\nconst diff = __webpack_require__(/*! diff */ \"(ssr)/./node_modules/.pnpm/diff@5.2.0/node_modules/diff/lib/index.js\");\nconst jsDiff = diff;\nvar DiffType;\n(function (DiffType) {\n    DiffType[DiffType[\"DEFAULT\"] = 0] = \"DEFAULT\";\n    DiffType[DiffType[\"ADDED\"] = 1] = \"ADDED\";\n    DiffType[DiffType[\"REMOVED\"] = 2] = \"REMOVED\";\n    DiffType[DiffType[\"CHANGED\"] = 3] = \"CHANGED\";\n})(DiffType = exports.DiffType || (exports.DiffType = {}));\n// See https://github.com/kpdecker/jsdiff/tree/v4.0.1#api for more info on the below JsDiff methods\nvar DiffMethod;\n(function (DiffMethod) {\n    DiffMethod[\"CHARS\"] = \"diffChars\";\n    DiffMethod[\"WORDS\"] = \"diffWords\";\n    DiffMethod[\"WORDS_WITH_SPACE\"] = \"diffWordsWithSpace\";\n    DiffMethod[\"LINES\"] = \"diffLines\";\n    DiffMethod[\"TRIMMED_LINES\"] = \"diffTrimmedLines\";\n    DiffMethod[\"SENTENCES\"] = \"diffSentences\";\n    DiffMethod[\"CSS\"] = \"diffCss\";\n    DiffMethod[\"JSON\"] = \"diffJson\";\n})(DiffMethod = exports.DiffMethod || (exports.DiffMethod = {}));\n/**\n * Splits diff text by new line and computes final list of diff lines based on\n * conditions.\n *\n * @param value Diff text from the js diff module.\n */\nconst constructLines = (value) => {\n    if (value === '')\n        return [];\n    const lines = value.replace(/\\n$/, '').split('\\n');\n    return lines;\n};\n/**\n * Computes word diff information in the line.\n * [TODO]: Consider adding options argument for JsDiff text block comparison\n *\n * @param oldValue Old word in the line.\n * @param newValue New word in the line.\n * @param compareMethod JsDiff text diff method from https://github.com/kpdecker/jsdiff/tree/v4.0.1#api\n */\nconst computeDiff = (oldValue, newValue, compareMethod = DiffMethod.CHARS) => {\n    const diffArray = jsDiff[compareMethod](oldValue, newValue);\n    const computedDiff = {\n        left: [],\n        right: [],\n    };\n    diffArray.forEach(({ added, removed, value }) => {\n        const diffInformation = {};\n        if (added) {\n            diffInformation.type = DiffType.ADDED;\n            diffInformation.value = value;\n            computedDiff.right.push(diffInformation);\n        }\n        if (removed) {\n            diffInformation.type = DiffType.REMOVED;\n            diffInformation.value = value;\n            computedDiff.left.push(diffInformation);\n        }\n        if (!removed && !added) {\n            diffInformation.type = DiffType.DEFAULT;\n            diffInformation.value = value;\n            computedDiff.right.push(diffInformation);\n            computedDiff.left.push(diffInformation);\n        }\n        return diffInformation;\n    });\n    return computedDiff;\n};\n/**\n * [TODO]: Think about moving common left and right value assignment to a\n * common place. Better readability?\n *\n * Computes line wise information based in the js diff information passed. Each\n * line contains information about left and right section. Left side denotes\n * deletion and right side denotes addition.\n *\n * @param oldString Old string to compare.\n * @param newString New string to compare with old string.\n * @param disableWordDiff Flag to enable/disable word diff.\n * @param lineCompareMethod JsDiff text diff method from https://github.com/kpdecker/jsdiff/tree/v4.0.1#api\n * @param linesOffset line number to start counting from\n */\nconst computeLineInformation = (oldString, newString, disableWordDiff = false, lineCompareMethod = DiffMethod.CHARS, linesOffset = 0) => {\n    let diffArray = [];\n    // Use diffLines for strings, and diffJson for objects...\n    if (typeof oldString === 'string' && typeof newString === 'string') {\n        diffArray = diff.diffLines(oldString.trimRight(), newString.trimRight(), {\n            newlineIsToken: false,\n            ignoreWhitespace: false,\n            ignoreCase: false,\n        });\n    }\n    else {\n        diffArray = diff.diffJson(oldString, newString);\n    }\n    let rightLineNumber = linesOffset;\n    let leftLineNumber = linesOffset;\n    let lineInformation = [];\n    let counter = 0;\n    const diffLines = [];\n    const ignoreDiffIndexes = [];\n    const getLineInformation = (value, diffIndex, added, removed, evaluateOnlyFirstLine) => {\n        const lines = constructLines(value);\n        return lines\n            .map((line, lineIndex) => {\n            const left = {};\n            const right = {};\n            if (ignoreDiffIndexes.includes(`${diffIndex}-${lineIndex}`) ||\n                (evaluateOnlyFirstLine && lineIndex !== 0)) {\n                return undefined;\n            }\n            if (added || removed) {\n                let countAsChange = true;\n                if (removed) {\n                    leftLineNumber += 1;\n                    left.lineNumber = leftLineNumber;\n                    left.type = DiffType.REMOVED;\n                    left.value = line || ' ';\n                    // When the current line is of type REMOVED, check the next item in\n                    // the diff array whether it is of type ADDED. If true, the current\n                    // diff will be marked as both REMOVED and ADDED. Meaning, the\n                    // current line is a modification.\n                    const nextDiff = diffArray[diffIndex + 1];\n                    if (nextDiff && nextDiff.added) {\n                        const nextDiffLines = constructLines(nextDiff.value)[lineIndex];\n                        if (nextDiffLines) {\n                            const nextDiffLineInfo = getLineInformation(nextDiffLines, diffIndex, true, false, true);\n                            const { value: rightValue, lineNumber, type, } = nextDiffLineInfo[0].right;\n                            // When identified as modification, push the next diff to ignore\n                            // list as the next value will be added in this line computation as\n                            // right and left values.\n                            ignoreDiffIndexes.push(`${diffIndex + 1}-${lineIndex}`);\n                            right.lineNumber = lineNumber;\n                            if (left.value === rightValue) {\n                                // The new value is exactly the same as the old\n                                countAsChange = false;\n                                right.type = 0;\n                                left.type = 0;\n                                right.value = rightValue;\n                            }\n                            else {\n                                right.type = type;\n                                // Do char level diff and assign the corresponding values to the\n                                // left and right diff information object.\n                                if (disableWordDiff) {\n                                    right.value = rightValue;\n                                }\n                                else {\n                                    const computedDiff = computeDiff(line, rightValue, lineCompareMethod);\n                                    right.value = computedDiff.right;\n                                    left.value = computedDiff.left;\n                                }\n                            }\n                        }\n                    }\n                }\n                else {\n                    rightLineNumber += 1;\n                    right.lineNumber = rightLineNumber;\n                    right.type = DiffType.ADDED;\n                    right.value = line;\n                }\n                if (countAsChange && !evaluateOnlyFirstLine) {\n                    if (!diffLines.includes(counter)) {\n                        diffLines.push(counter);\n                    }\n                }\n            }\n            else {\n                leftLineNumber += 1;\n                rightLineNumber += 1;\n                left.lineNumber = leftLineNumber;\n                left.type = DiffType.DEFAULT;\n                left.value = line;\n                right.lineNumber = rightLineNumber;\n                right.type = DiffType.DEFAULT;\n                right.value = line;\n            }\n            if (!evaluateOnlyFirstLine) {\n                counter += 1;\n            }\n            return { right, left };\n        })\n            .filter(Boolean);\n    };\n    diffArray.forEach(({ added, removed, value }, index) => {\n        lineInformation = [\n            ...lineInformation,\n            ...getLineInformation(value, index, added, removed),\n        ];\n    });\n    return {\n        lineInformation,\n        diffLines,\n    };\n};\nexports.computeLineInformation = computeLineInformation;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtZGlmZi12aWV3ZXItY29udGludWVkQDMuMi42X3JlYWN0LWRvbUAxOS4wLjAtcmMtNjVhNTZkMGUtMjAyNDEwMjBfcmVhY3RAMTkuMC4wLXJjLTY1YTU2X2JhcDN0Z3l5a29ldTdmdWozNDZtNXR4cHJ5L25vZGVfbW9kdWxlcy9yZWFjdC1kaWZmLXZpZXdlci1jb250aW51ZWQvbGliL2NvbXB1dGUtbGluZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsOEJBQThCLEdBQUcsa0JBQWtCLEdBQUcsZ0JBQWdCO0FBQ3RFLGFBQWEsbUJBQU8sQ0FBQyxrRkFBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDLGdCQUFnQixLQUFLO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQyxrQkFBa0IsS0FBSztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFVBQVUsR0FBRyxVQUFVO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHVDQUF1QztBQUMzRTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsY0FBYyxHQUFHLFVBQVU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNUO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZXNzb24tYXV0aG9yaW5nLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LWRpZmYtdmlld2VyLWNvbnRpbnVlZEAzLjIuNl9yZWFjdC1kb21AMTkuMC4wLXJjLTY1YTU2ZDBlLTIwMjQxMDIwX3JlYWN0QDE5LjAuMC1yYy02NWE1Nl9iYXAzdGd5eWtvZXU3ZnVqMzQ2bTV0eHByeS9ub2RlX21vZHVsZXMvcmVhY3QtZGlmZi12aWV3ZXItY29udGludWVkL2xpYi9jb21wdXRlLWxpbmVzLmpzPzBiYmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbXB1dGVMaW5lSW5mb3JtYXRpb24gPSBleHBvcnRzLkRpZmZNZXRob2QgPSBleHBvcnRzLkRpZmZUeXBlID0gdm9pZCAwO1xuY29uc3QgZGlmZiA9IHJlcXVpcmUoXCJkaWZmXCIpO1xuY29uc3QganNEaWZmID0gZGlmZjtcbnZhciBEaWZmVHlwZTtcbihmdW5jdGlvbiAoRGlmZlR5cGUpIHtcbiAgICBEaWZmVHlwZVtEaWZmVHlwZVtcIkRFRkFVTFRcIl0gPSAwXSA9IFwiREVGQVVMVFwiO1xuICAgIERpZmZUeXBlW0RpZmZUeXBlW1wiQURERURcIl0gPSAxXSA9IFwiQURERURcIjtcbiAgICBEaWZmVHlwZVtEaWZmVHlwZVtcIlJFTU9WRURcIl0gPSAyXSA9IFwiUkVNT1ZFRFwiO1xuICAgIERpZmZUeXBlW0RpZmZUeXBlW1wiQ0hBTkdFRFwiXSA9IDNdID0gXCJDSEFOR0VEXCI7XG59KShEaWZmVHlwZSA9IGV4cG9ydHMuRGlmZlR5cGUgfHwgKGV4cG9ydHMuRGlmZlR5cGUgPSB7fSkpO1xuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9rcGRlY2tlci9qc2RpZmYvdHJlZS92NC4wLjEjYXBpIGZvciBtb3JlIGluZm8gb24gdGhlIGJlbG93IEpzRGlmZiBtZXRob2RzXG52YXIgRGlmZk1ldGhvZDtcbihmdW5jdGlvbiAoRGlmZk1ldGhvZCkge1xuICAgIERpZmZNZXRob2RbXCJDSEFSU1wiXSA9IFwiZGlmZkNoYXJzXCI7XG4gICAgRGlmZk1ldGhvZFtcIldPUkRTXCJdID0gXCJkaWZmV29yZHNcIjtcbiAgICBEaWZmTWV0aG9kW1wiV09SRFNfV0lUSF9TUEFDRVwiXSA9IFwiZGlmZldvcmRzV2l0aFNwYWNlXCI7XG4gICAgRGlmZk1ldGhvZFtcIkxJTkVTXCJdID0gXCJkaWZmTGluZXNcIjtcbiAgICBEaWZmTWV0aG9kW1wiVFJJTU1FRF9MSU5FU1wiXSA9IFwiZGlmZlRyaW1tZWRMaW5lc1wiO1xuICAgIERpZmZNZXRob2RbXCJTRU5URU5DRVNcIl0gPSBcImRpZmZTZW50ZW5jZXNcIjtcbiAgICBEaWZmTWV0aG9kW1wiQ1NTXCJdID0gXCJkaWZmQ3NzXCI7XG4gICAgRGlmZk1ldGhvZFtcIkpTT05cIl0gPSBcImRpZmZKc29uXCI7XG59KShEaWZmTWV0aG9kID0gZXhwb3J0cy5EaWZmTWV0aG9kIHx8IChleHBvcnRzLkRpZmZNZXRob2QgPSB7fSkpO1xuLyoqXG4gKiBTcGxpdHMgZGlmZiB0ZXh0IGJ5IG5ldyBsaW5lIGFuZCBjb21wdXRlcyBmaW5hbCBsaXN0IG9mIGRpZmYgbGluZXMgYmFzZWQgb25cbiAqIGNvbmRpdGlvbnMuXG4gKlxuICogQHBhcmFtIHZhbHVlIERpZmYgdGV4dCBmcm9tIHRoZSBqcyBkaWZmIG1vZHVsZS5cbiAqL1xuY29uc3QgY29uc3RydWN0TGluZXMgPSAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT09ICcnKVxuICAgICAgICByZXR1cm4gW107XG4gICAgY29uc3QgbGluZXMgPSB2YWx1ZS5yZXBsYWNlKC9cXG4kLywgJycpLnNwbGl0KCdcXG4nKTtcbiAgICByZXR1cm4gbGluZXM7XG59O1xuLyoqXG4gKiBDb21wdXRlcyB3b3JkIGRpZmYgaW5mb3JtYXRpb24gaW4gdGhlIGxpbmUuXG4gKiBbVE9ET106IENvbnNpZGVyIGFkZGluZyBvcHRpb25zIGFyZ3VtZW50IGZvciBKc0RpZmYgdGV4dCBibG9jayBjb21wYXJpc29uXG4gKlxuICogQHBhcmFtIG9sZFZhbHVlIE9sZCB3b3JkIGluIHRoZSBsaW5lLlxuICogQHBhcmFtIG5ld1ZhbHVlIE5ldyB3b3JkIGluIHRoZSBsaW5lLlxuICogQHBhcmFtIGNvbXBhcmVNZXRob2QgSnNEaWZmIHRleHQgZGlmZiBtZXRob2QgZnJvbSBodHRwczovL2dpdGh1Yi5jb20va3BkZWNrZXIvanNkaWZmL3RyZWUvdjQuMC4xI2FwaVxuICovXG5jb25zdCBjb21wdXRlRGlmZiA9IChvbGRWYWx1ZSwgbmV3VmFsdWUsIGNvbXBhcmVNZXRob2QgPSBEaWZmTWV0aG9kLkNIQVJTKSA9PiB7XG4gICAgY29uc3QgZGlmZkFycmF5ID0ganNEaWZmW2NvbXBhcmVNZXRob2RdKG9sZFZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgY29uc3QgY29tcHV0ZWREaWZmID0ge1xuICAgICAgICBsZWZ0OiBbXSxcbiAgICAgICAgcmlnaHQ6IFtdLFxuICAgIH07XG4gICAgZGlmZkFycmF5LmZvckVhY2goKHsgYWRkZWQsIHJlbW92ZWQsIHZhbHVlIH0pID0+IHtcbiAgICAgICAgY29uc3QgZGlmZkluZm9ybWF0aW9uID0ge307XG4gICAgICAgIGlmIChhZGRlZCkge1xuICAgICAgICAgICAgZGlmZkluZm9ybWF0aW9uLnR5cGUgPSBEaWZmVHlwZS5BRERFRDtcbiAgICAgICAgICAgIGRpZmZJbmZvcm1hdGlvbi52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgY29tcHV0ZWREaWZmLnJpZ2h0LnB1c2goZGlmZkluZm9ybWF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgICAgICAgZGlmZkluZm9ybWF0aW9uLnR5cGUgPSBEaWZmVHlwZS5SRU1PVkVEO1xuICAgICAgICAgICAgZGlmZkluZm9ybWF0aW9uLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBjb21wdXRlZERpZmYubGVmdC5wdXNoKGRpZmZJbmZvcm1hdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZW1vdmVkICYmICFhZGRlZCkge1xuICAgICAgICAgICAgZGlmZkluZm9ybWF0aW9uLnR5cGUgPSBEaWZmVHlwZS5ERUZBVUxUO1xuICAgICAgICAgICAgZGlmZkluZm9ybWF0aW9uLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBjb21wdXRlZERpZmYucmlnaHQucHVzaChkaWZmSW5mb3JtYXRpb24pO1xuICAgICAgICAgICAgY29tcHV0ZWREaWZmLmxlZnQucHVzaChkaWZmSW5mb3JtYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWZmSW5mb3JtYXRpb247XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbXB1dGVkRGlmZjtcbn07XG4vKipcbiAqIFtUT0RPXTogVGhpbmsgYWJvdXQgbW92aW5nIGNvbW1vbiBsZWZ0IGFuZCByaWdodCB2YWx1ZSBhc3NpZ25tZW50IHRvIGFcbiAqIGNvbW1vbiBwbGFjZS4gQmV0dGVyIHJlYWRhYmlsaXR5P1xuICpcbiAqIENvbXB1dGVzIGxpbmUgd2lzZSBpbmZvcm1hdGlvbiBiYXNlZCBpbiB0aGUganMgZGlmZiBpbmZvcm1hdGlvbiBwYXNzZWQuIEVhY2hcbiAqIGxpbmUgY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgbGVmdCBhbmQgcmlnaHQgc2VjdGlvbi4gTGVmdCBzaWRlIGRlbm90ZXNcbiAqIGRlbGV0aW9uIGFuZCByaWdodCBzaWRlIGRlbm90ZXMgYWRkaXRpb24uXG4gKlxuICogQHBhcmFtIG9sZFN0cmluZyBPbGQgc3RyaW5nIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0gbmV3U3RyaW5nIE5ldyBzdHJpbmcgdG8gY29tcGFyZSB3aXRoIG9sZCBzdHJpbmcuXG4gKiBAcGFyYW0gZGlzYWJsZVdvcmREaWZmIEZsYWcgdG8gZW5hYmxlL2Rpc2FibGUgd29yZCBkaWZmLlxuICogQHBhcmFtIGxpbmVDb21wYXJlTWV0aG9kIEpzRGlmZiB0ZXh0IGRpZmYgbWV0aG9kIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2twZGVja2VyL2pzZGlmZi90cmVlL3Y0LjAuMSNhcGlcbiAqIEBwYXJhbSBsaW5lc09mZnNldCBsaW5lIG51bWJlciB0byBzdGFydCBjb3VudGluZyBmcm9tXG4gKi9cbmNvbnN0IGNvbXB1dGVMaW5lSW5mb3JtYXRpb24gPSAob2xkU3RyaW5nLCBuZXdTdHJpbmcsIGRpc2FibGVXb3JkRGlmZiA9IGZhbHNlLCBsaW5lQ29tcGFyZU1ldGhvZCA9IERpZmZNZXRob2QuQ0hBUlMsIGxpbmVzT2Zmc2V0ID0gMCkgPT4ge1xuICAgIGxldCBkaWZmQXJyYXkgPSBbXTtcbiAgICAvLyBVc2UgZGlmZkxpbmVzIGZvciBzdHJpbmdzLCBhbmQgZGlmZkpzb24gZm9yIG9iamVjdHMuLi5cbiAgICBpZiAodHlwZW9mIG9sZFN0cmluZyA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIG5ld1N0cmluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZGlmZkFycmF5ID0gZGlmZi5kaWZmTGluZXMob2xkU3RyaW5nLnRyaW1SaWdodCgpLCBuZXdTdHJpbmcudHJpbVJpZ2h0KCksIHtcbiAgICAgICAgICAgIG5ld2xpbmVJc1Rva2VuOiBmYWxzZSxcbiAgICAgICAgICAgIGlnbm9yZVdoaXRlc3BhY2U6IGZhbHNlLFxuICAgICAgICAgICAgaWdub3JlQ2FzZTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGlmZkFycmF5ID0gZGlmZi5kaWZmSnNvbihvbGRTdHJpbmcsIG5ld1N0cmluZyk7XG4gICAgfVxuICAgIGxldCByaWdodExpbmVOdW1iZXIgPSBsaW5lc09mZnNldDtcbiAgICBsZXQgbGVmdExpbmVOdW1iZXIgPSBsaW5lc09mZnNldDtcbiAgICBsZXQgbGluZUluZm9ybWF0aW9uID0gW107XG4gICAgbGV0IGNvdW50ZXIgPSAwO1xuICAgIGNvbnN0IGRpZmZMaW5lcyA9IFtdO1xuICAgIGNvbnN0IGlnbm9yZURpZmZJbmRleGVzID0gW107XG4gICAgY29uc3QgZ2V0TGluZUluZm9ybWF0aW9uID0gKHZhbHVlLCBkaWZmSW5kZXgsIGFkZGVkLCByZW1vdmVkLCBldmFsdWF0ZU9ubHlGaXJzdExpbmUpID0+IHtcbiAgICAgICAgY29uc3QgbGluZXMgPSBjb25zdHJ1Y3RMaW5lcyh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBsaW5lc1xuICAgICAgICAgICAgLm1hcCgobGluZSwgbGluZUluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0ge307XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHt9O1xuICAgICAgICAgICAgaWYgKGlnbm9yZURpZmZJbmRleGVzLmluY2x1ZGVzKGAke2RpZmZJbmRleH0tJHtsaW5lSW5kZXh9YCkgfHxcbiAgICAgICAgICAgICAgICAoZXZhbHVhdGVPbmx5Rmlyc3RMaW5lICYmIGxpbmVJbmRleCAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFkZGVkIHx8IHJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgY291bnRBc0NoYW5nZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdExpbmVOdW1iZXIgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdC5saW5lTnVtYmVyID0gbGVmdExpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQudHlwZSA9IERpZmZUeXBlLlJFTU9WRUQ7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQudmFsdWUgPSBsaW5lIHx8ICcgJztcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgY3VycmVudCBsaW5lIGlzIG9mIHR5cGUgUkVNT1ZFRCwgY2hlY2sgdGhlIG5leHQgaXRlbSBpblxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZGlmZiBhcnJheSB3aGV0aGVyIGl0IGlzIG9mIHR5cGUgQURERUQuIElmIHRydWUsIHRoZSBjdXJyZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIGRpZmYgd2lsbCBiZSBtYXJrZWQgYXMgYm90aCBSRU1PVkVEIGFuZCBBRERFRC4gTWVhbmluZywgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgbGluZSBpcyBhIG1vZGlmaWNhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dERpZmYgPSBkaWZmQXJyYXlbZGlmZkluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0RGlmZiAmJiBuZXh0RGlmZi5hZGRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dERpZmZMaW5lcyA9IGNvbnN0cnVjdExpbmVzKG5leHREaWZmLnZhbHVlKVtsaW5lSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHREaWZmTGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0RGlmZkxpbmVJbmZvID0gZ2V0TGluZUluZm9ybWF0aW9uKG5leHREaWZmTGluZXMsIGRpZmZJbmRleCwgdHJ1ZSwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdmFsdWU6IHJpZ2h0VmFsdWUsIGxpbmVOdW1iZXIsIHR5cGUsIH0gPSBuZXh0RGlmZkxpbmVJbmZvWzBdLnJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gaWRlbnRpZmllZCBhcyBtb2RpZmljYXRpb24sIHB1c2ggdGhlIG5leHQgZGlmZiB0byBpZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsaXN0IGFzIHRoZSBuZXh0IHZhbHVlIHdpbGwgYmUgYWRkZWQgaW4gdGhpcyBsaW5lIGNvbXB1dGF0aW9uIGFzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmlnaHQgYW5kIGxlZnQgdmFsdWVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlnbm9yZURpZmZJbmRleGVzLnB1c2goYCR7ZGlmZkluZGV4ICsgMX0tJHtsaW5lSW5kZXh9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQubGluZU51bWJlciA9IGxpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQudmFsdWUgPT09IHJpZ2h0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG5ldyB2YWx1ZSBpcyBleGFjdGx5IHRoZSBzYW1lIGFzIHRoZSBvbGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnRBc0NoYW5nZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodC50eXBlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdC50eXBlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQudmFsdWUgPSByaWdodFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQudHlwZSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvIGNoYXIgbGV2ZWwgZGlmZiBhbmQgYXNzaWduIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcyB0byB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGVmdCBhbmQgcmlnaHQgZGlmZiBpbmZvcm1hdGlvbiBvYmplY3QuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXNhYmxlV29yZERpZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0LnZhbHVlID0gcmlnaHRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXB1dGVkRGlmZiA9IGNvbXB1dGVEaWZmKGxpbmUsIHJpZ2h0VmFsdWUsIGxpbmVDb21wYXJlTWV0aG9kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0LnZhbHVlID0gY29tcHV0ZWREaWZmLnJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdC52YWx1ZSA9IGNvbXB1dGVkRGlmZi5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByaWdodExpbmVOdW1iZXIgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQubGluZU51bWJlciA9IHJpZ2h0TGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQudHlwZSA9IERpZmZUeXBlLkFEREVEO1xuICAgICAgICAgICAgICAgICAgICByaWdodC52YWx1ZSA9IGxpbmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb3VudEFzQ2hhbmdlICYmICFldmFsdWF0ZU9ubHlGaXJzdExpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkaWZmTGluZXMuaW5jbHVkZXMoY291bnRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZMaW5lcy5wdXNoKGNvdW50ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGVmdExpbmVOdW1iZXIgKz0gMTtcbiAgICAgICAgICAgICAgICByaWdodExpbmVOdW1iZXIgKz0gMTtcbiAgICAgICAgICAgICAgICBsZWZ0LmxpbmVOdW1iZXIgPSBsZWZ0TGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICBsZWZ0LnR5cGUgPSBEaWZmVHlwZS5ERUZBVUxUO1xuICAgICAgICAgICAgICAgIGxlZnQudmFsdWUgPSBsaW5lO1xuICAgICAgICAgICAgICAgIHJpZ2h0LmxpbmVOdW1iZXIgPSByaWdodExpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgcmlnaHQudHlwZSA9IERpZmZUeXBlLkRFRkFVTFQ7XG4gICAgICAgICAgICAgICAgcmlnaHQudmFsdWUgPSBsaW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFldmFsdWF0ZU9ubHlGaXJzdExpbmUpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyByaWdodCwgbGVmdCB9O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcihCb29sZWFuKTtcbiAgICB9O1xuICAgIGRpZmZBcnJheS5mb3JFYWNoKCh7IGFkZGVkLCByZW1vdmVkLCB2YWx1ZSB9LCBpbmRleCkgPT4ge1xuICAgICAgICBsaW5lSW5mb3JtYXRpb24gPSBbXG4gICAgICAgICAgICAuLi5saW5lSW5mb3JtYXRpb24sXG4gICAgICAgICAgICAuLi5nZXRMaW5lSW5mb3JtYXRpb24odmFsdWUsIGluZGV4LCBhZGRlZCwgcmVtb3ZlZCksXG4gICAgICAgIF07XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGluZUluZm9ybWF0aW9uLFxuICAgICAgICBkaWZmTGluZXMsXG4gICAgfTtcbn07XG5leHBvcnRzLmNvbXB1dGVMaW5lSW5mb3JtYXRpb24gPSBjb21wdXRlTGluZUluZm9ybWF0aW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/react-diff-viewer-continued@3.2.6_react-dom@19.0.0-rc-65a56d0e-20241020_react@19.0.0-rc-65a56_bap3tgyykoeu7fuj346m5txpry/node_modules/react-diff-viewer-continued/lib/compute-lines.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/react-diff-viewer-continued@3.2.6_react-dom@19.0.0-rc-65a56d0e-20241020_react@19.0.0-rc-65a56_bap3tgyykoeu7fuj346m5txpry/node_modules/react-diff-viewer-continued/lib/index.js":
/*!***********************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/react-diff-viewer-continued@3.2.6_react-dom@19.0.0-rc-65a56d0e-20241020_react@19.0.0-rc-65a56_bap3tgyykoeu7fuj346m5txpry/node_modules/react-diff-viewer-continued/lib/index.js ***!
  \***********************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DiffMethod = exports.LineNumberPrefix = void 0;\nconst React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/.pnpm/next@15.0.0_@babel+core@7.26.0_react-dom@19.0.0-rc-65a56d0e-20241020_react@19.0.0-rc-65a56d0e_nethbh5cqcrw7fiqieqg7ifc64/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\nconst PropTypes = __webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/index.js\");\nconst classnames_1 = __webpack_require__(/*! classnames */ \"(ssr)/./node_modules/.pnpm/classnames@2.5.1/node_modules/classnames/index.js\");\nconst compute_lines_1 = __webpack_require__(/*! ./compute-lines */ \"(ssr)/./node_modules/.pnpm/react-diff-viewer-continued@3.2.6_react-dom@19.0.0-rc-65a56d0e-20241020_react@19.0.0-rc-65a56_bap3tgyykoeu7fuj346m5txpry/node_modules/react-diff-viewer-continued/lib/compute-lines.js\");\nObject.defineProperty(exports, \"DiffMethod\", ({ enumerable: true, get: function () { return compute_lines_1.DiffMethod; } }));\nconst styles_1 = __webpack_require__(/*! ./styles */ \"(ssr)/./node_modules/.pnpm/react-diff-viewer-continued@3.2.6_react-dom@19.0.0-rc-65a56d0e-20241020_react@19.0.0-rc-65a56_bap3tgyykoeu7fuj346m5txpry/node_modules/react-diff-viewer-continued/lib/styles.js\");\nconst m = __webpack_require__(/*! memoize-one */ \"(ssr)/./node_modules/.pnpm/memoize-one@6.0.0/node_modules/memoize-one/dist/memoize-one.esm.js\");\nconst memoize = m.default || m;\nvar LineNumberPrefix;\n(function (LineNumberPrefix) {\n    LineNumberPrefix[\"LEFT\"] = \"L\";\n    LineNumberPrefix[\"RIGHT\"] = \"R\";\n})(LineNumberPrefix = exports.LineNumberPrefix || (exports.LineNumberPrefix = {}));\nclass DiffViewer extends React.Component {\n    constructor(props) {\n        super(props);\n        /**\n         * Resets code block expand to the initial stage. Will be exposed to the parent component via\n         * refs.\n         */\n        this.resetCodeBlocks = () => {\n            if (this.state.expandedBlocks.length > 0) {\n                this.setState({\n                    expandedBlocks: [],\n                });\n                return true;\n            }\n            return false;\n        };\n        /**\n         * Pushes the target expanded code block to the state. During the re-render,\n         * this value is used to expand/fold unmodified code.\n         */\n        this.onBlockExpand = (id) => {\n            const prevState = this.state.expandedBlocks.slice();\n            prevState.push(id);\n            this.setState({\n                expandedBlocks: prevState,\n            });\n        };\n        /**\n         * Computes final styles for the diff viewer. It combines the default styles with the user\n         * supplied overrides. The computed styles are cached with performance in mind.\n         *\n         * @param styles User supplied style overrides.\n         */\n        this.computeStyles = memoize(styles_1.default);\n        /**\n         * Returns a function with clicked line number in the closure. Returns an no-op function when no\n         * onLineNumberClick handler is supplied.\n         *\n         * @param id Line id of a line.\n         */\n        this.onLineNumberClickProxy = (id) => {\n            if (this.props.onLineNumberClick) {\n                return (e) => this.props.onLineNumberClick(id, e);\n            }\n            return () => { };\n        };\n        /**\n         * Maps over the word diff and constructs the required React elements to show word diff.\n         *\n         * @param diffArray Word diff information derived from line information.\n         * @param renderer Optional renderer to format diff words. Useful for syntax highlighting.\n         */\n        this.renderWordDiff = (diffArray, renderer) => {\n            return diffArray.map((wordDiff, i) => {\n                return (React.createElement(\"span\", { key: i, className: (0, classnames_1.default)(this.styles.wordDiff, {\n                        [this.styles.wordAdded]: wordDiff.type === compute_lines_1.DiffType.ADDED,\n                        [this.styles.wordRemoved]: wordDiff.type === compute_lines_1.DiffType.REMOVED,\n                    }) }, renderer ? renderer(wordDiff.value) : wordDiff.value));\n            });\n        };\n        /**\n         * Maps over the line diff and constructs the required react elements to show line diff. It calls\n         * renderWordDiff when encountering word diff. This takes care of both inline and split view line\n         * renders.\n         *\n         * @param lineNumber Line number of the current line.\n         * @param type Type of diff of the current line.\n         * @param prefix Unique id to prefix with the line numbers.\n         * @param value Content of the line. It can be a string or a word diff array.\n         * @param additionalLineNumber Additional line number to be shown. Useful for rendering inline\n         *  diff view. Right line number will be passed as additionalLineNumber.\n         * @param additionalPrefix Similar to prefix but for additional line number.\n         */\n        this.renderLine = (lineNumber, type, prefix, value, additionalLineNumber, additionalPrefix) => {\n            const lineNumberTemplate = `${prefix}-${lineNumber}`;\n            const additionalLineNumberTemplate = `${additionalPrefix}-${additionalLineNumber}`;\n            const highlightLine = this.props.highlightLines.includes(lineNumberTemplate) ||\n                this.props.highlightLines.includes(additionalLineNumberTemplate);\n            const added = type === compute_lines_1.DiffType.ADDED;\n            const removed = type === compute_lines_1.DiffType.REMOVED;\n            const changed = type === compute_lines_1.DiffType.CHANGED;\n            let content;\n            if (Array.isArray(value)) {\n                content = this.renderWordDiff(value, this.props.renderContent);\n            }\n            else if (this.props.renderContent) {\n                content = this.props.renderContent(value);\n            }\n            else {\n                content = value;\n            }\n            return (React.createElement(React.Fragment, null,\n                !this.props.hideLineNumbers && (React.createElement(\"td\", { onClick: lineNumber && this.onLineNumberClickProxy(lineNumberTemplate), className: (0, classnames_1.default)(this.styles.gutter, {\n                        [this.styles.emptyGutter]: !lineNumber,\n                        [this.styles.diffAdded]: added,\n                        [this.styles.diffRemoved]: removed,\n                        [this.styles.diffChanged]: changed,\n                        [this.styles.highlightedGutter]: highlightLine,\n                    }) },\n                    React.createElement(\"pre\", { className: this.styles.lineNumber }, lineNumber))),\n                !this.props.splitView && !this.props.hideLineNumbers && (React.createElement(\"td\", { onClick: additionalLineNumber &&\n                        this.onLineNumberClickProxy(additionalLineNumberTemplate), className: (0, classnames_1.default)(this.styles.gutter, {\n                        [this.styles.emptyGutter]: !additionalLineNumber,\n                        [this.styles.diffAdded]: added,\n                        [this.styles.diffRemoved]: removed,\n                        [this.styles.diffChanged]: changed,\n                        [this.styles.highlightedGutter]: highlightLine,\n                    }) },\n                    React.createElement(\"pre\", { className: this.styles.lineNumber }, additionalLineNumber))),\n                this.props.renderGutter\n                    ? this.props.renderGutter({\n                        lineNumber,\n                        type,\n                        prefix,\n                        value,\n                        additionalLineNumber,\n                        additionalPrefix,\n                        styles: this.styles,\n                    })\n                    : null,\n                React.createElement(\"td\", { className: (0, classnames_1.default)(this.styles.marker, {\n                        [this.styles.emptyLine]: !content,\n                        [this.styles.diffAdded]: added,\n                        [this.styles.diffRemoved]: removed,\n                        [this.styles.diffChanged]: changed,\n                        [this.styles.highlightedLine]: highlightLine,\n                    }) },\n                    React.createElement(\"pre\", null,\n                        added && '+',\n                        removed && '-')),\n                React.createElement(\"td\", { className: (0, classnames_1.default)(this.styles.content, {\n                        [this.styles.emptyLine]: !content,\n                        [this.styles.diffAdded]: added,\n                        [this.styles.diffRemoved]: removed,\n                        [this.styles.diffChanged]: changed,\n                        [this.styles.highlightedLine]: highlightLine,\n                    }) },\n                    React.createElement(\"pre\", { className: this.styles.contentText }, content))));\n        };\n        /**\n         * Generates lines for split view.\n         *\n         * @param obj Line diff information.\n         * @param obj.left Life diff information for the left pane of the split view.\n         * @param obj.right Life diff information for the right pane of the split view.\n         * @param index React key for the lines.\n         */\n        this.renderSplitView = ({ left, right }, index) => {\n            return (React.createElement(\"tr\", { key: index, className: this.styles.line },\n                this.renderLine(left.lineNumber, left.type, LineNumberPrefix.LEFT, left.value),\n                this.renderLine(right.lineNumber, right.type, LineNumberPrefix.RIGHT, right.value)));\n        };\n        /**\n         * Generates lines for inline view.\n         *\n         * @param obj Line diff information.\n         * @param obj.left Life diff information for the added section of the inline view.\n         * @param obj.right Life diff information for the removed section of the inline view.\n         * @param index React key for the lines.\n         */\n        this.renderInlineView = ({ left, right }, index) => {\n            let content;\n            if (left.type === compute_lines_1.DiffType.REMOVED && right.type === compute_lines_1.DiffType.ADDED) {\n                return (React.createElement(React.Fragment, { key: index },\n                    React.createElement(\"tr\", { className: this.styles.line }, this.renderLine(left.lineNumber, left.type, LineNumberPrefix.LEFT, left.value, null)),\n                    React.createElement(\"tr\", { className: this.styles.line }, this.renderLine(null, right.type, LineNumberPrefix.RIGHT, right.value, right.lineNumber))));\n            }\n            if (left.type === compute_lines_1.DiffType.REMOVED) {\n                content = this.renderLine(left.lineNumber, left.type, LineNumberPrefix.LEFT, left.value, null);\n            }\n            if (left.type === compute_lines_1.DiffType.DEFAULT) {\n                content = this.renderLine(left.lineNumber, left.type, LineNumberPrefix.LEFT, left.value, right.lineNumber, LineNumberPrefix.RIGHT);\n            }\n            if (right.type === compute_lines_1.DiffType.ADDED) {\n                content = this.renderLine(null, right.type, LineNumberPrefix.RIGHT, right.value, right.lineNumber);\n            }\n            return (React.createElement(\"tr\", { key: index, className: this.styles.line }, content));\n        };\n        /**\n         * Returns a function with clicked block number in the closure.\n         *\n         * @param id Cold fold block id.\n         */\n        this.onBlockClickProxy = (id) => () => this.onBlockExpand(id);\n        /**\n         * Generates cold fold block. It also uses the custom message renderer when available to show\n         * cold fold messages.\n         *\n         * @param num Number of skipped lines between two blocks.\n         * @param blockNumber Code fold block id.\n         * @param leftBlockLineNumber First left line number after the current code fold block.\n         * @param rightBlockLineNumber First right line number after the current code fold block.\n         */\n        this.renderSkippedLineIndicator = (num, blockNumber, leftBlockLineNumber, rightBlockLineNumber) => {\n            const { hideLineNumbers, splitView } = this.props;\n            const message = this.props.codeFoldMessageRenderer ? (this.props.codeFoldMessageRenderer(num, leftBlockLineNumber, rightBlockLineNumber)) : (React.createElement(\"pre\", { className: this.styles.codeFoldContent },\n                \"Expand \",\n                num,\n                \" lines ...\"));\n            const content = (React.createElement(\"td\", null,\n                React.createElement(\"a\", { onClick: this.onBlockClickProxy(blockNumber), tabIndex: 0 }, message)));\n            const isUnifiedViewWithoutLineNumbers = !splitView && !hideLineNumbers;\n            return (React.createElement(\"tr\", { key: `${leftBlockLineNumber}-${rightBlockLineNumber}`, className: this.styles.codeFold },\n                !hideLineNumbers && React.createElement(\"td\", { className: this.styles.codeFoldGutter }),\n                this.props.renderGutter ? (React.createElement(\"td\", { className: this.styles.codeFoldGutter })) : null,\n                React.createElement(\"td\", { className: (0, classnames_1.default)({\n                        [this.styles.codeFoldGutter]: isUnifiedViewWithoutLineNumbers,\n                    }) }),\n                isUnifiedViewWithoutLineNumbers ? (React.createElement(React.Fragment, null,\n                    React.createElement(\"td\", null),\n                    content)) : (React.createElement(React.Fragment, null,\n                    content,\n                    this.props.renderGutter ? React.createElement(\"td\", null) : null,\n                    React.createElement(\"td\", null))),\n                React.createElement(\"td\", null),\n                React.createElement(\"td\", null)));\n        };\n        /**\n         * Generates the entire diff view.\n         */\n        this.renderDiff = () => {\n            const { oldValue, newValue, splitView, disableWordDiff, compareMethod, linesOffset, } = this.props;\n            const { lineInformation, diffLines } = (0, compute_lines_1.computeLineInformation)(oldValue, newValue, disableWordDiff, compareMethod, linesOffset);\n            const extraLines = this.props.extraLinesSurroundingDiff < 0\n                ? 0\n                : this.props.extraLinesSurroundingDiff;\n            let skippedLines = [];\n            return lineInformation.map((line, i) => {\n                const diffBlockStart = diffLines[0];\n                const currentPosition = diffBlockStart - i;\n                if (this.props.showDiffOnly) {\n                    if (currentPosition === -extraLines) {\n                        skippedLines = [];\n                        diffLines.shift();\n                    }\n                    if (line.left.type === compute_lines_1.DiffType.DEFAULT &&\n                        (currentPosition > extraLines ||\n                            typeof diffBlockStart === 'undefined') &&\n                        !this.state.expandedBlocks.includes(diffBlockStart)) {\n                        skippedLines.push(i + 1);\n                        // show skipped line indicator only if there is more than one line to hide\n                        if (i === lineInformation.length - 1 && skippedLines.length > 1) {\n                            return this.renderSkippedLineIndicator(skippedLines.length, diffBlockStart, line.left.lineNumber, line.right.lineNumber);\n                            // if we are trying to hide the last line, just show it\n                        }\n                        else if (i < lineInformation.length - 1) {\n                            return null;\n                        }\n                    }\n                }\n                const diffNodes = splitView\n                    ? this.renderSplitView(line, i)\n                    : this.renderInlineView(line, i);\n                if (currentPosition === extraLines && skippedLines.length > 0) {\n                    const { length } = skippedLines;\n                    skippedLines = [];\n                    return (React.createElement(React.Fragment, { key: i },\n                        this.renderSkippedLineIndicator(length, diffBlockStart, line.left.lineNumber, line.right.lineNumber),\n                        diffNodes));\n                }\n                return diffNodes;\n            });\n        };\n        this.render = () => {\n            const { oldValue, newValue, useDarkTheme, leftTitle, rightTitle, splitView, hideLineNumbers, } = this.props;\n            if (this.props.compareMethod !== compute_lines_1.DiffMethod.JSON) {\n                if (typeof oldValue !== 'string' || typeof newValue !== 'string') {\n                    throw Error('\"oldValue\" and \"newValue\" should be strings');\n                }\n            }\n            this.styles = this.computeStyles(this.props.styles, useDarkTheme);\n            const nodes = this.renderDiff();\n            const colSpanOnSplitView = hideLineNumbers ? 2 : 3;\n            const colSpanOnInlineView = hideLineNumbers ? 2 : 4;\n            let columnExtension = this.props.renderGutter ? 1 : 0;\n            const title = (leftTitle || rightTitle) && (React.createElement(\"tr\", null,\n                React.createElement(\"td\", { colSpan: (splitView ? colSpanOnSplitView : colSpanOnInlineView) +\n                        columnExtension, className: this.styles.titleBlock },\n                    React.createElement(\"pre\", { className: this.styles.contentText }, leftTitle)),\n                splitView && (React.createElement(\"td\", { colSpan: colSpanOnSplitView + columnExtension, className: this.styles.titleBlock },\n                    React.createElement(\"pre\", { className: this.styles.contentText }, rightTitle)))));\n            return (React.createElement(\"table\", { className: (0, classnames_1.default)(this.styles.diffContainer, {\n                    [this.styles.splitView]: splitView,\n                }) },\n                React.createElement(\"tbody\", null,\n                    title,\n                    nodes)));\n        };\n        this.state = {\n            expandedBlocks: [],\n        };\n    }\n}\nDiffViewer.defaultProps = {\n    oldValue: '',\n    newValue: '',\n    splitView: true,\n    highlightLines: [],\n    disableWordDiff: false,\n    compareMethod: compute_lines_1.DiffMethod.CHARS,\n    styles: {},\n    hideLineNumbers: false,\n    extraLinesSurroundingDiff: 3,\n    showDiffOnly: true,\n    useDarkTheme: false,\n    linesOffset: 0,\n};\nDiffViewer.propTypes = {\n    oldValue: PropTypes.any.isRequired,\n    newValue: PropTypes.any.isRequired,\n    splitView: PropTypes.bool,\n    disableWordDiff: PropTypes.bool,\n    compareMethod: PropTypes.oneOf(Object.values(compute_lines_1.DiffMethod)),\n    renderContent: PropTypes.func,\n    renderGutter: PropTypes.func,\n    onLineNumberClick: PropTypes.func,\n    extraLinesSurroundingDiff: PropTypes.number,\n    styles: PropTypes.object,\n    hideLineNumbers: PropTypes.bool,\n    showDiffOnly: PropTypes.bool,\n    highlightLines: PropTypes.arrayOf(PropTypes.string),\n    leftTitle: PropTypes.oneOfType([PropTypes.string, PropTypes.element]),\n    rightTitle: PropTypes.oneOfType([PropTypes.string, PropTypes.element]),\n    linesOffset: PropTypes.number,\n};\nexports[\"default\"] = DiffViewer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtZGlmZi12aWV3ZXItY29udGludWVkQDMuMi42X3JlYWN0LWRvbUAxOS4wLjAtcmMtNjVhNTZkMGUtMjAyNDEwMjBfcmVhY3RAMTkuMC4wLXJjLTY1YTU2X2JhcDN0Z3l5a29ldTdmdWozNDZtNXR4cHJ5L25vZGVfbW9kdWxlcy9yZWFjdC1kaWZmLXZpZXdlci1jb250aW51ZWQvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLHdCQUF3QjtBQUM3QyxjQUFjLG1CQUFPLENBQUMsNk9BQU87QUFDN0Isa0JBQWtCLG1CQUFPLENBQUMsaUdBQVk7QUFDdEMscUJBQXFCLG1CQUFPLENBQUMsZ0dBQVk7QUFDekMsd0JBQXdCLG1CQUFPLENBQUMsME9BQWlCO0FBQ2pELDhDQUE2QyxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUMzSCxpQkFBaUIsbUJBQU8sQ0FBQyw0TkFBVTtBQUNuQyxVQUFVLG1CQUFPLENBQUMsa0hBQWE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0RBQWtELHdCQUF3QixLQUFLO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBLHFCQUFxQixHQUFHO0FBQ3hCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTyxHQUFHLFdBQVc7QUFDL0Qsb0RBQW9ELGlCQUFpQixHQUFHLHFCQUFxQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEdBQUc7QUFDeEIsaURBQWlELG1DQUFtQztBQUNwRixxR0FBcUc7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEdBQUc7QUFDeEIsaURBQWlELG1DQUFtQztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixHQUFHO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEdBQUc7QUFDeEIsaURBQWlELG9DQUFvQztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsYUFBYTtBQUMvQyxnREFBZ0QseUNBQXlDO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsYUFBYTtBQUNoRDtBQUNBO0FBQ0EsOERBQThELFlBQVk7QUFDMUUsZ0RBQWdELDZCQUE2QjtBQUM3RSxnREFBZ0QsNkJBQTZCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHlDQUF5QztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZCQUE2QjtBQUNqRCxzTEFBc0wsd0NBQXdDO0FBQzlOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDJEQUEyRDtBQUN0RztBQUNBLGdEQUFnRCxRQUFRLG9CQUFvQixHQUFHLHFCQUFxQixvQ0FBb0M7QUFDeEksZ0VBQWdFLHVDQUF1QztBQUN2Ryx1RUFBdUUsdUNBQXVDO0FBQzlHLDRDQUE0QztBQUM1QztBQUNBLHFCQUFxQixHQUFHO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhFQUE4RTtBQUNsRyxvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQSxrRUFBa0UsUUFBUTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esb0JBQW9CLHVGQUF1RjtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLDRFQUE0RTtBQUM1RSxpREFBaUQsb0NBQW9DO0FBQ3JGLDBEQUEwRCxrRkFBa0Y7QUFDNUksaURBQWlELG9DQUFvQztBQUNyRixtREFBbUQ7QUFDbkQ7QUFDQSxpQkFBaUIsR0FBRztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL2xlc3Nvbi1hdXRob3JpbmcvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtZGlmZi12aWV3ZXItY29udGludWVkQDMuMi42X3JlYWN0LWRvbUAxOS4wLjAtcmMtNjVhNTZkMGUtMjAyNDEwMjBfcmVhY3RAMTkuMC4wLXJjLTY1YTU2X2JhcDN0Z3l5a29ldTdmdWozNDZtNXR4cHJ5L25vZGVfbW9kdWxlcy9yZWFjdC1kaWZmLXZpZXdlci1jb250aW51ZWQvbGliL2luZGV4LmpzPzE5MjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRpZmZNZXRob2QgPSBleHBvcnRzLkxpbmVOdW1iZXJQcmVmaXggPSB2b2lkIDA7XG5jb25zdCBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbmNvbnN0IFByb3BUeXBlcyA9IHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpO1xuY29uc3QgY2xhc3NuYW1lc18xID0gcmVxdWlyZShcImNsYXNzbmFtZXNcIik7XG5jb25zdCBjb21wdXRlX2xpbmVzXzEgPSByZXF1aXJlKFwiLi9jb21wdXRlLWxpbmVzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlmZk1ldGhvZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcHV0ZV9saW5lc18xLkRpZmZNZXRob2Q7IH0gfSk7XG5jb25zdCBzdHlsZXNfMSA9IHJlcXVpcmUoXCIuL3N0eWxlc1wiKTtcbmNvbnN0IG0gPSByZXF1aXJlKCdtZW1vaXplLW9uZScpO1xuY29uc3QgbWVtb2l6ZSA9IG0uZGVmYXVsdCB8fCBtO1xudmFyIExpbmVOdW1iZXJQcmVmaXg7XG4oZnVuY3Rpb24gKExpbmVOdW1iZXJQcmVmaXgpIHtcbiAgICBMaW5lTnVtYmVyUHJlZml4W1wiTEVGVFwiXSA9IFwiTFwiO1xuICAgIExpbmVOdW1iZXJQcmVmaXhbXCJSSUdIVFwiXSA9IFwiUlwiO1xufSkoTGluZU51bWJlclByZWZpeCA9IGV4cG9ydHMuTGluZU51bWJlclByZWZpeCB8fCAoZXhwb3J0cy5MaW5lTnVtYmVyUHJlZml4ID0ge30pKTtcbmNsYXNzIERpZmZWaWV3ZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2V0cyBjb2RlIGJsb2NrIGV4cGFuZCB0byB0aGUgaW5pdGlhbCBzdGFnZS4gV2lsbCBiZSBleHBvc2VkIHRvIHRoZSBwYXJlbnQgY29tcG9uZW50IHZpYVxuICAgICAgICAgKiByZWZzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXNldENvZGVCbG9ja3MgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5leHBhbmRlZEJsb2Nrcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGV4cGFuZGVkQmxvY2tzOiBbXSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFB1c2hlcyB0aGUgdGFyZ2V0IGV4cGFuZGVkIGNvZGUgYmxvY2sgdG8gdGhlIHN0YXRlLiBEdXJpbmcgdGhlIHJlLXJlbmRlcixcbiAgICAgICAgICogdGhpcyB2YWx1ZSBpcyB1c2VkIHRvIGV4cGFuZC9mb2xkIHVubW9kaWZpZWQgY29kZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25CbG9ja0V4cGFuZCA9IChpZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJldlN0YXRlID0gdGhpcy5zdGF0ZS5leHBhbmRlZEJsb2Nrcy5zbGljZSgpO1xuICAgICAgICAgICAgcHJldlN0YXRlLnB1c2goaWQpO1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgZXhwYW5kZWRCbG9ja3M6IHByZXZTdGF0ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcHV0ZXMgZmluYWwgc3R5bGVzIGZvciB0aGUgZGlmZiB2aWV3ZXIuIEl0IGNvbWJpbmVzIHRoZSBkZWZhdWx0IHN0eWxlcyB3aXRoIHRoZSB1c2VyXG4gICAgICAgICAqIHN1cHBsaWVkIG92ZXJyaWRlcy4gVGhlIGNvbXB1dGVkIHN0eWxlcyBhcmUgY2FjaGVkIHdpdGggcGVyZm9ybWFuY2UgaW4gbWluZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHN0eWxlcyBVc2VyIHN1cHBsaWVkIHN0eWxlIG92ZXJyaWRlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29tcHV0ZVN0eWxlcyA9IG1lbW9pemUoc3R5bGVzXzEuZGVmYXVsdCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gd2l0aCBjbGlja2VkIGxpbmUgbnVtYmVyIGluIHRoZSBjbG9zdXJlLiBSZXR1cm5zIGFuIG5vLW9wIGZ1bmN0aW9uIHdoZW4gbm9cbiAgICAgICAgICogb25MaW5lTnVtYmVyQ2xpY2sgaGFuZGxlciBpcyBzdXBwbGllZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGlkIExpbmUgaWQgb2YgYSBsaW5lLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkxpbmVOdW1iZXJDbGlja1Byb3h5ID0gKGlkKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5vbkxpbmVOdW1iZXJDbGljaykge1xuICAgICAgICAgICAgICAgIHJldHVybiAoZSkgPT4gdGhpcy5wcm9wcy5vbkxpbmVOdW1iZXJDbGljayhpZCwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4geyB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFwcyBvdmVyIHRoZSB3b3JkIGRpZmYgYW5kIGNvbnN0cnVjdHMgdGhlIHJlcXVpcmVkIFJlYWN0IGVsZW1lbnRzIHRvIHNob3cgd29yZCBkaWZmLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZGlmZkFycmF5IFdvcmQgZGlmZiBpbmZvcm1hdGlvbiBkZXJpdmVkIGZyb20gbGluZSBpbmZvcm1hdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHJlbmRlcmVyIE9wdGlvbmFsIHJlbmRlcmVyIHRvIGZvcm1hdCBkaWZmIHdvcmRzLiBVc2VmdWwgZm9yIHN5bnRheCBoaWdobGlnaHRpbmcuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlbmRlcldvcmREaWZmID0gKGRpZmZBcnJheSwgcmVuZGVyZXIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBkaWZmQXJyYXkubWFwKCh3b3JkRGlmZiwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBrZXk6IGksIGNsYXNzTmFtZTogKDAsIGNsYXNzbmFtZXNfMS5kZWZhdWx0KSh0aGlzLnN0eWxlcy53b3JkRGlmZiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgW3RoaXMuc3R5bGVzLndvcmRBZGRlZF06IHdvcmREaWZmLnR5cGUgPT09IGNvbXB1dGVfbGluZXNfMS5EaWZmVHlwZS5BRERFRCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFt0aGlzLnN0eWxlcy53b3JkUmVtb3ZlZF06IHdvcmREaWZmLnR5cGUgPT09IGNvbXB1dGVfbGluZXNfMS5EaWZmVHlwZS5SRU1PVkVELFxuICAgICAgICAgICAgICAgICAgICB9KSB9LCByZW5kZXJlciA/IHJlbmRlcmVyKHdvcmREaWZmLnZhbHVlKSA6IHdvcmREaWZmLnZhbHVlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcHMgb3ZlciB0aGUgbGluZSBkaWZmIGFuZCBjb25zdHJ1Y3RzIHRoZSByZXF1aXJlZCByZWFjdCBlbGVtZW50cyB0byBzaG93IGxpbmUgZGlmZi4gSXQgY2FsbHNcbiAgICAgICAgICogcmVuZGVyV29yZERpZmYgd2hlbiBlbmNvdW50ZXJpbmcgd29yZCBkaWZmLiBUaGlzIHRha2VzIGNhcmUgb2YgYm90aCBpbmxpbmUgYW5kIHNwbGl0IHZpZXcgbGluZVxuICAgICAgICAgKiByZW5kZXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbGluZU51bWJlciBMaW5lIG51bWJlciBvZiB0aGUgY3VycmVudCBsaW5lLlxuICAgICAgICAgKiBAcGFyYW0gdHlwZSBUeXBlIG9mIGRpZmYgb2YgdGhlIGN1cnJlbnQgbGluZS5cbiAgICAgICAgICogQHBhcmFtIHByZWZpeCBVbmlxdWUgaWQgdG8gcHJlZml4IHdpdGggdGhlIGxpbmUgbnVtYmVycy5cbiAgICAgICAgICogQHBhcmFtIHZhbHVlIENvbnRlbnQgb2YgdGhlIGxpbmUuIEl0IGNhbiBiZSBhIHN0cmluZyBvciBhIHdvcmQgZGlmZiBhcnJheS5cbiAgICAgICAgICogQHBhcmFtIGFkZGl0aW9uYWxMaW5lTnVtYmVyIEFkZGl0aW9uYWwgbGluZSBudW1iZXIgdG8gYmUgc2hvd24uIFVzZWZ1bCBmb3IgcmVuZGVyaW5nIGlubGluZVxuICAgICAgICAgKiAgZGlmZiB2aWV3LiBSaWdodCBsaW5lIG51bWJlciB3aWxsIGJlIHBhc3NlZCBhcyBhZGRpdGlvbmFsTGluZU51bWJlci5cbiAgICAgICAgICogQHBhcmFtIGFkZGl0aW9uYWxQcmVmaXggU2ltaWxhciB0byBwcmVmaXggYnV0IGZvciBhZGRpdGlvbmFsIGxpbmUgbnVtYmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZW5kZXJMaW5lID0gKGxpbmVOdW1iZXIsIHR5cGUsIHByZWZpeCwgdmFsdWUsIGFkZGl0aW9uYWxMaW5lTnVtYmVyLCBhZGRpdGlvbmFsUHJlZml4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsaW5lTnVtYmVyVGVtcGxhdGUgPSBgJHtwcmVmaXh9LSR7bGluZU51bWJlcn1gO1xuICAgICAgICAgICAgY29uc3QgYWRkaXRpb25hbExpbmVOdW1iZXJUZW1wbGF0ZSA9IGAke2FkZGl0aW9uYWxQcmVmaXh9LSR7YWRkaXRpb25hbExpbmVOdW1iZXJ9YDtcbiAgICAgICAgICAgIGNvbnN0IGhpZ2hsaWdodExpbmUgPSB0aGlzLnByb3BzLmhpZ2hsaWdodExpbmVzLmluY2x1ZGVzKGxpbmVOdW1iZXJUZW1wbGF0ZSkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLmhpZ2hsaWdodExpbmVzLmluY2x1ZGVzKGFkZGl0aW9uYWxMaW5lTnVtYmVyVGVtcGxhdGUpO1xuICAgICAgICAgICAgY29uc3QgYWRkZWQgPSB0eXBlID09PSBjb21wdXRlX2xpbmVzXzEuRGlmZlR5cGUuQURERUQ7XG4gICAgICAgICAgICBjb25zdCByZW1vdmVkID0gdHlwZSA9PT0gY29tcHV0ZV9saW5lc18xLkRpZmZUeXBlLlJFTU9WRUQ7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VkID0gdHlwZSA9PT0gY29tcHV0ZV9saW5lc18xLkRpZmZUeXBlLkNIQU5HRUQ7XG4gICAgICAgICAgICBsZXQgY29udGVudDtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLnJlbmRlcldvcmREaWZmKHZhbHVlLCB0aGlzLnByb3BzLnJlbmRlckNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wcm9wcy5yZW5kZXJDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IHRoaXMucHJvcHMucmVuZGVyQ29udGVudCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICAgICAgIXRoaXMucHJvcHMuaGlkZUxpbmVOdW1iZXJzICYmIChSZWFjdC5jcmVhdGVFbGVtZW50KFwidGRcIiwgeyBvbkNsaWNrOiBsaW5lTnVtYmVyICYmIHRoaXMub25MaW5lTnVtYmVyQ2xpY2tQcm94eShsaW5lTnVtYmVyVGVtcGxhdGUpLCBjbGFzc05hbWU6ICgwLCBjbGFzc25hbWVzXzEuZGVmYXVsdCkodGhpcy5zdHlsZXMuZ3V0dGVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbdGhpcy5zdHlsZXMuZW1wdHlHdXR0ZXJdOiAhbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIFt0aGlzLnN0eWxlcy5kaWZmQWRkZWRdOiBhZGRlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFt0aGlzLnN0eWxlcy5kaWZmUmVtb3ZlZF06IHJlbW92ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBbdGhpcy5zdHlsZXMuZGlmZkNoYW5nZWRdOiBjaGFuZ2VkLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3RoaXMuc3R5bGVzLmhpZ2hsaWdodGVkR3V0dGVyXTogaGlnaGxpZ2h0TGluZSxcbiAgICAgICAgICAgICAgICAgICAgfSkgfSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInByZVwiLCB7IGNsYXNzTmFtZTogdGhpcy5zdHlsZXMubGluZU51bWJlciB9LCBsaW5lTnVtYmVyKSkpLFxuICAgICAgICAgICAgICAgICF0aGlzLnByb3BzLnNwbGl0VmlldyAmJiAhdGhpcy5wcm9wcy5oaWRlTGluZU51bWJlcnMgJiYgKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IG9uQ2xpY2s6IGFkZGl0aW9uYWxMaW5lTnVtYmVyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTGluZU51bWJlckNsaWNrUHJveHkoYWRkaXRpb25hbExpbmVOdW1iZXJUZW1wbGF0ZSksIGNsYXNzTmFtZTogKDAsIGNsYXNzbmFtZXNfMS5kZWZhdWx0KSh0aGlzLnN0eWxlcy5ndXR0ZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFt0aGlzLnN0eWxlcy5lbXB0eUd1dHRlcl06ICFhZGRpdGlvbmFsTGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIFt0aGlzLnN0eWxlcy5kaWZmQWRkZWRdOiBhZGRlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFt0aGlzLnN0eWxlcy5kaWZmUmVtb3ZlZF06IHJlbW92ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBbdGhpcy5zdHlsZXMuZGlmZkNoYW5nZWRdOiBjaGFuZ2VkLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3RoaXMuc3R5bGVzLmhpZ2hsaWdodGVkR3V0dGVyXTogaGlnaGxpZ2h0TGluZSxcbiAgICAgICAgICAgICAgICAgICAgfSkgfSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInByZVwiLCB7IGNsYXNzTmFtZTogdGhpcy5zdHlsZXMubGluZU51bWJlciB9LCBhZGRpdGlvbmFsTGluZU51bWJlcikpKSxcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnJlbmRlckd1dHRlclxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMucHJvcHMucmVuZGVyR3V0dGVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsTGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxQcmVmaXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IHRoaXMuc3R5bGVzLFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInRkXCIsIHsgY2xhc3NOYW1lOiAoMCwgY2xhc3NuYW1lc18xLmRlZmF1bHQpKHRoaXMuc3R5bGVzLm1hcmtlciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgW3RoaXMuc3R5bGVzLmVtcHR5TGluZV06ICFjb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgW3RoaXMuc3R5bGVzLmRpZmZBZGRlZF06IGFkZGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3RoaXMuc3R5bGVzLmRpZmZSZW1vdmVkXTogcmVtb3ZlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFt0aGlzLnN0eWxlcy5kaWZmQ2hhbmdlZF06IGNoYW5nZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBbdGhpcy5zdHlsZXMuaGlnaGxpZ2h0ZWRMaW5lXTogaGlnaGxpZ2h0TGluZSxcbiAgICAgICAgICAgICAgICAgICAgfSkgfSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInByZVwiLCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkZWQgJiYgJysnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZCAmJiAnLScpKSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGRcIiwgeyBjbGFzc05hbWU6ICgwLCBjbGFzc25hbWVzXzEuZGVmYXVsdCkodGhpcy5zdHlsZXMuY29udGVudCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgW3RoaXMuc3R5bGVzLmVtcHR5TGluZV06ICFjb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgW3RoaXMuc3R5bGVzLmRpZmZBZGRlZF06IGFkZGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3RoaXMuc3R5bGVzLmRpZmZSZW1vdmVkXTogcmVtb3ZlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFt0aGlzLnN0eWxlcy5kaWZmQ2hhbmdlZF06IGNoYW5nZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBbdGhpcy5zdHlsZXMuaGlnaGxpZ2h0ZWRMaW5lXTogaGlnaGxpZ2h0TGluZSxcbiAgICAgICAgICAgICAgICAgICAgfSkgfSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInByZVwiLCB7IGNsYXNzTmFtZTogdGhpcy5zdHlsZXMuY29udGVudFRleHQgfSwgY29udGVudCkpKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZW5lcmF0ZXMgbGluZXMgZm9yIHNwbGl0IHZpZXcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBvYmogTGluZSBkaWZmIGluZm9ybWF0aW9uLlxuICAgICAgICAgKiBAcGFyYW0gb2JqLmxlZnQgTGlmZSBkaWZmIGluZm9ybWF0aW9uIGZvciB0aGUgbGVmdCBwYW5lIG9mIHRoZSBzcGxpdCB2aWV3LlxuICAgICAgICAgKiBAcGFyYW0gb2JqLnJpZ2h0IExpZmUgZGlmZiBpbmZvcm1hdGlvbiBmb3IgdGhlIHJpZ2h0IHBhbmUgb2YgdGhlIHNwbGl0IHZpZXcuXG4gICAgICAgICAqIEBwYXJhbSBpbmRleCBSZWFjdCBrZXkgZm9yIHRoZSBsaW5lcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVuZGVyU3BsaXRWaWV3ID0gKHsgbGVmdCwgcmlnaHQgfSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInRyXCIsIHsga2V5OiBpbmRleCwgY2xhc3NOYW1lOiB0aGlzLnN0eWxlcy5saW5lIH0sXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJMaW5lKGxlZnQubGluZU51bWJlciwgbGVmdC50eXBlLCBMaW5lTnVtYmVyUHJlZml4LkxFRlQsIGxlZnQudmFsdWUpLFxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTGluZShyaWdodC5saW5lTnVtYmVyLCByaWdodC50eXBlLCBMaW5lTnVtYmVyUHJlZml4LlJJR0hULCByaWdodC52YWx1ZSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdlbmVyYXRlcyBsaW5lcyBmb3IgaW5saW5lIHZpZXcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBvYmogTGluZSBkaWZmIGluZm9ybWF0aW9uLlxuICAgICAgICAgKiBAcGFyYW0gb2JqLmxlZnQgTGlmZSBkaWZmIGluZm9ybWF0aW9uIGZvciB0aGUgYWRkZWQgc2VjdGlvbiBvZiB0aGUgaW5saW5lIHZpZXcuXG4gICAgICAgICAqIEBwYXJhbSBvYmoucmlnaHQgTGlmZSBkaWZmIGluZm9ybWF0aW9uIGZvciB0aGUgcmVtb3ZlZCBzZWN0aW9uIG9mIHRoZSBpbmxpbmUgdmlldy5cbiAgICAgICAgICogQHBhcmFtIGluZGV4IFJlYWN0IGtleSBmb3IgdGhlIGxpbmVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZW5kZXJJbmxpbmVWaWV3ID0gKHsgbGVmdCwgcmlnaHQgfSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGxldCBjb250ZW50O1xuICAgICAgICAgICAgaWYgKGxlZnQudHlwZSA9PT0gY29tcHV0ZV9saW5lc18xLkRpZmZUeXBlLlJFTU9WRUQgJiYgcmlnaHQudHlwZSA9PT0gY29tcHV0ZV9saW5lc18xLkRpZmZUeXBlLkFEREVEKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCB7IGtleTogaW5kZXggfSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInRyXCIsIHsgY2xhc3NOYW1lOiB0aGlzLnN0eWxlcy5saW5lIH0sIHRoaXMucmVuZGVyTGluZShsZWZ0LmxpbmVOdW1iZXIsIGxlZnQudHlwZSwgTGluZU51bWJlclByZWZpeC5MRUZULCBsZWZ0LnZhbHVlLCBudWxsKSksXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IGNsYXNzTmFtZTogdGhpcy5zdHlsZXMubGluZSB9LCB0aGlzLnJlbmRlckxpbmUobnVsbCwgcmlnaHQudHlwZSwgTGluZU51bWJlclByZWZpeC5SSUdIVCwgcmlnaHQudmFsdWUsIHJpZ2h0LmxpbmVOdW1iZXIpKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZnQudHlwZSA9PT0gY29tcHV0ZV9saW5lc18xLkRpZmZUeXBlLlJFTU9WRUQpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gdGhpcy5yZW5kZXJMaW5lKGxlZnQubGluZU51bWJlciwgbGVmdC50eXBlLCBMaW5lTnVtYmVyUHJlZml4LkxFRlQsIGxlZnQudmFsdWUsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZnQudHlwZSA9PT0gY29tcHV0ZV9saW5lc18xLkRpZmZUeXBlLkRFRkFVTFQpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gdGhpcy5yZW5kZXJMaW5lKGxlZnQubGluZU51bWJlciwgbGVmdC50eXBlLCBMaW5lTnVtYmVyUHJlZml4LkxFRlQsIGxlZnQudmFsdWUsIHJpZ2h0LmxpbmVOdW1iZXIsIExpbmVOdW1iZXJQcmVmaXguUklHSFQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJpZ2h0LnR5cGUgPT09IGNvbXB1dGVfbGluZXNfMS5EaWZmVHlwZS5BRERFRCkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLnJlbmRlckxpbmUobnVsbCwgcmlnaHQudHlwZSwgTGluZU51bWJlclByZWZpeC5SSUdIVCwgcmlnaHQudmFsdWUsIHJpZ2h0LmxpbmVOdW1iZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwidHJcIiwgeyBrZXk6IGluZGV4LCBjbGFzc05hbWU6IHRoaXMuc3R5bGVzLmxpbmUgfSwgY29udGVudCkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHdpdGggY2xpY2tlZCBibG9jayBudW1iZXIgaW4gdGhlIGNsb3N1cmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBpZCBDb2xkIGZvbGQgYmxvY2sgaWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQmxvY2tDbGlja1Byb3h5ID0gKGlkKSA9PiAoKSA9PiB0aGlzLm9uQmxvY2tFeHBhbmQoaWQpO1xuICAgICAgICAvKipcbiAgICAgICAgICogR2VuZXJhdGVzIGNvbGQgZm9sZCBibG9jay4gSXQgYWxzbyB1c2VzIHRoZSBjdXN0b20gbWVzc2FnZSByZW5kZXJlciB3aGVuIGF2YWlsYWJsZSB0byBzaG93XG4gICAgICAgICAqIGNvbGQgZm9sZCBtZXNzYWdlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG51bSBOdW1iZXIgb2Ygc2tpcHBlZCBsaW5lcyBiZXR3ZWVuIHR3byBibG9ja3MuXG4gICAgICAgICAqIEBwYXJhbSBibG9ja051bWJlciBDb2RlIGZvbGQgYmxvY2sgaWQuXG4gICAgICAgICAqIEBwYXJhbSBsZWZ0QmxvY2tMaW5lTnVtYmVyIEZpcnN0IGxlZnQgbGluZSBudW1iZXIgYWZ0ZXIgdGhlIGN1cnJlbnQgY29kZSBmb2xkIGJsb2NrLlxuICAgICAgICAgKiBAcGFyYW0gcmlnaHRCbG9ja0xpbmVOdW1iZXIgRmlyc3QgcmlnaHQgbGluZSBudW1iZXIgYWZ0ZXIgdGhlIGN1cnJlbnQgY29kZSBmb2xkIGJsb2NrLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZW5kZXJTa2lwcGVkTGluZUluZGljYXRvciA9IChudW0sIGJsb2NrTnVtYmVyLCBsZWZ0QmxvY2tMaW5lTnVtYmVyLCByaWdodEJsb2NrTGluZU51bWJlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBoaWRlTGluZU51bWJlcnMsIHNwbGl0VmlldyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLnByb3BzLmNvZGVGb2xkTWVzc2FnZVJlbmRlcmVyID8gKHRoaXMucHJvcHMuY29kZUZvbGRNZXNzYWdlUmVuZGVyZXIobnVtLCBsZWZ0QmxvY2tMaW5lTnVtYmVyLCByaWdodEJsb2NrTGluZU51bWJlcikpIDogKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIiwgeyBjbGFzc05hbWU6IHRoaXMuc3R5bGVzLmNvZGVGb2xkQ29udGVudCB9LFxuICAgICAgICAgICAgICAgIFwiRXhwYW5kIFwiLFxuICAgICAgICAgICAgICAgIG51bSxcbiAgICAgICAgICAgICAgICBcIiBsaW5lcyAuLi5cIikpO1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IChSZWFjdC5jcmVhdGVFbGVtZW50KFwidGRcIiwgbnVsbCxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCB7IG9uQ2xpY2s6IHRoaXMub25CbG9ja0NsaWNrUHJveHkoYmxvY2tOdW1iZXIpLCB0YWJJbmRleDogMCB9LCBtZXNzYWdlKSkpO1xuICAgICAgICAgICAgY29uc3QgaXNVbmlmaWVkVmlld1dpdGhvdXRMaW5lTnVtYmVycyA9ICFzcGxpdFZpZXcgJiYgIWhpZGVMaW5lTnVtYmVycztcbiAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInRyXCIsIHsga2V5OiBgJHtsZWZ0QmxvY2tMaW5lTnVtYmVyfS0ke3JpZ2h0QmxvY2tMaW5lTnVtYmVyfWAsIGNsYXNzTmFtZTogdGhpcy5zdHlsZXMuY29kZUZvbGQgfSxcbiAgICAgICAgICAgICAgICAhaGlkZUxpbmVOdW1iZXJzICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IGNsYXNzTmFtZTogdGhpcy5zdHlsZXMuY29kZUZvbGRHdXR0ZXIgfSksXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5yZW5kZXJHdXR0ZXIgPyAoUmVhY3QuY3JlYXRlRWxlbWVudChcInRkXCIsIHsgY2xhc3NOYW1lOiB0aGlzLnN0eWxlcy5jb2RlRm9sZEd1dHRlciB9KSkgOiBudWxsLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IGNsYXNzTmFtZTogKDAsIGNsYXNzbmFtZXNfMS5kZWZhdWx0KSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBbdGhpcy5zdHlsZXMuY29kZUZvbGRHdXR0ZXJdOiBpc1VuaWZpZWRWaWV3V2l0aG91dExpbmVOdW1iZXJzLFxuICAgICAgICAgICAgICAgICAgICB9KSB9KSxcbiAgICAgICAgICAgICAgICBpc1VuaWZpZWRWaWV3V2l0aG91dExpbmVOdW1iZXJzID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCBudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudCkpIDogKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMucmVuZGVyR3V0dGVyID8gUmVhY3QuY3JlYXRlRWxlbWVudChcInRkXCIsIG51bGwpIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInRkXCIsIG51bGwpKSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInRkXCIsIG51bGwpLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCBudWxsKSkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2VuZXJhdGVzIHRoZSBlbnRpcmUgZGlmZiB2aWV3LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZW5kZXJEaWZmID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvbGRWYWx1ZSwgbmV3VmFsdWUsIHNwbGl0VmlldywgZGlzYWJsZVdvcmREaWZmLCBjb21wYXJlTWV0aG9kLCBsaW5lc09mZnNldCwgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBjb25zdCB7IGxpbmVJbmZvcm1hdGlvbiwgZGlmZkxpbmVzIH0gPSAoMCwgY29tcHV0ZV9saW5lc18xLmNvbXB1dGVMaW5lSW5mb3JtYXRpb24pKG9sZFZhbHVlLCBuZXdWYWx1ZSwgZGlzYWJsZVdvcmREaWZmLCBjb21wYXJlTWV0aG9kLCBsaW5lc09mZnNldCk7XG4gICAgICAgICAgICBjb25zdCBleHRyYUxpbmVzID0gdGhpcy5wcm9wcy5leHRyYUxpbmVzU3Vycm91bmRpbmdEaWZmIDwgMFxuICAgICAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgICAgIDogdGhpcy5wcm9wcy5leHRyYUxpbmVzU3Vycm91bmRpbmdEaWZmO1xuICAgICAgICAgICAgbGV0IHNraXBwZWRMaW5lcyA9IFtdO1xuICAgICAgICAgICAgcmV0dXJuIGxpbmVJbmZvcm1hdGlvbi5tYXAoKGxpbmUsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaWZmQmxvY2tTdGFydCA9IGRpZmZMaW5lc1swXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50UG9zaXRpb24gPSBkaWZmQmxvY2tTdGFydCAtIGk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMuc2hvd0RpZmZPbmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UG9zaXRpb24gPT09IC1leHRyYUxpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwcGVkTGluZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZMaW5lcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lLmxlZnQudHlwZSA9PT0gY29tcHV0ZV9saW5lc18xLkRpZmZUeXBlLkRFRkFVTFQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChjdXJyZW50UG9zaXRpb24gPiBleHRyYUxpbmVzIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGRpZmZCbG9ja1N0YXJ0ID09PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLnN0YXRlLmV4cGFuZGVkQmxvY2tzLmluY2x1ZGVzKGRpZmZCbG9ja1N0YXJ0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcHBlZExpbmVzLnB1c2goaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hvdyBza2lwcGVkIGxpbmUgaW5kaWNhdG9yIG9ubHkgaWYgdGhlcmUgaXMgbW9yZSB0aGFuIG9uZSBsaW5lIHRvIGhpZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBsaW5lSW5mb3JtYXRpb24ubGVuZ3RoIC0gMSAmJiBza2lwcGVkTGluZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlclNraXBwZWRMaW5lSW5kaWNhdG9yKHNraXBwZWRMaW5lcy5sZW5ndGgsIGRpZmZCbG9ja1N0YXJ0LCBsaW5lLmxlZnQubGluZU51bWJlciwgbGluZS5yaWdodC5saW5lTnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBhcmUgdHJ5aW5nIHRvIGhpZGUgdGhlIGxhc3QgbGluZSwganVzdCBzaG93IGl0XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpIDwgbGluZUluZm9ybWF0aW9uLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBkaWZmTm9kZXMgPSBzcGxpdFZpZXdcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnJlbmRlclNwbGl0VmlldyhsaW5lLCBpKVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMucmVuZGVySW5saW5lVmlldyhsaW5lLCBpKTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFBvc2l0aW9uID09PSBleHRyYUxpbmVzICYmIHNraXBwZWRMaW5lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBza2lwcGVkTGluZXM7XG4gICAgICAgICAgICAgICAgICAgIHNraXBwZWRMaW5lcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIHsga2V5OiBpIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclNraXBwZWRMaW5lSW5kaWNhdG9yKGxlbmd0aCwgZGlmZkJsb2NrU3RhcnQsIGxpbmUubGVmdC5saW5lTnVtYmVyLCBsaW5lLnJpZ2h0LmxpbmVOdW1iZXIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlmZk5vZGVzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkaWZmTm9kZXM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZW5kZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG9sZFZhbHVlLCBuZXdWYWx1ZSwgdXNlRGFya1RoZW1lLCBsZWZ0VGl0bGUsIHJpZ2h0VGl0bGUsIHNwbGl0VmlldywgaGlkZUxpbmVOdW1iZXJzLCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmNvbXBhcmVNZXRob2QgIT09IGNvbXB1dGVfbGluZXNfMS5EaWZmTWV0aG9kLkpTT04pIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9sZFZhbHVlICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3VmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdcIm9sZFZhbHVlXCIgYW5kIFwibmV3VmFsdWVcIiBzaG91bGQgYmUgc3RyaW5ncycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3R5bGVzID0gdGhpcy5jb21wdXRlU3R5bGVzKHRoaXMucHJvcHMuc3R5bGVzLCB1c2VEYXJrVGhlbWUpO1xuICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSB0aGlzLnJlbmRlckRpZmYoKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbFNwYW5PblNwbGl0VmlldyA9IGhpZGVMaW5lTnVtYmVycyA/IDIgOiAzO1xuICAgICAgICAgICAgY29uc3QgY29sU3Bhbk9uSW5saW5lVmlldyA9IGhpZGVMaW5lTnVtYmVycyA/IDIgOiA0O1xuICAgICAgICAgICAgbGV0IGNvbHVtbkV4dGVuc2lvbiA9IHRoaXMucHJvcHMucmVuZGVyR3V0dGVyID8gMSA6IDA7XG4gICAgICAgICAgICBjb25zdCB0aXRsZSA9IChsZWZ0VGl0bGUgfHwgcmlnaHRUaXRsZSkgJiYgKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0clwiLCBudWxsLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IGNvbFNwYW46IChzcGxpdFZpZXcgPyBjb2xTcGFuT25TcGxpdFZpZXcgOiBjb2xTcGFuT25JbmxpbmVWaWV3KSArXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5FeHRlbnNpb24sIGNsYXNzTmFtZTogdGhpcy5zdHlsZXMudGl0bGVCbG9jayB9LFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicHJlXCIsIHsgY2xhc3NOYW1lOiB0aGlzLnN0eWxlcy5jb250ZW50VGV4dCB9LCBsZWZ0VGl0bGUpKSxcbiAgICAgICAgICAgICAgICBzcGxpdFZpZXcgJiYgKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IGNvbFNwYW46IGNvbFNwYW5PblNwbGl0VmlldyArIGNvbHVtbkV4dGVuc2lvbiwgY2xhc3NOYW1lOiB0aGlzLnN0eWxlcy50aXRsZUJsb2NrIH0sXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIiwgeyBjbGFzc05hbWU6IHRoaXMuc3R5bGVzLmNvbnRlbnRUZXh0IH0sIHJpZ2h0VGl0bGUpKSkpKTtcbiAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInRhYmxlXCIsIHsgY2xhc3NOYW1lOiAoMCwgY2xhc3NuYW1lc18xLmRlZmF1bHQpKHRoaXMuc3R5bGVzLmRpZmZDb250YWluZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgW3RoaXMuc3R5bGVzLnNwbGl0Vmlld106IHNwbGl0VmlldyxcbiAgICAgICAgICAgICAgICB9KSB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0Ym9keVwiLCBudWxsLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMpKSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBleHBhbmRlZEJsb2NrczogW10sXG4gICAgICAgIH07XG4gICAgfVxufVxuRGlmZlZpZXdlci5kZWZhdWx0UHJvcHMgPSB7XG4gICAgb2xkVmFsdWU6ICcnLFxuICAgIG5ld1ZhbHVlOiAnJyxcbiAgICBzcGxpdFZpZXc6IHRydWUsXG4gICAgaGlnaGxpZ2h0TGluZXM6IFtdLFxuICAgIGRpc2FibGVXb3JkRGlmZjogZmFsc2UsXG4gICAgY29tcGFyZU1ldGhvZDogY29tcHV0ZV9saW5lc18xLkRpZmZNZXRob2QuQ0hBUlMsXG4gICAgc3R5bGVzOiB7fSxcbiAgICBoaWRlTGluZU51bWJlcnM6IGZhbHNlLFxuICAgIGV4dHJhTGluZXNTdXJyb3VuZGluZ0RpZmY6IDMsXG4gICAgc2hvd0RpZmZPbmx5OiB0cnVlLFxuICAgIHVzZURhcmtUaGVtZTogZmFsc2UsXG4gICAgbGluZXNPZmZzZXQ6IDAsXG59O1xuRGlmZlZpZXdlci5wcm9wVHlwZXMgPSB7XG4gICAgb2xkVmFsdWU6IFByb3BUeXBlcy5hbnkuaXNSZXF1aXJlZCxcbiAgICBuZXdWYWx1ZTogUHJvcFR5cGVzLmFueS5pc1JlcXVpcmVkLFxuICAgIHNwbGl0VmlldzogUHJvcFR5cGVzLmJvb2wsXG4gICAgZGlzYWJsZVdvcmREaWZmOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBjb21wYXJlTWV0aG9kOiBQcm9wVHlwZXMub25lT2YoT2JqZWN0LnZhbHVlcyhjb21wdXRlX2xpbmVzXzEuRGlmZk1ldGhvZCkpLFxuICAgIHJlbmRlckNvbnRlbnQ6IFByb3BUeXBlcy5mdW5jLFxuICAgIHJlbmRlckd1dHRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25MaW5lTnVtYmVyQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICAgIGV4dHJhTGluZXNTdXJyb3VuZGluZ0RpZmY6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgc3R5bGVzOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIGhpZGVMaW5lTnVtYmVyczogUHJvcFR5cGVzLmJvb2wsXG4gICAgc2hvd0RpZmZPbmx5OiBQcm9wVHlwZXMuYm9vbCxcbiAgICBoaWdobGlnaHRMaW5lczogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLnN0cmluZyksXG4gICAgbGVmdFRpdGxlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuZWxlbWVudF0pLFxuICAgIHJpZ2h0VGl0bGU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5lbGVtZW50XSksXG4gICAgbGluZXNPZmZzZXQ6IFByb3BUeXBlcy5udW1iZXIsXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gRGlmZlZpZXdlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/react-diff-viewer-continued@3.2.6_react-dom@19.0.0-rc-65a56d0e-20241020_react@19.0.0-rc-65a56_bap3tgyykoeu7fuj346m5txpry/node_modules/react-diff-viewer-continued/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/react-diff-viewer-continued@3.2.6_react-dom@19.0.0-rc-65a56d0e-20241020_react@19.0.0-rc-65a56_bap3tgyykoeu7fuj346m5txpry/node_modules/react-diff-viewer-continued/lib/styles.js":
/*!************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/react-diff-viewer-continued@3.2.6_react-dom@19.0.0-rc-65a56d0e-20241020_react@19.0.0-rc-65a56_bap3tgyykoeu7fuj346m5txpry/node_modules/react-diff-viewer-continued/lib/styles.js ***!
  \************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst css_1 = __webpack_require__(/*! @emotion/css */ \"(ssr)/./node_modules/.pnpm/@emotion+css@11.13.4/node_modules/@emotion/css/dist/emotion-css.development.esm.js\");\n// eslint-disable-next-line import/no-anonymous-default-export\nexports[\"default\"] = (styleOverride, useDarkTheme = false) => {\n    const { variables: overrideVariables = {} } = styleOverride, styles = __rest(styleOverride, [\"variables\"]);\n    const themeVariables = {\n        light: Object.assign({\n            diffViewerBackground: '#fff',\n            diffViewerColor: '#212529',\n            addedBackground: '#e6ffed',\n            addedColor: '#24292e',\n            removedBackground: '#ffeef0',\n            removedColor: '#24292e',\n            changedBackground: '#fffbdd',\n            wordAddedBackground: '#acf2bd',\n            wordRemovedBackground: '#fdb8c0',\n            addedGutterBackground: '#cdffd8',\n            removedGutterBackground: '#ffdce0',\n            gutterBackground: '#f7f7f7',\n            gutterBackgroundDark: '#f3f1f1',\n            highlightBackground: '#fffbdd',\n            highlightGutterBackground: '#fff5b1',\n            codeFoldGutterBackground: '#dbedff',\n            codeFoldBackground: '#f1f8ff',\n            emptyLineBackground: '#fafbfc',\n            gutterColor: '#212529',\n            addedGutterColor: '#212529',\n            removedGutterColor: '#212529',\n            codeFoldContentColor: '#212529',\n            diffViewerTitleBackground: '#fafbfc',\n            diffViewerTitleColor: '#212529',\n            diffViewerTitleBorderColor: '#eee',\n        }, (overrideVariables.light || {})),\n        dark: Object.assign({\n            diffViewerBackground: '#2e303c',\n            diffViewerColor: '#FFF',\n            addedBackground: '#044B53',\n            addedColor: 'white',\n            removedBackground: '#632F34',\n            removedColor: 'white',\n            changedBackground: '#3e302c',\n            wordAddedBackground: '#055d67',\n            wordRemovedBackground: '#7d383f',\n            addedGutterBackground: '#034148',\n            removedGutterBackground: '#632b30',\n            gutterBackground: '#2c2f3a',\n            gutterBackgroundDark: '#262933',\n            highlightBackground: '#2a3967',\n            highlightGutterBackground: '#2d4077',\n            codeFoldGutterBackground: '#21232b',\n            codeFoldBackground: '#262831',\n            emptyLineBackground: '#363946',\n            gutterColor: '#666c87',\n            addedGutterColor: '#8c8c8c',\n            removedGutterColor: '#8c8c8c',\n            codeFoldContentColor: '#656a8b',\n            diffViewerTitleBackground: '#2f323e',\n            diffViewerTitleColor: '#555a7b',\n            diffViewerTitleBorderColor: '#353846',\n        }, (overrideVariables.dark || {})),\n    };\n    const variables = useDarkTheme ? themeVariables.dark : themeVariables.light;\n    const content = (0, css_1.css)({\n        width: '100%',\n        label: 'content',\n    });\n    const splitView = (0, css_1.css)({\n        [`.${content}`]: {\n            width: '50%',\n        },\n        label: 'split-view',\n    });\n    const diffContainer = (0, css_1.css)({\n        width: '100%',\n        background: variables.diffViewerBackground,\n        pre: {\n            margin: 0,\n            whiteSpace: 'pre-wrap',\n            lineHeight: '25px',\n        },\n        label: 'diff-container',\n        borderCollapse: 'collapse',\n    });\n    const codeFoldContent = (0, css_1.css)({\n        color: variables.codeFoldContentColor,\n        label: 'code-fold-content',\n    });\n    const contentText = (0, css_1.css)({\n        color: variables.diffViewerColor,\n        label: 'content-text',\n    });\n    const titleBlock = (0, css_1.css)({\n        background: variables.diffViewerTitleBackground,\n        padding: 10,\n        borderBottom: `1px solid ${variables.diffViewerTitleBorderColor}`,\n        label: 'title-block',\n        ':last-child': {\n            borderLeft: `1px solid ${variables.diffViewerTitleBorderColor}`,\n        },\n        [`.${contentText}`]: {\n            color: variables.diffViewerTitleColor,\n        },\n    });\n    const lineNumber = (0, css_1.css)({\n        color: variables.gutterColor,\n        label: 'line-number',\n    });\n    const diffRemoved = (0, css_1.css)({\n        background: variables.removedBackground,\n        color: variables.removedColor,\n        pre: {\n            color: variables.removedColor,\n        },\n        [`.${lineNumber}`]: {\n            color: variables.removedGutterColor,\n        },\n        label: 'diff-removed',\n    });\n    const diffAdded = (0, css_1.css)({\n        background: variables.addedBackground,\n        color: variables.addedColor,\n        pre: {\n            color: variables.addedColor,\n        },\n        [`.${lineNumber}`]: {\n            color: variables.addedGutterColor,\n        },\n        label: 'diff-added',\n    });\n    const diffChanged = (0, css_1.css)({\n        background: variables.changedBackground,\n        [`.${lineNumber}`]: {\n            color: variables.gutterColor,\n        },\n        label: 'diff-changed',\n    });\n    const wordDiff = (0, css_1.css)({\n        padding: 2,\n        display: 'inline-flex',\n        borderRadius: 4,\n        wordBreak: 'break-all',\n        label: 'word-diff',\n    });\n    const wordAdded = (0, css_1.css)({\n        background: variables.wordAddedBackground,\n        label: 'word-added',\n    });\n    const wordRemoved = (0, css_1.css)({\n        background: variables.wordRemovedBackground,\n        label: 'word-removed',\n    });\n    const codeFoldGutter = (0, css_1.css)({\n        backgroundColor: variables.codeFoldGutterBackground,\n        label: 'code-fold-gutter',\n    });\n    const codeFold = (0, css_1.css)({\n        backgroundColor: variables.codeFoldBackground,\n        height: 40,\n        fontSize: 14,\n        fontWeight: 700,\n        label: 'code-fold',\n        a: {\n            textDecoration: 'underline !important',\n            cursor: 'pointer',\n            pre: {\n                display: 'inline',\n            },\n        },\n    });\n    const emptyLine = (0, css_1.css)({\n        backgroundColor: variables.emptyLineBackground,\n        label: 'empty-line',\n    });\n    const marker = (0, css_1.css)({\n        width: 25,\n        paddingLeft: 10,\n        paddingRight: 10,\n        userSelect: 'none',\n        label: 'marker',\n        [`&.${diffAdded}`]: {\n            pre: {\n                color: variables.addedColor,\n            },\n        },\n        [`&.${diffRemoved}`]: {\n            pre: {\n                color: variables.removedColor,\n            },\n        },\n    });\n    const highlightedLine = (0, css_1.css)({\n        background: variables.highlightBackground,\n        label: 'highlighted-line',\n        [`.${wordAdded}, .${wordRemoved}`]: {\n            backgroundColor: 'initial',\n        },\n    });\n    const highlightedGutter = (0, css_1.css)({\n        label: 'highlighted-gutter',\n    });\n    const gutter = (0, css_1.css)({\n        userSelect: 'none',\n        minWidth: 50,\n        padding: '0 10px',\n        whiteSpace: 'nowrap',\n        label: 'gutter',\n        textAlign: 'right',\n        background: variables.gutterBackground,\n        '&:hover': {\n            cursor: 'pointer',\n            background: variables.gutterBackgroundDark,\n            pre: {\n                opacity: 1,\n            },\n        },\n        pre: {\n            opacity: 0.5,\n        },\n        [`&.${diffAdded}`]: {\n            background: variables.addedGutterBackground,\n        },\n        [`&.${diffRemoved}`]: {\n            background: variables.removedGutterBackground,\n        },\n        [`&.${highlightedGutter}`]: {\n            background: variables.highlightGutterBackground,\n            '&:hover': {\n                background: variables.highlightGutterBackground,\n            },\n        },\n    });\n    const emptyGutter = (0, css_1.css)({\n        '&:hover': {\n            background: variables.gutterBackground,\n            cursor: 'initial',\n        },\n        label: 'empty-gutter',\n    });\n    const line = (0, css_1.css)({\n        verticalAlign: 'baseline',\n        label: 'line',\n    });\n    const defaultStyles = {\n        diffContainer,\n        diffRemoved,\n        diffAdded,\n        diffChanged,\n        splitView,\n        marker,\n        highlightedGutter,\n        highlightedLine,\n        gutter,\n        line,\n        wordDiff,\n        wordAdded,\n        wordRemoved,\n        codeFoldGutter,\n        codeFold,\n        emptyGutter,\n        emptyLine,\n        lineNumber,\n        contentText,\n        content,\n        codeFoldContent,\n        titleBlock,\n    };\n    const computerOverrideStyles = Object.keys(styles).reduce((acc, key) => (Object.assign(Object.assign({}, acc), {\n        [key]: (0, css_1.css)(styles[key]),\n    })), {});\n    return Object.keys(defaultStyles).reduce((acc, key) => (Object.assign(Object.assign({}, acc), {\n        [key]: computerOverrideStyles[key]\n            ? (0, css_1.cx)(defaultStyles[key], computerOverrideStyles[key])\n            : defaultStyles[key],\n    })), {});\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtZGlmZi12aWV3ZXItY29udGludWVkQDMuMi42X3JlYWN0LWRvbUAxOS4wLjAtcmMtNjVhNTZkMGUtMjAyNDEwMjBfcmVhY3RAMTkuMC4wLXJjLTY1YTU2X2JhcDN0Z3l5a29ldTdmdWozNDZtNXR4cHJ5L25vZGVfbW9kdWxlcy9yZWFjdC1kaWZmLXZpZXdlci1jb250aW51ZWQvbGliL3N0eWxlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsbUJBQU8sQ0FBQyxtSUFBYztBQUNwQztBQUNBLGtCQUFlO0FBQ2YsWUFBWSxvQ0FBb0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxnQ0FBZ0M7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsK0JBQStCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxxQ0FBcUM7QUFDeEU7QUFDQTtBQUNBLHFDQUFxQyxxQ0FBcUM7QUFDMUUsU0FBUztBQUNULGFBQWEsWUFBWTtBQUN6QjtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsYUFBYSxXQUFXO0FBQ3hCO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsYUFBYSxXQUFXO0FBQ3hCO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVLEtBQUssWUFBWTtBQUN4QztBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxjQUFjLFVBQVU7QUFDeEI7QUFDQSxTQUFTO0FBQ1QsY0FBYyxZQUFZO0FBQzFCO0FBQ0EsU0FBUztBQUNULGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyR0FBMkc7QUFDM0c7QUFDQSxLQUFLLE1BQU07QUFDWCwwRkFBMEY7QUFDMUY7QUFDQTtBQUNBO0FBQ0EsS0FBSyxNQUFNO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZXNzb24tYXV0aG9yaW5nLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LWRpZmYtdmlld2VyLWNvbnRpbnVlZEAzLjIuNl9yZWFjdC1kb21AMTkuMC4wLXJjLTY1YTU2ZDBlLTIwMjQxMDIwX3JlYWN0QDE5LjAuMC1yYy02NWE1Nl9iYXAzdGd5eWtvZXU3ZnVqMzQ2bTV0eHByeS9ub2RlX21vZHVsZXMvcmVhY3QtZGlmZi12aWV3ZXItY29udGludWVkL2xpYi9zdHlsZXMuanM/NzFiYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNzc18xID0gcmVxdWlyZShcIkBlbW90aW9uL2Nzc1wiKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tYW5vbnltb3VzLWRlZmF1bHQtZXhwb3J0XG5leHBvcnRzLmRlZmF1bHQgPSAoc3R5bGVPdmVycmlkZSwgdXNlRGFya1RoZW1lID0gZmFsc2UpID0+IHtcbiAgICBjb25zdCB7IHZhcmlhYmxlczogb3ZlcnJpZGVWYXJpYWJsZXMgPSB7fSB9ID0gc3R5bGVPdmVycmlkZSwgc3R5bGVzID0gX19yZXN0KHN0eWxlT3ZlcnJpZGUsIFtcInZhcmlhYmxlc1wiXSk7XG4gICAgY29uc3QgdGhlbWVWYXJpYWJsZXMgPSB7XG4gICAgICAgIGxpZ2h0OiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGRpZmZWaWV3ZXJCYWNrZ3JvdW5kOiAnI2ZmZicsXG4gICAgICAgICAgICBkaWZmVmlld2VyQ29sb3I6ICcjMjEyNTI5JyxcbiAgICAgICAgICAgIGFkZGVkQmFja2dyb3VuZDogJyNlNmZmZWQnLFxuICAgICAgICAgICAgYWRkZWRDb2xvcjogJyMyNDI5MmUnLFxuICAgICAgICAgICAgcmVtb3ZlZEJhY2tncm91bmQ6ICcjZmZlZWYwJyxcbiAgICAgICAgICAgIHJlbW92ZWRDb2xvcjogJyMyNDI5MmUnLFxuICAgICAgICAgICAgY2hhbmdlZEJhY2tncm91bmQ6ICcjZmZmYmRkJyxcbiAgICAgICAgICAgIHdvcmRBZGRlZEJhY2tncm91bmQ6ICcjYWNmMmJkJyxcbiAgICAgICAgICAgIHdvcmRSZW1vdmVkQmFja2dyb3VuZDogJyNmZGI4YzAnLFxuICAgICAgICAgICAgYWRkZWRHdXR0ZXJCYWNrZ3JvdW5kOiAnI2NkZmZkOCcsXG4gICAgICAgICAgICByZW1vdmVkR3V0dGVyQmFja2dyb3VuZDogJyNmZmRjZTAnLFxuICAgICAgICAgICAgZ3V0dGVyQmFja2dyb3VuZDogJyNmN2Y3ZjcnLFxuICAgICAgICAgICAgZ3V0dGVyQmFja2dyb3VuZERhcms6ICcjZjNmMWYxJyxcbiAgICAgICAgICAgIGhpZ2hsaWdodEJhY2tncm91bmQ6ICcjZmZmYmRkJyxcbiAgICAgICAgICAgIGhpZ2hsaWdodEd1dHRlckJhY2tncm91bmQ6ICcjZmZmNWIxJyxcbiAgICAgICAgICAgIGNvZGVGb2xkR3V0dGVyQmFja2dyb3VuZDogJyNkYmVkZmYnLFxuICAgICAgICAgICAgY29kZUZvbGRCYWNrZ3JvdW5kOiAnI2YxZjhmZicsXG4gICAgICAgICAgICBlbXB0eUxpbmVCYWNrZ3JvdW5kOiAnI2ZhZmJmYycsXG4gICAgICAgICAgICBndXR0ZXJDb2xvcjogJyMyMTI1MjknLFxuICAgICAgICAgICAgYWRkZWRHdXR0ZXJDb2xvcjogJyMyMTI1MjknLFxuICAgICAgICAgICAgcmVtb3ZlZEd1dHRlckNvbG9yOiAnIzIxMjUyOScsXG4gICAgICAgICAgICBjb2RlRm9sZENvbnRlbnRDb2xvcjogJyMyMTI1MjknLFxuICAgICAgICAgICAgZGlmZlZpZXdlclRpdGxlQmFja2dyb3VuZDogJyNmYWZiZmMnLFxuICAgICAgICAgICAgZGlmZlZpZXdlclRpdGxlQ29sb3I6ICcjMjEyNTI5JyxcbiAgICAgICAgICAgIGRpZmZWaWV3ZXJUaXRsZUJvcmRlckNvbG9yOiAnI2VlZScsXG4gICAgICAgIH0sIChvdmVycmlkZVZhcmlhYmxlcy5saWdodCB8fCB7fSkpLFxuICAgICAgICBkYXJrOiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGRpZmZWaWV3ZXJCYWNrZ3JvdW5kOiAnIzJlMzAzYycsXG4gICAgICAgICAgICBkaWZmVmlld2VyQ29sb3I6ICcjRkZGJyxcbiAgICAgICAgICAgIGFkZGVkQmFja2dyb3VuZDogJyMwNDRCNTMnLFxuICAgICAgICAgICAgYWRkZWRDb2xvcjogJ3doaXRlJyxcbiAgICAgICAgICAgIHJlbW92ZWRCYWNrZ3JvdW5kOiAnIzYzMkYzNCcsXG4gICAgICAgICAgICByZW1vdmVkQ29sb3I6ICd3aGl0ZScsXG4gICAgICAgICAgICBjaGFuZ2VkQmFja2dyb3VuZDogJyMzZTMwMmMnLFxuICAgICAgICAgICAgd29yZEFkZGVkQmFja2dyb3VuZDogJyMwNTVkNjcnLFxuICAgICAgICAgICAgd29yZFJlbW92ZWRCYWNrZ3JvdW5kOiAnIzdkMzgzZicsXG4gICAgICAgICAgICBhZGRlZEd1dHRlckJhY2tncm91bmQ6ICcjMDM0MTQ4JyxcbiAgICAgICAgICAgIHJlbW92ZWRHdXR0ZXJCYWNrZ3JvdW5kOiAnIzYzMmIzMCcsXG4gICAgICAgICAgICBndXR0ZXJCYWNrZ3JvdW5kOiAnIzJjMmYzYScsXG4gICAgICAgICAgICBndXR0ZXJCYWNrZ3JvdW5kRGFyazogJyMyNjI5MzMnLFxuICAgICAgICAgICAgaGlnaGxpZ2h0QmFja2dyb3VuZDogJyMyYTM5NjcnLFxuICAgICAgICAgICAgaGlnaGxpZ2h0R3V0dGVyQmFja2dyb3VuZDogJyMyZDQwNzcnLFxuICAgICAgICAgICAgY29kZUZvbGRHdXR0ZXJCYWNrZ3JvdW5kOiAnIzIxMjMyYicsXG4gICAgICAgICAgICBjb2RlRm9sZEJhY2tncm91bmQ6ICcjMjYyODMxJyxcbiAgICAgICAgICAgIGVtcHR5TGluZUJhY2tncm91bmQ6ICcjMzYzOTQ2JyxcbiAgICAgICAgICAgIGd1dHRlckNvbG9yOiAnIzY2NmM4NycsXG4gICAgICAgICAgICBhZGRlZEd1dHRlckNvbG9yOiAnIzhjOGM4YycsXG4gICAgICAgICAgICByZW1vdmVkR3V0dGVyQ29sb3I6ICcjOGM4YzhjJyxcbiAgICAgICAgICAgIGNvZGVGb2xkQ29udGVudENvbG9yOiAnIzY1NmE4YicsXG4gICAgICAgICAgICBkaWZmVmlld2VyVGl0bGVCYWNrZ3JvdW5kOiAnIzJmMzIzZScsXG4gICAgICAgICAgICBkaWZmVmlld2VyVGl0bGVDb2xvcjogJyM1NTVhN2InLFxuICAgICAgICAgICAgZGlmZlZpZXdlclRpdGxlQm9yZGVyQ29sb3I6ICcjMzUzODQ2JyxcbiAgICAgICAgfSwgKG92ZXJyaWRlVmFyaWFibGVzLmRhcmsgfHwge30pKSxcbiAgICB9O1xuICAgIGNvbnN0IHZhcmlhYmxlcyA9IHVzZURhcmtUaGVtZSA/IHRoZW1lVmFyaWFibGVzLmRhcmsgOiB0aGVtZVZhcmlhYmxlcy5saWdodDtcbiAgICBjb25zdCBjb250ZW50ID0gKDAsIGNzc18xLmNzcykoe1xuICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICBsYWJlbDogJ2NvbnRlbnQnLFxuICAgIH0pO1xuICAgIGNvbnN0IHNwbGl0VmlldyA9ICgwLCBjc3NfMS5jc3MpKHtcbiAgICAgICAgW2AuJHtjb250ZW50fWBdOiB7XG4gICAgICAgICAgICB3aWR0aDogJzUwJScsXG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsOiAnc3BsaXQtdmlldycsXG4gICAgfSk7XG4gICAgY29uc3QgZGlmZkNvbnRhaW5lciA9ICgwLCBjc3NfMS5jc3MpKHtcbiAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgYmFja2dyb3VuZDogdmFyaWFibGVzLmRpZmZWaWV3ZXJCYWNrZ3JvdW5kLFxuICAgICAgICBwcmU6IHtcbiAgICAgICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgICAgIHdoaXRlU3BhY2U6ICdwcmUtd3JhcCcsXG4gICAgICAgICAgICBsaW5lSGVpZ2h0OiAnMjVweCcsXG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsOiAnZGlmZi1jb250YWluZXInLFxuICAgICAgICBib3JkZXJDb2xsYXBzZTogJ2NvbGxhcHNlJyxcbiAgICB9KTtcbiAgICBjb25zdCBjb2RlRm9sZENvbnRlbnQgPSAoMCwgY3NzXzEuY3NzKSh7XG4gICAgICAgIGNvbG9yOiB2YXJpYWJsZXMuY29kZUZvbGRDb250ZW50Q29sb3IsXG4gICAgICAgIGxhYmVsOiAnY29kZS1mb2xkLWNvbnRlbnQnLFxuICAgIH0pO1xuICAgIGNvbnN0IGNvbnRlbnRUZXh0ID0gKDAsIGNzc18xLmNzcykoe1xuICAgICAgICBjb2xvcjogdmFyaWFibGVzLmRpZmZWaWV3ZXJDb2xvcixcbiAgICAgICAgbGFiZWw6ICdjb250ZW50LXRleHQnLFxuICAgIH0pO1xuICAgIGNvbnN0IHRpdGxlQmxvY2sgPSAoMCwgY3NzXzEuY3NzKSh7XG4gICAgICAgIGJhY2tncm91bmQ6IHZhcmlhYmxlcy5kaWZmVmlld2VyVGl0bGVCYWNrZ3JvdW5kLFxuICAgICAgICBwYWRkaW5nOiAxMCxcbiAgICAgICAgYm9yZGVyQm90dG9tOiBgMXB4IHNvbGlkICR7dmFyaWFibGVzLmRpZmZWaWV3ZXJUaXRsZUJvcmRlckNvbG9yfWAsXG4gICAgICAgIGxhYmVsOiAndGl0bGUtYmxvY2snLFxuICAgICAgICAnOmxhc3QtY2hpbGQnOiB7XG4gICAgICAgICAgICBib3JkZXJMZWZ0OiBgMXB4IHNvbGlkICR7dmFyaWFibGVzLmRpZmZWaWV3ZXJUaXRsZUJvcmRlckNvbG9yfWAsXG4gICAgICAgIH0sXG4gICAgICAgIFtgLiR7Y29udGVudFRleHR9YF06IHtcbiAgICAgICAgICAgIGNvbG9yOiB2YXJpYWJsZXMuZGlmZlZpZXdlclRpdGxlQ29sb3IsXG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgY29uc3QgbGluZU51bWJlciA9ICgwLCBjc3NfMS5jc3MpKHtcbiAgICAgICAgY29sb3I6IHZhcmlhYmxlcy5ndXR0ZXJDb2xvcixcbiAgICAgICAgbGFiZWw6ICdsaW5lLW51bWJlcicsXG4gICAgfSk7XG4gICAgY29uc3QgZGlmZlJlbW92ZWQgPSAoMCwgY3NzXzEuY3NzKSh7XG4gICAgICAgIGJhY2tncm91bmQ6IHZhcmlhYmxlcy5yZW1vdmVkQmFja2dyb3VuZCxcbiAgICAgICAgY29sb3I6IHZhcmlhYmxlcy5yZW1vdmVkQ29sb3IsXG4gICAgICAgIHByZToge1xuICAgICAgICAgICAgY29sb3I6IHZhcmlhYmxlcy5yZW1vdmVkQ29sb3IsXG4gICAgICAgIH0sXG4gICAgICAgIFtgLiR7bGluZU51bWJlcn1gXToge1xuICAgICAgICAgICAgY29sb3I6IHZhcmlhYmxlcy5yZW1vdmVkR3V0dGVyQ29sb3IsXG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsOiAnZGlmZi1yZW1vdmVkJyxcbiAgICB9KTtcbiAgICBjb25zdCBkaWZmQWRkZWQgPSAoMCwgY3NzXzEuY3NzKSh7XG4gICAgICAgIGJhY2tncm91bmQ6IHZhcmlhYmxlcy5hZGRlZEJhY2tncm91bmQsXG4gICAgICAgIGNvbG9yOiB2YXJpYWJsZXMuYWRkZWRDb2xvcixcbiAgICAgICAgcHJlOiB7XG4gICAgICAgICAgICBjb2xvcjogdmFyaWFibGVzLmFkZGVkQ29sb3IsXG4gICAgICAgIH0sXG4gICAgICAgIFtgLiR7bGluZU51bWJlcn1gXToge1xuICAgICAgICAgICAgY29sb3I6IHZhcmlhYmxlcy5hZGRlZEd1dHRlckNvbG9yLFxuICAgICAgICB9LFxuICAgICAgICBsYWJlbDogJ2RpZmYtYWRkZWQnLFxuICAgIH0pO1xuICAgIGNvbnN0IGRpZmZDaGFuZ2VkID0gKDAsIGNzc18xLmNzcykoe1xuICAgICAgICBiYWNrZ3JvdW5kOiB2YXJpYWJsZXMuY2hhbmdlZEJhY2tncm91bmQsXG4gICAgICAgIFtgLiR7bGluZU51bWJlcn1gXToge1xuICAgICAgICAgICAgY29sb3I6IHZhcmlhYmxlcy5ndXR0ZXJDb2xvcixcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWw6ICdkaWZmLWNoYW5nZWQnLFxuICAgIH0pO1xuICAgIGNvbnN0IHdvcmREaWZmID0gKDAsIGNzc18xLmNzcykoe1xuICAgICAgICBwYWRkaW5nOiAyLFxuICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWZsZXgnLFxuICAgICAgICBib3JkZXJSYWRpdXM6IDQsXG4gICAgICAgIHdvcmRCcmVhazogJ2JyZWFrLWFsbCcsXG4gICAgICAgIGxhYmVsOiAnd29yZC1kaWZmJyxcbiAgICB9KTtcbiAgICBjb25zdCB3b3JkQWRkZWQgPSAoMCwgY3NzXzEuY3NzKSh7XG4gICAgICAgIGJhY2tncm91bmQ6IHZhcmlhYmxlcy53b3JkQWRkZWRCYWNrZ3JvdW5kLFxuICAgICAgICBsYWJlbDogJ3dvcmQtYWRkZWQnLFxuICAgIH0pO1xuICAgIGNvbnN0IHdvcmRSZW1vdmVkID0gKDAsIGNzc18xLmNzcykoe1xuICAgICAgICBiYWNrZ3JvdW5kOiB2YXJpYWJsZXMud29yZFJlbW92ZWRCYWNrZ3JvdW5kLFxuICAgICAgICBsYWJlbDogJ3dvcmQtcmVtb3ZlZCcsXG4gICAgfSk7XG4gICAgY29uc3QgY29kZUZvbGRHdXR0ZXIgPSAoMCwgY3NzXzEuY3NzKSh7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdmFyaWFibGVzLmNvZGVGb2xkR3V0dGVyQmFja2dyb3VuZCxcbiAgICAgICAgbGFiZWw6ICdjb2RlLWZvbGQtZ3V0dGVyJyxcbiAgICB9KTtcbiAgICBjb25zdCBjb2RlRm9sZCA9ICgwLCBjc3NfMS5jc3MpKHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB2YXJpYWJsZXMuY29kZUZvbGRCYWNrZ3JvdW5kLFxuICAgICAgICBoZWlnaHQ6IDQwLFxuICAgICAgICBmb250U2l6ZTogMTQsXG4gICAgICAgIGZvbnRXZWlnaHQ6IDcwMCxcbiAgICAgICAgbGFiZWw6ICdjb2RlLWZvbGQnLFxuICAgICAgICBhOiB7XG4gICAgICAgICAgICB0ZXh0RGVjb3JhdGlvbjogJ3VuZGVybGluZSAhaW1wb3J0YW50JyxcbiAgICAgICAgICAgIGN1cnNvcjogJ3BvaW50ZXInLFxuICAgICAgICAgICAgcHJlOiB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ2lubGluZScsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIGNvbnN0IGVtcHR5TGluZSA9ICgwLCBjc3NfMS5jc3MpKHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB2YXJpYWJsZXMuZW1wdHlMaW5lQmFja2dyb3VuZCxcbiAgICAgICAgbGFiZWw6ICdlbXB0eS1saW5lJyxcbiAgICB9KTtcbiAgICBjb25zdCBtYXJrZXIgPSAoMCwgY3NzXzEuY3NzKSh7XG4gICAgICAgIHdpZHRoOiAyNSxcbiAgICAgICAgcGFkZGluZ0xlZnQ6IDEwLFxuICAgICAgICBwYWRkaW5nUmlnaHQ6IDEwLFxuICAgICAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG4gICAgICAgIGxhYmVsOiAnbWFya2VyJyxcbiAgICAgICAgW2AmLiR7ZGlmZkFkZGVkfWBdOiB7XG4gICAgICAgICAgICBwcmU6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogdmFyaWFibGVzLmFkZGVkQ29sb3IsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBbYCYuJHtkaWZmUmVtb3ZlZH1gXToge1xuICAgICAgICAgICAgcHJlOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6IHZhcmlhYmxlcy5yZW1vdmVkQ29sb3IsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIGNvbnN0IGhpZ2hsaWdodGVkTGluZSA9ICgwLCBjc3NfMS5jc3MpKHtcbiAgICAgICAgYmFja2dyb3VuZDogdmFyaWFibGVzLmhpZ2hsaWdodEJhY2tncm91bmQsXG4gICAgICAgIGxhYmVsOiAnaGlnaGxpZ2h0ZWQtbGluZScsXG4gICAgICAgIFtgLiR7d29yZEFkZGVkfSwgLiR7d29yZFJlbW92ZWR9YF06IHtcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ2luaXRpYWwnLFxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIGNvbnN0IGhpZ2hsaWdodGVkR3V0dGVyID0gKDAsIGNzc18xLmNzcykoe1xuICAgICAgICBsYWJlbDogJ2hpZ2hsaWdodGVkLWd1dHRlcicsXG4gICAgfSk7XG4gICAgY29uc3QgZ3V0dGVyID0gKDAsIGNzc18xLmNzcykoe1xuICAgICAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG4gICAgICAgIG1pbldpZHRoOiA1MCxcbiAgICAgICAgcGFkZGluZzogJzAgMTBweCcsXG4gICAgICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICAgICAgICBsYWJlbDogJ2d1dHRlcicsXG4gICAgICAgIHRleHRBbGlnbjogJ3JpZ2h0JyxcbiAgICAgICAgYmFja2dyb3VuZDogdmFyaWFibGVzLmd1dHRlckJhY2tncm91bmQsXG4gICAgICAgICcmOmhvdmVyJzoge1xuICAgICAgICAgICAgY3Vyc29yOiAncG9pbnRlcicsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiB2YXJpYWJsZXMuZ3V0dGVyQmFja2dyb3VuZERhcmssXG4gICAgICAgICAgICBwcmU6IHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgcHJlOiB7XG4gICAgICAgICAgICBvcGFjaXR5OiAwLjUsXG4gICAgICAgIH0sXG4gICAgICAgIFtgJi4ke2RpZmZBZGRlZH1gXToge1xuICAgICAgICAgICAgYmFja2dyb3VuZDogdmFyaWFibGVzLmFkZGVkR3V0dGVyQmFja2dyb3VuZCxcbiAgICAgICAgfSxcbiAgICAgICAgW2AmLiR7ZGlmZlJlbW92ZWR9YF06IHtcbiAgICAgICAgICAgIGJhY2tncm91bmQ6IHZhcmlhYmxlcy5yZW1vdmVkR3V0dGVyQmFja2dyb3VuZCxcbiAgICAgICAgfSxcbiAgICAgICAgW2AmLiR7aGlnaGxpZ2h0ZWRHdXR0ZXJ9YF06IHtcbiAgICAgICAgICAgIGJhY2tncm91bmQ6IHZhcmlhYmxlcy5oaWdobGlnaHRHdXR0ZXJCYWNrZ3JvdW5kLFxuICAgICAgICAgICAgJyY6aG92ZXInOiB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogdmFyaWFibGVzLmhpZ2hsaWdodEd1dHRlckJhY2tncm91bmQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIGNvbnN0IGVtcHR5R3V0dGVyID0gKDAsIGNzc18xLmNzcykoe1xuICAgICAgICAnJjpob3Zlcic6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmQ6IHZhcmlhYmxlcy5ndXR0ZXJCYWNrZ3JvdW5kLFxuICAgICAgICAgICAgY3Vyc29yOiAnaW5pdGlhbCcsXG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsOiAnZW1wdHktZ3V0dGVyJyxcbiAgICB9KTtcbiAgICBjb25zdCBsaW5lID0gKDAsIGNzc18xLmNzcykoe1xuICAgICAgICB2ZXJ0aWNhbEFsaWduOiAnYmFzZWxpbmUnLFxuICAgICAgICBsYWJlbDogJ2xpbmUnLFxuICAgIH0pO1xuICAgIGNvbnN0IGRlZmF1bHRTdHlsZXMgPSB7XG4gICAgICAgIGRpZmZDb250YWluZXIsXG4gICAgICAgIGRpZmZSZW1vdmVkLFxuICAgICAgICBkaWZmQWRkZWQsXG4gICAgICAgIGRpZmZDaGFuZ2VkLFxuICAgICAgICBzcGxpdFZpZXcsXG4gICAgICAgIG1hcmtlcixcbiAgICAgICAgaGlnaGxpZ2h0ZWRHdXR0ZXIsXG4gICAgICAgIGhpZ2hsaWdodGVkTGluZSxcbiAgICAgICAgZ3V0dGVyLFxuICAgICAgICBsaW5lLFxuICAgICAgICB3b3JkRGlmZixcbiAgICAgICAgd29yZEFkZGVkLFxuICAgICAgICB3b3JkUmVtb3ZlZCxcbiAgICAgICAgY29kZUZvbGRHdXR0ZXIsXG4gICAgICAgIGNvZGVGb2xkLFxuICAgICAgICBlbXB0eUd1dHRlcixcbiAgICAgICAgZW1wdHlMaW5lLFxuICAgICAgICBsaW5lTnVtYmVyLFxuICAgICAgICBjb250ZW50VGV4dCxcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgY29kZUZvbGRDb250ZW50LFxuICAgICAgICB0aXRsZUJsb2NrLFxuICAgIH07XG4gICAgY29uc3QgY29tcHV0ZXJPdmVycmlkZVN0eWxlcyA9IE9iamVjdC5rZXlzKHN0eWxlcykucmVkdWNlKChhY2MsIGtleSkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWNjKSwge1xuICAgICAgICBba2V5XTogKDAsIGNzc18xLmNzcykoc3R5bGVzW2tleV0pLFxuICAgIH0pKSwge30pO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhkZWZhdWx0U3R5bGVzKS5yZWR1Y2UoKGFjYywga2V5KSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhY2MpLCB7XG4gICAgICAgIFtrZXldOiBjb21wdXRlck92ZXJyaWRlU3R5bGVzW2tleV1cbiAgICAgICAgICAgID8gKDAsIGNzc18xLmN4KShkZWZhdWx0U3R5bGVzW2tleV0sIGNvbXB1dGVyT3ZlcnJpZGVTdHlsZXNba2V5XSlcbiAgICAgICAgICAgIDogZGVmYXVsdFN0eWxlc1trZXldLFxuICAgIH0pKSwge30pO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/react-diff-viewer-continued@3.2.6_react-dom@19.0.0-rc-65a56d0e-20241020_react@19.0.0-rc-65a56_bap3tgyykoeu7fuj346m5txpry/node_modules/react-diff-viewer-continued/lib/styles.js\n");

/***/ })

};
;